// AUTOGENERATED by bondrewd\tools\tokens\generate_tokens.py on 2023-03-03 20:56:06
// DO NOT EDIT

#pragma once

#include <bondrewd/internal/common.hpp>
#include <bondrewd/lex/scanner.hpp>

#include <string_view>
#include <cstdio>
#include <unordered_map>


namespace bondrewd::lex {


enum class Punct {
    LPAR = 0,
    RPAR = 1,
    LSQB = 2,
    RSQB = 3,
    LBRACE = 4,
    RBRACE = 5,
    COLON = 6,
    DOT = 7,
    COMMA = 8,
    SEMI = 9,
    DOUBLECOLON = 10,
    PLUS = 11,
    MINUS = 12,
    STAR = 13,
    SLASH = 14,
    PERCENT = 15,
    TILDE = 16,
    CIRCUMFLEX = 17,
    VBAR = 18,
    AMPER = 19,
    LEFTSHIFT = 20,
    RIGHTSHIFT = 21,
    EQUAL = 22,
    PLUSEQUAL = 23,
    MINEQUAL = 24,
    STAREQUAL = 25,
    SLASHEQUAL = 26,
    PERCENTEQUAL = 27,
    AMPEREQUAL = 28,
    VBAREQUAL = 29,
    CIRCUMFLEXEQUAL = 30,
    LEFTSHIFTEQUAL = 31,
    RIGHTSHIFTEQUAL = 32,
    DOUBLEEQUAL = 33,
    NOTEQUAL = 34,
    GREATER = 35,
    LESS = 36,
    GREATEREQUAL = 37,
    LESSEQUAL = 38,
    BIDIRCMP = 39,
    AT = 40,
    RARROW = 41,
    RARROW2 = 42,
};


enum class HardKeyword {
    IF = 0,
    THEN = 1,
    ELSE = 2,
    FOR = 3,
    WHILE = 4,
    MATCH = 5,
    CTIME = 6,
    VAR = 7,
    FUNC = 8,
    TRUE = 9,
    FALSE = 10,
    CLASS = 11,
    TRAIT = 12,
    RETURN = 13,
    CARTRIDGE = 14,
    IMPORT = 15,
    EXPORT = 16,
    PUBLIC = 17,
    PROTECTED = 18,
    PRIVATE = 19,
};


const char *punct_to_string(Punct value);

const char *keyword_to_string(HardKeyword value);

extern const std::unordered_map<std::string_view, Punct> string_to_punct;

extern const std::unordered_map<std::string_view, HardKeyword> string_to_keyword;



class MiscTrie {
public:
    #pragma region Verdicts
    enum class Verdict {
        none = 0,
        block_comment = 1,
        line_comment = 2,
        punct = 3,
        string_quote = 4,
    };
    #pragma endregion Verdicts 

    #pragma region Constructors
    MiscTrie() {}
    #pragma endregion Constructors

    #pragma region Service constructors
    MiscTrie(const MiscTrie &) = default;
    MiscTrie(MiscTrie &&) = default;
    MiscTrie &operator=(const MiscTrie &) = default;
    MiscTrie &operator=(MiscTrie &&) = default;
    #pragma endregion Service constructors

    #pragma region Interface
    Verdict feed(Scanner &scanner, Punct *punct, char *quote) {
        auto start_pos = scanner.tell();
    switch (scanner.cur()) {
    case '/': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '/': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "//"

                return Verdict::line_comment;
            } break;
            }
        } break;
        case '*': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "/*"

                return Verdict::block_comment;
            } break;
            }
        } break;
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "/="
                if (punct) {
                    *punct = Punct::SLASHEQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // "/"
            if (punct) {
                *punct = Punct::SLASH;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '#': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "#"

            return Verdict::line_comment;
        } break;
        }
    } break;
    case '(': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "("
            if (punct) {
                *punct = Punct::LPAR;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case ')': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // ")"
            if (punct) {
                *punct = Punct::RPAR;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '[': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "["
            if (punct) {
                *punct = Punct::LSQB;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case ']': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "]"
            if (punct) {
                *punct = Punct::RSQB;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '{': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "{"
            if (punct) {
                *punct = Punct::LBRACE;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '}': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "}"
            if (punct) {
                *punct = Punct::RBRACE;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case ':': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case ':': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "::"
                if (punct) {
                    *punct = Punct::DOUBLECOLON;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // ":"
            if (punct) {
                *punct = Punct::COLON;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '.': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "."
            if (punct) {
                *punct = Punct::DOT;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case ',': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // ","
            if (punct) {
                *punct = Punct::COMMA;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case ';': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // ";"
            if (punct) {
                *punct = Punct::SEMI;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '+': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "+="
                if (punct) {
                    *punct = Punct::PLUSEQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // "+"
            if (punct) {
                *punct = Punct::PLUS;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '-': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "-="
                if (punct) {
                    *punct = Punct::MINEQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        case '>': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "->"
                if (punct) {
                    *punct = Punct::RARROW;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // "-"
            if (punct) {
                *punct = Punct::MINUS;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '*': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "*="
                if (punct) {
                    *punct = Punct::STAREQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // "*"
            if (punct) {
                *punct = Punct::STAR;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '%': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "%="
                if (punct) {
                    *punct = Punct::PERCENTEQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // "%"
            if (punct) {
                *punct = Punct::PERCENT;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '~': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "~"
            if (punct) {
                *punct = Punct::TILDE;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '^': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "^="
                if (punct) {
                    *punct = Punct::CIRCUMFLEXEQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // "^"
            if (punct) {
                *punct = Punct::CIRCUMFLEX;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '|': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "|="
                if (punct) {
                    *punct = Punct::VBAREQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // "|"
            if (punct) {
                *punct = Punct::VBAR;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '&': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "&="
                if (punct) {
                    *punct = Punct::AMPEREQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // "&"
            if (punct) {
                *punct = Punct::AMPER;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '<': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '<': {
            scanner.advance();
            
            switch (scanner.cur()) {
            case '=': {
                scanner.advance();
                
                switch (scanner.cur()) {
                default: {
                    // "<<="
                    if (punct) {
                        *punct = Punct::LEFTSHIFTEQUAL;  // TODO
                    }

                    return Verdict::punct;
                } break;
                }
            } break;
            default: {
                // "<<"
                if (punct) {
                    *punct = Punct::LEFTSHIFT;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            case '>': {
                scanner.advance();
                
                switch (scanner.cur()) {
                default: {
                    // "<=>"
                    if (punct) {
                        *punct = Punct::BIDIRCMP;  // TODO
                    }

                    return Verdict::punct;
                } break;
                }
            } break;
            default: {
                // "<="
                if (punct) {
                    *punct = Punct::LESSEQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // "<"
            if (punct) {
                *punct = Punct::LESS;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '>': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '>': {
            scanner.advance();
            
            switch (scanner.cur()) {
            case '=': {
                scanner.advance();
                
                switch (scanner.cur()) {
                default: {
                    // ">>="
                    if (punct) {
                        *punct = Punct::RIGHTSHIFTEQUAL;  // TODO
                    }

                    return Verdict::punct;
                } break;
                }
            } break;
            default: {
                // ">>"
                if (punct) {
                    *punct = Punct::RIGHTSHIFT;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // ">="
                if (punct) {
                    *punct = Punct::GREATEREQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // ">"
            if (punct) {
                *punct = Punct::GREATER;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '=': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "=="
                if (punct) {
                    *punct = Punct::DOUBLEEQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        case '>': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "=>"
                if (punct) {
                    *punct = Punct::RARROW2;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // "="
            if (punct) {
                *punct = Punct::EQUAL;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '!': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "!="
                if (punct) {
                    *punct = Punct::NOTEQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // ""
            scanner.seek(start_pos);
            scanner.advance(0);

            return Verdict::none;
        } break;
        }
    } break;
    case '@': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "@"
            if (punct) {
                *punct = Punct::AT;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '\'': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "\'"
            if (quote) {
                *quote = '\'';
            }

            return Verdict::string_quote;
        } break;
        }
    } break;
    case '\"': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "\""
            if (quote) {
                *quote = '\"';
            }

            return Verdict::string_quote;
        } break;
        }
    } break;
    default: {
        // ""
        scanner.seek(start_pos);
        scanner.advance(0);

        return Verdict::none;
    } break;
    }
    }
    #pragma endregion Interface

};



class StringTrie {
public:
    #pragma region Verdicts
    enum class Verdict {
        none = 0,
        end_quote = 1,
        escape = 2,
    };
    #pragma endregion Verdicts 

    #pragma region Constructors
    StringTrie() {}
    #pragma endregion Constructors

    #pragma region Service constructors
    StringTrie(const StringTrie &) = default;
    StringTrie(StringTrie &&) = default;
    StringTrie &operator=(const StringTrie &) = default;
    StringTrie &operator=(StringTrie &&) = default;
    #pragma endregion Service constructors

    #pragma region Interface
    Verdict feed(Scanner &scanner, char *quote, int *escape) {
        auto start_pos = scanner.tell();
    switch (scanner.cur()) {
    case '\\': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "\\"
                if (escape) {
                    *escape = scanner.cur();
                    scanner.advance();
                }

            return Verdict::escape;
        } break;
        }
    } break;
    case '\'': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "\'"
                if (quote) {
                    *quote = '\'';
                }

            return Verdict::end_quote;
        } break;
        }
    } break;
    case '\"': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "\""
                if (quote) {
                    *quote = '\"';
                }

            return Verdict::end_quote;
        } break;
        }
    } break;
    default: {
        // ""
        scanner.seek(start_pos);
        scanner.advance(0);

        return Verdict::none;
    } break;
    }
    }
    #pragma endregion Interface

};



class BlockCommentTrie {
public:
    #pragma region Verdicts
    enum class Verdict {
        none = 0,
        end = 1,
        start = 2,
    };
    #pragma endregion Verdicts 

    #pragma region Constructors
    BlockCommentTrie() {}
    #pragma endregion Constructors

    #pragma region Service constructors
    BlockCommentTrie(const BlockCommentTrie &) = default;
    BlockCommentTrie(BlockCommentTrie &&) = default;
    BlockCommentTrie &operator=(const BlockCommentTrie &) = default;
    BlockCommentTrie &operator=(BlockCommentTrie &&) = default;
    #pragma endregion Service constructors

    #pragma region Interface
    Verdict feed(Scanner &scanner) {
        auto start_pos = scanner.tell();
    switch (scanner.cur()) {
    case '/': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '*': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "/*"

                return Verdict::start;
            } break;
            }
        } break;
        default: {
            // ""
            scanner.seek(start_pos);
            scanner.advance(0);

            return Verdict::none;
        } break;
        }
    } break;
    case '*': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '/': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "*/"

                return Verdict::end;
            } break;
            }
        } break;
        default: {
            // ""
            scanner.seek(start_pos);
            scanner.advance(0);

            return Verdict::none;
        } break;
        }
    } break;
    default: {
        // ""
        scanner.seek(start_pos);
        scanner.advance(0);

        return Verdict::none;
    } break;
    }
    }
    #pragma endregion Interface

};


}  // namespace bondrewd::lex
