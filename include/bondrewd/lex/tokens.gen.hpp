// AUTOGENERATED by bondrewd/tools/tokens/generate_tokens.py on 2023-03-10 18:44:38
// DO NOT EDIT

#pragma once

#include <bondrewd/internal/common.hpp>
#include <bondrewd/lex/scanner.hpp>

#include <string_view>
#include <cstdio>
#include <unordered_map>


namespace bondrewd::lex {


enum class Punct {
    LPAR = 0,
    RPAR = 1,
    LSQB = 2,
    RSQB = 3,
    LBRACE = 4,
    RBRACE = 5,
    COLON = 6,
    DOT = 7,
    COMMA = 8,
    SEMI = 9,
    DOUBLECOLON = 10,
    PLUS = 11,
    MINUS = 12,
    STAR = 13,
    SLASH = 14,
    PERCENT = 15,
    POWER = 16,
    TILDE = 17,
    CIRCUMFLEX = 18,
    VBAR = 19,
    AMPER = 20,
    LEFTSHIFT = 21,
    RIGHTSHIFT = 22,
    EQUAL = 23,
    PLUSEQUAL = 24,
    MINEQUAL = 25,
    STAREQUAL = 26,
    SLASHEQUAL = 27,
    PERCENTEQUAL = 28,
    AMPEREQUAL = 29,
    VBAREQUAL = 30,
    CIRCUMFLEXEQUAL = 31,
    LEFTSHIFTEQUAL = 32,
    RIGHTSHIFTEQUAL = 33,
    DOUBLEEQUAL = 34,
    NOTEQUAL = 35,
    GREATER = 36,
    LESS = 37,
    GREATEREQUAL = 38,
    LESSEQUAL = 39,
    BIDIRCMP = 40,
    AT = 41,
    RARROW = 42,
    RARROW2 = 43,
};


enum class HardKeyword {
    AND = 0,
    OR = 1,
    NOT = 2,
    IN = 3,
    IF = 4,
    THEN = 5,
    ELSE = 6,
    FOR = 7,
    WHILE = 8,
    MATCH = 9,
    CTIME = 10,
    VAR = 11,
    FUNC = 12,
    CLASS = 13,
    TRAIT = 14,
    IMPL = 15,
    RETURN = 16,
    BREAK = 17,
    CONTINUE = 18,
    CARTRIDGE = 19,
    IMPORT = 20,
    EXPORT = 21,
    PUBLIC = 22,
    PROTECTED = 23,
    PRIVATE = 24,
};


const char *punct_to_string(Punct value);

const char *keyword_to_string(HardKeyword value);

extern const std::unordered_map<std::string_view, Punct> string_to_punct;

extern const std::unordered_map<std::string_view, HardKeyword> string_to_keyword;



class MiscTrie {
public:
    #pragma region Verdicts
    enum class Verdict {
        none = 0,
        block_comment = 1,
        line_comment = 2,
        punct = 3,
        string_quote = 4,
    };
    #pragma endregion Verdicts 

    #pragma region Constructors
    MiscTrie() {}
    #pragma endregion Constructors

    #pragma region Service constructors
    MiscTrie(const MiscTrie &) = default;
    MiscTrie(MiscTrie &&) = default;
    MiscTrie &operator=(const MiscTrie &) = default;
    MiscTrie &operator=(MiscTrie &&) = default;
    #pragma endregion Service constructors

    #pragma region Interface
    Verdict feed(Scanner &scanner, Punct *punct, std::string_view *quote) {
        auto start_pos = scanner.tell();
    switch (scanner.cur()) {
    case '/': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '/': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "//"

                return Verdict::line_comment;
            } break;
            }
        } break;
        case '*': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "/*"

                return Verdict::block_comment;
            } break;
            }
        } break;
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "/="
                if (punct) {
                    *punct = Punct::SLASHEQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // "/"
            if (punct) {
                *punct = Punct::SLASH;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '#': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "#"

            return Verdict::line_comment;
        } break;
        }
    } break;
    case '(': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "("
            if (punct) {
                *punct = Punct::LPAR;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case ')': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // ")"
            if (punct) {
                *punct = Punct::RPAR;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '[': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "["
            if (punct) {
                *punct = Punct::LSQB;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case ']': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "]"
            if (punct) {
                *punct = Punct::RSQB;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '{': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "{"
            if (punct) {
                *punct = Punct::LBRACE;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '}': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "}"
            if (punct) {
                *punct = Punct::RBRACE;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case ':': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case ':': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "::"
                if (punct) {
                    *punct = Punct::DOUBLECOLON;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // ":"
            if (punct) {
                *punct = Punct::COLON;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '.': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "."
            if (punct) {
                *punct = Punct::DOT;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case ',': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // ","
            if (punct) {
                *punct = Punct::COMMA;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case ';': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // ";"
            if (punct) {
                *punct = Punct::SEMI;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '+': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "+="
                if (punct) {
                    *punct = Punct::PLUSEQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // "+"
            if (punct) {
                *punct = Punct::PLUS;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '-': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "-="
                if (punct) {
                    *punct = Punct::MINEQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        case '>': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "->"
                if (punct) {
                    *punct = Punct::RARROW;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // "-"
            if (punct) {
                *punct = Punct::MINUS;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '*': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '*': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "**"
                if (punct) {
                    *punct = Punct::POWER;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "*="
                if (punct) {
                    *punct = Punct::STAREQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // "*"
            if (punct) {
                *punct = Punct::STAR;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '%': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "%="
                if (punct) {
                    *punct = Punct::PERCENTEQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // "%"
            if (punct) {
                *punct = Punct::PERCENT;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '~': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "~"
            if (punct) {
                *punct = Punct::TILDE;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '^': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "^="
                if (punct) {
                    *punct = Punct::CIRCUMFLEXEQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // "^"
            if (punct) {
                *punct = Punct::CIRCUMFLEX;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '|': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "|="
                if (punct) {
                    *punct = Punct::VBAREQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // "|"
            if (punct) {
                *punct = Punct::VBAR;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '&': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "&="
                if (punct) {
                    *punct = Punct::AMPEREQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // "&"
            if (punct) {
                *punct = Punct::AMPER;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '<': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '<': {
            scanner.advance();
            
            switch (scanner.cur()) {
            case '=': {
                scanner.advance();
                
                switch (scanner.cur()) {
                default: {
                    // "<<="
                    if (punct) {
                        *punct = Punct::LEFTSHIFTEQUAL;  // TODO
                    }

                    return Verdict::punct;
                } break;
                }
            } break;
            default: {
                // "<<"
                if (punct) {
                    *punct = Punct::LEFTSHIFT;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            case '>': {
                scanner.advance();
                
                switch (scanner.cur()) {
                default: {
                    // "<=>"
                    if (punct) {
                        *punct = Punct::BIDIRCMP;  // TODO
                    }

                    return Verdict::punct;
                } break;
                }
            } break;
            default: {
                // "<="
                if (punct) {
                    *punct = Punct::LESSEQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // "<"
            if (punct) {
                *punct = Punct::LESS;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '>': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '>': {
            scanner.advance();
            
            switch (scanner.cur()) {
            case '=': {
                scanner.advance();
                
                switch (scanner.cur()) {
                default: {
                    // ">>="
                    if (punct) {
                        *punct = Punct::RIGHTSHIFTEQUAL;  // TODO
                    }

                    return Verdict::punct;
                } break;
                }
            } break;
            default: {
                // ">>"
                if (punct) {
                    *punct = Punct::RIGHTSHIFT;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // ">="
                if (punct) {
                    *punct = Punct::GREATEREQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // ">"
            if (punct) {
                *punct = Punct::GREATER;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '=': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "=="
                if (punct) {
                    *punct = Punct::DOUBLEEQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        case '>': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "=>"
                if (punct) {
                    *punct = Punct::RARROW2;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // "="
            if (punct) {
                *punct = Punct::EQUAL;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '!': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '=': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "!="
                if (punct) {
                    *punct = Punct::NOTEQUAL;  // TODO
                }

                return Verdict::punct;
            } break;
            }
        } break;
        default: {
            // ""
            scanner.seek(start_pos);
            scanner.advance(0);

            return Verdict::none;
        } break;
        }
    } break;
    case '@': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "@"
            if (punct) {
                *punct = Punct::AT;  // TODO
            }

            return Verdict::punct;
        } break;
        }
    } break;
    case '\'': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '\'': {
            scanner.advance();
            
            switch (scanner.cur()) {
            case '\'': {
                scanner.advance();
                
                switch (scanner.cur()) {
                default: {
                    // "\'\'\'"
                    if (quote) {
                        *quote = "\'\'\'";
                    }

                    return Verdict::string_quote;
                } break;
                }
            } break;
            default: {
                // "\'"
                scanner.seek(start_pos);
                scanner.advance(1);
                if (quote) {
                    *quote = "\'";
                }

                return Verdict::string_quote;
            } break;
            }
        } break;
        default: {
            // "\'"
            if (quote) {
                *quote = "\'";
            }

            return Verdict::string_quote;
        } break;
        }
    } break;
    case '\"': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '\"': {
            scanner.advance();
            
            switch (scanner.cur()) {
            case '\"': {
                scanner.advance();
                
                switch (scanner.cur()) {
                default: {
                    // "\"\"\""
                    if (quote) {
                        *quote = "\"\"\"";
                    }

                    return Verdict::string_quote;
                } break;
                }
            } break;
            default: {
                // "\""
                scanner.seek(start_pos);
                scanner.advance(1);
                if (quote) {
                    *quote = "\"";
                }

                return Verdict::string_quote;
            } break;
            }
        } break;
        default: {
            // "\""
            if (quote) {
                *quote = "\"";
            }

            return Verdict::string_quote;
        } break;
        }
    } break;
    default: {
        // ""
        scanner.seek(start_pos);
        scanner.advance(0);

        return Verdict::none;
    } break;
    }
    }
    #pragma endregion Interface

};



class StringTrie {
public:
    #pragma region Verdicts
    enum class Verdict {
        none = 0,
        end_quote = 1,
        escape = 2,
        newline = 3,
    };
    #pragma endregion Verdicts 

    #pragma region Constructors
    StringTrie() {}
    #pragma endregion Constructors

    #pragma region Service constructors
    StringTrie(const StringTrie &) = default;
    StringTrie(StringTrie &&) = default;
    StringTrie &operator=(const StringTrie &) = default;
    StringTrie &operator=(StringTrie &&) = default;
    #pragma endregion Service constructors

    #pragma region Interface
    Verdict feed(Scanner &scanner, std::string_view *quote, int *escape) {
        auto start_pos = scanner.tell();
    switch (scanner.cur()) {
    case '\\': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "\\"
                if (escape) {
                    *escape = scanner.cur();
                    scanner.advance();
                }

            return Verdict::escape;
        } break;
        }
    } break;
    case '\n': {
        scanner.advance();
        
        switch (scanner.cur()) {
        default: {
            // "\n"

            return Verdict::newline;
        } break;
        }
    } break;
    case '\'': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '\'': {
            scanner.advance();
            
            switch (scanner.cur()) {
            case '\'': {
                scanner.advance();
                
                switch (scanner.cur()) {
                default: {
                    // "\'\'\'"
                        if (quote) {
                            *quote = "\'\'\'";
                        }

                    return Verdict::end_quote;
                } break;
                }
            } break;
            default: {
                // "\'"
                scanner.seek(start_pos);
                scanner.advance(1);
                    if (quote) {
                        *quote = "\'";
                    }

                return Verdict::end_quote;
            } break;
            }
        } break;
        default: {
            // "\'"
                if (quote) {
                    *quote = "\'";
                }

            return Verdict::end_quote;
        } break;
        }
    } break;
    case '\"': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '\"': {
            scanner.advance();
            
            switch (scanner.cur()) {
            case '\"': {
                scanner.advance();
                
                switch (scanner.cur()) {
                default: {
                    // "\"\"\""
                        if (quote) {
                            *quote = "\"\"\"";
                        }

                    return Verdict::end_quote;
                } break;
                }
            } break;
            default: {
                // "\""
                scanner.seek(start_pos);
                scanner.advance(1);
                    if (quote) {
                        *quote = "\"";
                    }

                return Verdict::end_quote;
            } break;
            }
        } break;
        default: {
            // "\""
                if (quote) {
                    *quote = "\"";
                }

            return Verdict::end_quote;
        } break;
        }
    } break;
    default: {
        // ""
        scanner.seek(start_pos);
        scanner.advance(0);

        return Verdict::none;
    } break;
    }
    }
    #pragma endregion Interface

};



class BlockCommentTrie {
public:
    #pragma region Verdicts
    enum class Verdict {
        none = 0,
        end = 1,
        start = 2,
    };
    #pragma endregion Verdicts 

    #pragma region Constructors
    BlockCommentTrie() {}
    #pragma endregion Constructors

    #pragma region Service constructors
    BlockCommentTrie(const BlockCommentTrie &) = default;
    BlockCommentTrie(BlockCommentTrie &&) = default;
    BlockCommentTrie &operator=(const BlockCommentTrie &) = default;
    BlockCommentTrie &operator=(BlockCommentTrie &&) = default;
    #pragma endregion Service constructors

    #pragma region Interface
    Verdict feed(Scanner &scanner) {
        auto start_pos = scanner.tell();
    switch (scanner.cur()) {
    case '/': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '*': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "/*"

                return Verdict::start;
            } break;
            }
        } break;
        default: {
            // ""
            scanner.seek(start_pos);
            scanner.advance(0);

            return Verdict::none;
        } break;
        }
    } break;
    case '*': {
        scanner.advance();
        
        switch (scanner.cur()) {
        case '/': {
            scanner.advance();
            
            switch (scanner.cur()) {
            default: {
                // "*/"

                return Verdict::end;
            } break;
            }
        } break;
        default: {
            // ""
            scanner.seek(start_pos);
            scanner.advance(0);

            return Verdict::none;
        } break;
        }
    } break;
    default: {
        // ""
        scanner.seek(start_pos);
        scanner.advance(0);

        return Verdict::none;
    } break;
    }
    }
    #pragma endregion Interface

};


}  // namespace bondrewd::lex
