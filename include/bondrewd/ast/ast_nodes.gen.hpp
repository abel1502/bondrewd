// AUTOGENERATED by bondrewd/tools/asdl++/asdl_cpp.py on 2023-03-13 08:07:46
// DO NOT EDIT

#pragma once

#include <bondrewd/internal/common.hpp>
#include <bondrewd/ast/ast.hpp>


namespace bondrewd::ast::nodes {


#pragma region Forward declarations
class cartridge;
class Cartridge;
class stmt;
class VarDef;
class Impl;
class Assign;
class Expr;
class Pass;
class expr;
class Name;
class Constant;
class Attribute;
class Call;
class Subscript;
class Block;
class FuncDef;
class ClassDef;
class BinOp;
class UnOp;
class Compare;
class BoolOp;
class If;
class For;
class While;
class Return;
class Break;
class Continue;
class Tuple;
class Array;
class assign_op;
class AsgnNone;
class AsgnAdd;
class AsgnSub;
class AsgnMul;
class AsgnDiv;
class AsgnMod;
class AsgnLShift;
class AsgnRShift;
class AsgnBitOr;
class AsgnBitXor;
class AsgnBitAnd;
class bool_op;
class And;
class Or;
class binary_op;
class Add;
class Sub;
class Mul;
class Div;
class Mod;
class Pow;
class LShift;
class RShift;
class BitOr;
class BitXor;
class BitAnd;
class BidirCmp;
class unary_op;
class BitInv;
class Not;
class UAdd;
class USub;
class cmp_op;
class Eq;
class NotEq;
class Lt;
class LtE;
class Gt;
class GtE;
class In;
class NotIn;
class attr_op;
class AttrInst;
class AttrStatic;
class expr_context;
class Load;
class Store;
class arg_defs;
class arg_def;
class call_args;
class call_arg;
#pragma endregion Forward declarations


#pragma region Implementations
class Cartridge : _ConcreteASTNode {
public:
    #pragma region Fields
    string name;
    sequence<stmt> body;
    #pragma endregion Fields

    #pragma region Constructors
    Cartridge(string name, sequence<stmt> body) :
        name{std::move(name)}, body{std::move(body)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Cartridge(const Cartridge &) = delete;
    Cartridge(Cartridge &&) = default;
    Cartridge &operator=(const Cartridge &) = delete;
    Cartridge &operator=(Cartridge &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(name, body);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<cartridge>() const {
        return ast::make_field<cartridge>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class cartridge : public _AST<Cartridge> {
public:
    #pragma region Constructors
    cartridge(auto &&value_)
        : _AST(std::forward<decltype(value_)>(value_)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    cartridge(const cartridge &) = delete;
    cartridge(cartridge &&) = default;
    cartridge &operator=(const cartridge &) = delete;
    cartridge &operator=(cartridge &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~cartridge() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    #pragma endregion Attributes

    #pragma region Extras
    
    #pragma endregion Extras
};


class VarDef : _ConcreteASTNode {
public:
    #pragma region Fields
    identifier name;
    maybe<expr> type;
    maybe<expr> value;
    bool mut;
    bool ctime;
    #pragma endregion Fields

    #pragma region Constructors
    VarDef(identifier name, maybe<expr> type, maybe<expr> value, bool mut, bool ctime) :
        name{std::move(name)}, type{std::move(type)}, value{std::move(value)}, mut{std::move(mut)}, ctime{std::move(ctime)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    VarDef(const VarDef &) = delete;
    VarDef(VarDef &&) = default;
    VarDef &operator=(const VarDef &) = delete;
    VarDef &operator=(VarDef &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(name, type, value, mut, ctime);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<stmt>() const {
        return ast::make_field<stmt>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Impl : _ConcreteASTNode {
public:
    #pragma region Fields
    identifier class_name;
    std::optional<identifier> trait_name;
    field<expr> body;
    bool ctime;
    #pragma endregion Fields

    #pragma region Constructors
    Impl(identifier class_name, std::optional<identifier> trait_name, field<expr> body, bool ctime) :
        class_name{std::move(class_name)}, trait_name{std::move(trait_name)}, body{std::move(body)}, ctime{std::move(ctime)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Impl(const Impl &) = delete;
    Impl(Impl &&) = default;
    Impl &operator=(const Impl &) = delete;
    Impl &operator=(Impl &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(class_name, trait_name, body, ctime);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<stmt>() const {
        return ast::make_field<stmt>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Assign : _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> target;
    field<expr> value;
    field<assign_op> op;
    #pragma endregion Fields

    #pragma region Constructors
    Assign(field<expr> target, field<expr> value, field<assign_op> op) :
        target{std::move(target)}, value{std::move(value)}, op{std::move(op)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Assign(const Assign &) = delete;
    Assign(Assign &&) = default;
    Assign &operator=(const Assign &) = delete;
    Assign &operator=(Assign &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(target, value, op);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<stmt>() const {
        return ast::make_field<stmt>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Expr : _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> value;
    #pragma endregion Fields

    #pragma region Constructors
    Expr(field<expr> value) :
        value{std::move(value)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Expr(const Expr &) = delete;
    Expr(Expr &&) = default;
    Expr &operator=(const Expr &) = delete;
    Expr &operator=(Expr &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(value);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<stmt>() const {
        return ast::make_field<stmt>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Pass : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Pass() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Pass(const Pass &) = delete;
    Pass(Pass &&) = default;
    Pass &operator=(const Pass &) = delete;
    Pass &operator=(Pass &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<stmt>() const {
        return ast::make_field<stmt>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class stmt : public _AST<VarDef, Impl, Assign, Expr, Pass> {
public:
    #pragma region Constructors
    stmt(auto &&value_)
        : _AST(std::forward<decltype(value_)>(value_)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    stmt(const stmt &) = delete;
    stmt(stmt &&) = default;
    stmt &operator=(const stmt &) = delete;
    stmt &operator=(stmt &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~stmt() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    #pragma endregion Attributes

    #pragma region Extras
    
    #pragma endregion Extras
};


class Name : _ConcreteASTNode {
public:
    #pragma region Fields
    identifier value;
    #pragma endregion Fields

    #pragma region Constructors
    Name(identifier value) :
        value{std::move(value)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Name(const Name &) = delete;
    Name(Name &&) = default;
    Name &operator=(const Name &) = delete;
    Name &operator=(Name &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(value);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() const {
        return ast::make_field<expr>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Constant : _ConcreteASTNode {
public:
    #pragma region Fields
    constant value;
    #pragma endregion Fields

    #pragma region Constructors
    Constant(constant value) :
        value{std::move(value)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Constant(const Constant &) = delete;
    Constant(Constant &&) = default;
    Constant &operator=(const Constant &) = delete;
    Constant &operator=(Constant &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(value);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() const {
        return ast::make_field<expr>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Attribute : _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> value;
    identifier attr;
    field<attr_op> type;
    #pragma endregion Fields

    #pragma region Constructors
    Attribute(field<expr> value, identifier attr, field<attr_op> type) :
        value{std::move(value)}, attr{std::move(attr)}, type{std::move(type)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Attribute(const Attribute &) = delete;
    Attribute(Attribute &&) = default;
    Attribute &operator=(const Attribute &) = delete;
    Attribute &operator=(Attribute &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(value, attr, type);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() const {
        return ast::make_field<expr>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Call : _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> func;
    field<call_args> args;
    #pragma endregion Fields

    #pragma region Constructors
    Call(field<expr> func, field<call_args> args) :
        func{std::move(func)}, args{std::move(args)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Call(const Call &) = delete;
    Call(Call &&) = default;
    Call &operator=(const Call &) = delete;
    Call &operator=(Call &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(func, args);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() const {
        return ast::make_field<expr>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Subscript : _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> value;
    field<call_args> args;
    #pragma endregion Fields

    #pragma region Constructors
    Subscript(field<expr> value, field<call_args> args) :
        value{std::move(value)}, args{std::move(args)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Subscript(const Subscript &) = delete;
    Subscript(Subscript &&) = default;
    Subscript &operator=(const Subscript &) = delete;
    Subscript &operator=(Subscript &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(value, args);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() const {
        return ast::make_field<expr>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Block : _ConcreteASTNode {
public:
    #pragma region Fields
    sequence<stmt> body;
    field<expr> value;
    bool ctime;
    #pragma endregion Fields

    #pragma region Constructors
    Block(sequence<stmt> body, field<expr> value, bool ctime) :
        body{std::move(body)}, value{std::move(value)}, ctime{std::move(ctime)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Block(const Block &) = delete;
    Block(Block &&) = default;
    Block &operator=(const Block &) = delete;
    Block &operator=(Block &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(body, value, ctime);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() const {
        return ast::make_field<expr>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class FuncDef : _ConcreteASTNode {
public:
    #pragma region Fields
    identifier name;
    field<arg_defs> args;
    maybe<expr> return_type;
    field<expr> body;
    #pragma endregion Fields

    #pragma region Constructors
    FuncDef(identifier name, field<arg_defs> args, maybe<expr> return_type, field<expr> body) :
        name{std::move(name)}, args{std::move(args)}, return_type{std::move(return_type)}, body{std::move(body)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    FuncDef(const FuncDef &) = delete;
    FuncDef(FuncDef &&) = default;
    FuncDef &operator=(const FuncDef &) = delete;
    FuncDef &operator=(FuncDef &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(name, args, return_type, body);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() const {
        return ast::make_field<expr>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class ClassDef : _ConcreteASTNode {
public:
    #pragma region Fields
    identifier name;
    field<expr> body;
    bool ctime;
    #pragma endregion Fields

    #pragma region Constructors
    ClassDef(identifier name, field<expr> body, bool ctime) :
        name{std::move(name)}, body{std::move(body)}, ctime{std::move(ctime)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    ClassDef(const ClassDef &) = delete;
    ClassDef(ClassDef &&) = default;
    ClassDef &operator=(const ClassDef &) = delete;
    ClassDef &operator=(ClassDef &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(name, body, ctime);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() const {
        return ast::make_field<expr>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class BinOp : _ConcreteASTNode {
public:
    #pragma region Fields
    field<binary_op> op;
    field<expr> left;
    field<expr> right;
    #pragma endregion Fields

    #pragma region Constructors
    BinOp(field<binary_op> op, field<expr> left, field<expr> right) :
        op{std::move(op)}, left{std::move(left)}, right{std::move(right)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    BinOp(const BinOp &) = delete;
    BinOp(BinOp &&) = default;
    BinOp &operator=(const BinOp &) = delete;
    BinOp &operator=(BinOp &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(op, left, right);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() const {
        return ast::make_field<expr>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class UnOp : _ConcreteASTNode {
public:
    #pragma region Fields
    field<unary_op> op;
    field<expr> operand;
    #pragma endregion Fields

    #pragma region Constructors
    UnOp(field<unary_op> op, field<expr> operand) :
        op{std::move(op)}, operand{std::move(operand)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    UnOp(const UnOp &) = delete;
    UnOp(UnOp &&) = default;
    UnOp &operator=(const UnOp &) = delete;
    UnOp &operator=(UnOp &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(op, operand);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() const {
        return ast::make_field<expr>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Compare : _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> left;
    sequence<cmp_op> op;
    sequence<expr> operands;
    #pragma endregion Fields

    #pragma region Constructors
    Compare(field<expr> left, sequence<cmp_op> op, sequence<expr> operands) :
        left{std::move(left)}, op{std::move(op)}, operands{std::move(operands)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Compare(const Compare &) = delete;
    Compare(Compare &&) = default;
    Compare &operator=(const Compare &) = delete;
    Compare &operator=(Compare &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(left, op, operands);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() const {
        return ast::make_field<expr>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class BoolOp : _ConcreteASTNode {
public:
    #pragma region Fields
    field<bool_op> op;
    sequence<expr> values;
    #pragma endregion Fields

    #pragma region Constructors
    BoolOp(field<bool_op> op, sequence<expr> values) :
        op{std::move(op)}, values{std::move(values)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    BoolOp(const BoolOp &) = delete;
    BoolOp(BoolOp &&) = default;
    BoolOp &operator=(const BoolOp &) = delete;
    BoolOp &operator=(BoolOp &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(op, values);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() const {
        return ast::make_field<expr>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class If : _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> cond;
    field<expr> body;
    field<expr> orelse;
    #pragma endregion Fields

    #pragma region Constructors
    If(field<expr> cond, field<expr> body, field<expr> orelse) :
        cond{std::move(cond)}, body{std::move(body)}, orelse{std::move(orelse)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    If(const If &) = delete;
    If(If &&) = default;
    If &operator=(const If &) = delete;
    If &operator=(If &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(cond, body, orelse);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() const {
        return ast::make_field<expr>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class For : _ConcreteASTNode {
public:
    #pragma region Fields
    identifier var;
    field<expr> iter;
    field<expr> body;
    field<expr> orelse;
    #pragma endregion Fields

    #pragma region Constructors
    For(identifier var, field<expr> iter, field<expr> body, field<expr> orelse) :
        var{std::move(var)}, iter{std::move(iter)}, body{std::move(body)}, orelse{std::move(orelse)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    For(const For &) = delete;
    For(For &&) = default;
    For &operator=(const For &) = delete;
    For &operator=(For &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(var, iter, body, orelse);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() const {
        return ast::make_field<expr>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class While : _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> cond;
    field<expr> body;
    maybe<expr> orelse;
    #pragma endregion Fields

    #pragma region Constructors
    While(field<expr> cond, field<expr> body, maybe<expr> orelse) :
        cond{std::move(cond)}, body{std::move(body)}, orelse{std::move(orelse)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    While(const While &) = delete;
    While(While &&) = default;
    While &operator=(const While &) = delete;
    While &operator=(While &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(cond, body, orelse);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() const {
        return ast::make_field<expr>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Return : _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> value;
    #pragma endregion Fields

    #pragma region Constructors
    Return(field<expr> value) :
        value{std::move(value)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Return(const Return &) = delete;
    Return(Return &&) = default;
    Return &operator=(const Return &) = delete;
    Return &operator=(Return &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(value);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() const {
        return ast::make_field<expr>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Break : _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> value;
    #pragma endregion Fields

    #pragma region Constructors
    Break(field<expr> value) :
        value{std::move(value)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Break(const Break &) = delete;
    Break(Break &&) = default;
    Break &operator=(const Break &) = delete;
    Break &operator=(Break &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(value);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() const {
        return ast::make_field<expr>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Continue : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Continue() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Continue(const Continue &) = delete;
    Continue(Continue &&) = default;
    Continue &operator=(const Continue &) = delete;
    Continue &operator=(Continue &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() const {
        return ast::make_field<expr>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Tuple : _ConcreteASTNode {
public:
    #pragma region Fields
    sequence<expr> values;
    #pragma endregion Fields

    #pragma region Constructors
    Tuple(sequence<expr> values) :
        values{std::move(values)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Tuple(const Tuple &) = delete;
    Tuple(Tuple &&) = default;
    Tuple &operator=(const Tuple &) = delete;
    Tuple &operator=(Tuple &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(values);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() const {
        return ast::make_field<expr>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Array : _ConcreteASTNode {
public:
    #pragma region Fields
    sequence<expr> values;
    #pragma endregion Fields

    #pragma region Constructors
    Array(sequence<expr> values) :
        values{std::move(values)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Array(const Array &) = delete;
    Array(Array &&) = default;
    Array &operator=(const Array &) = delete;
    Array &operator=(Array &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(values);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() const {
        return ast::make_field<expr>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class expr : public _AST<Name, Constant, Attribute, Call, Subscript, Block, FuncDef, ClassDef, BinOp, UnOp, Compare, BoolOp, If, For, While, Return, Break, Continue, Tuple, Array> {
public:
    #pragma region Constructors
    expr(auto &&value_)
        : _AST(std::forward<decltype(value_)>(value_)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    expr(const expr &) = delete;
    expr(expr &&) = default;
    expr &operator=(const expr &) = delete;
    expr &operator=(expr &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~expr() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    #pragma endregion Attributes

    #pragma region Extras
    
    #pragma endregion Extras
};


class AsgnNone : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AsgnNone() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AsgnNone(const AsgnNone &) = delete;
    AsgnNone(AsgnNone &&) = default;
    AsgnNone &operator=(const AsgnNone &) = delete;
    AsgnNone &operator=(AsgnNone &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<assign_op>() const {
        return ast::make_field<assign_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class AsgnAdd : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AsgnAdd() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AsgnAdd(const AsgnAdd &) = delete;
    AsgnAdd(AsgnAdd &&) = default;
    AsgnAdd &operator=(const AsgnAdd &) = delete;
    AsgnAdd &operator=(AsgnAdd &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<assign_op>() const {
        return ast::make_field<assign_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class AsgnSub : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AsgnSub() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AsgnSub(const AsgnSub &) = delete;
    AsgnSub(AsgnSub &&) = default;
    AsgnSub &operator=(const AsgnSub &) = delete;
    AsgnSub &operator=(AsgnSub &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<assign_op>() const {
        return ast::make_field<assign_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class AsgnMul : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AsgnMul() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AsgnMul(const AsgnMul &) = delete;
    AsgnMul(AsgnMul &&) = default;
    AsgnMul &operator=(const AsgnMul &) = delete;
    AsgnMul &operator=(AsgnMul &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<assign_op>() const {
        return ast::make_field<assign_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class AsgnDiv : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AsgnDiv() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AsgnDiv(const AsgnDiv &) = delete;
    AsgnDiv(AsgnDiv &&) = default;
    AsgnDiv &operator=(const AsgnDiv &) = delete;
    AsgnDiv &operator=(AsgnDiv &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<assign_op>() const {
        return ast::make_field<assign_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class AsgnMod : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AsgnMod() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AsgnMod(const AsgnMod &) = delete;
    AsgnMod(AsgnMod &&) = default;
    AsgnMod &operator=(const AsgnMod &) = delete;
    AsgnMod &operator=(AsgnMod &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<assign_op>() const {
        return ast::make_field<assign_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class AsgnLShift : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AsgnLShift() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AsgnLShift(const AsgnLShift &) = delete;
    AsgnLShift(AsgnLShift &&) = default;
    AsgnLShift &operator=(const AsgnLShift &) = delete;
    AsgnLShift &operator=(AsgnLShift &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<assign_op>() const {
        return ast::make_field<assign_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class AsgnRShift : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AsgnRShift() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AsgnRShift(const AsgnRShift &) = delete;
    AsgnRShift(AsgnRShift &&) = default;
    AsgnRShift &operator=(const AsgnRShift &) = delete;
    AsgnRShift &operator=(AsgnRShift &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<assign_op>() const {
        return ast::make_field<assign_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class AsgnBitOr : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AsgnBitOr() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AsgnBitOr(const AsgnBitOr &) = delete;
    AsgnBitOr(AsgnBitOr &&) = default;
    AsgnBitOr &operator=(const AsgnBitOr &) = delete;
    AsgnBitOr &operator=(AsgnBitOr &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<assign_op>() const {
        return ast::make_field<assign_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class AsgnBitXor : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AsgnBitXor() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AsgnBitXor(const AsgnBitXor &) = delete;
    AsgnBitXor(AsgnBitXor &&) = default;
    AsgnBitXor &operator=(const AsgnBitXor &) = delete;
    AsgnBitXor &operator=(AsgnBitXor &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<assign_op>() const {
        return ast::make_field<assign_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class AsgnBitAnd : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AsgnBitAnd() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AsgnBitAnd(const AsgnBitAnd &) = delete;
    AsgnBitAnd(AsgnBitAnd &&) = default;
    AsgnBitAnd &operator=(const AsgnBitAnd &) = delete;
    AsgnBitAnd &operator=(AsgnBitAnd &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<assign_op>() const {
        return ast::make_field<assign_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class assign_op : public _AST<AsgnNone, AsgnAdd, AsgnSub, AsgnMul, AsgnDiv, AsgnMod, AsgnLShift, AsgnRShift, AsgnBitOr, AsgnBitXor, AsgnBitAnd> {
public:
    #pragma region Constructors
    assign_op(auto &&value_)
        : _AST(std::forward<decltype(value_)>(value_)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    assign_op(const assign_op &) = delete;
    assign_op(assign_op &&) = default;
    assign_op &operator=(const assign_op &) = delete;
    assign_op &operator=(assign_op &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~assign_op() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    #pragma endregion Attributes

    #pragma region Extras
    
    #pragma endregion Extras
};


class And : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    And() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    And(const And &) = delete;
    And(And &&) = default;
    And &operator=(const And &) = delete;
    And &operator=(And &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<bool_op>() const {
        return ast::make_field<bool_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Or : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Or() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Or(const Or &) = delete;
    Or(Or &&) = default;
    Or &operator=(const Or &) = delete;
    Or &operator=(Or &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<bool_op>() const {
        return ast::make_field<bool_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class bool_op : public _AST<And, Or> {
public:
    #pragma region Constructors
    bool_op(auto &&value_)
        : _AST(std::forward<decltype(value_)>(value_)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    bool_op(const bool_op &) = delete;
    bool_op(bool_op &&) = default;
    bool_op &operator=(const bool_op &) = delete;
    bool_op &operator=(bool_op &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~bool_op() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    #pragma endregion Attributes

    #pragma region Extras
    
    #pragma endregion Extras
};


class Add : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Add() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Add(const Add &) = delete;
    Add(Add &&) = default;
    Add &operator=(const Add &) = delete;
    Add &operator=(Add &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() const {
        return ast::make_field<binary_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Sub : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Sub() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Sub(const Sub &) = delete;
    Sub(Sub &&) = default;
    Sub &operator=(const Sub &) = delete;
    Sub &operator=(Sub &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() const {
        return ast::make_field<binary_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Mul : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Mul() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Mul(const Mul &) = delete;
    Mul(Mul &&) = default;
    Mul &operator=(const Mul &) = delete;
    Mul &operator=(Mul &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() const {
        return ast::make_field<binary_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Div : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Div() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Div(const Div &) = delete;
    Div(Div &&) = default;
    Div &operator=(const Div &) = delete;
    Div &operator=(Div &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() const {
        return ast::make_field<binary_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Mod : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Mod() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Mod(const Mod &) = delete;
    Mod(Mod &&) = default;
    Mod &operator=(const Mod &) = delete;
    Mod &operator=(Mod &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() const {
        return ast::make_field<binary_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Pow : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Pow() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Pow(const Pow &) = delete;
    Pow(Pow &&) = default;
    Pow &operator=(const Pow &) = delete;
    Pow &operator=(Pow &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() const {
        return ast::make_field<binary_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class LShift : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    LShift() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    LShift(const LShift &) = delete;
    LShift(LShift &&) = default;
    LShift &operator=(const LShift &) = delete;
    LShift &operator=(LShift &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() const {
        return ast::make_field<binary_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class RShift : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    RShift() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    RShift(const RShift &) = delete;
    RShift(RShift &&) = default;
    RShift &operator=(const RShift &) = delete;
    RShift &operator=(RShift &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() const {
        return ast::make_field<binary_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class BitOr : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    BitOr() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    BitOr(const BitOr &) = delete;
    BitOr(BitOr &&) = default;
    BitOr &operator=(const BitOr &) = delete;
    BitOr &operator=(BitOr &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() const {
        return ast::make_field<binary_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class BitXor : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    BitXor() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    BitXor(const BitXor &) = delete;
    BitXor(BitXor &&) = default;
    BitXor &operator=(const BitXor &) = delete;
    BitXor &operator=(BitXor &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() const {
        return ast::make_field<binary_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class BitAnd : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    BitAnd() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    BitAnd(const BitAnd &) = delete;
    BitAnd(BitAnd &&) = default;
    BitAnd &operator=(const BitAnd &) = delete;
    BitAnd &operator=(BitAnd &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() const {
        return ast::make_field<binary_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class BidirCmp : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    BidirCmp() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    BidirCmp(const BidirCmp &) = delete;
    BidirCmp(BidirCmp &&) = default;
    BidirCmp &operator=(const BidirCmp &) = delete;
    BidirCmp &operator=(BidirCmp &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() const {
        return ast::make_field<binary_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class binary_op : public _AST<Add, Sub, Mul, Div, Mod, Pow, LShift, RShift, BitOr, BitXor, BitAnd, BidirCmp> {
public:
    #pragma region Constructors
    binary_op(auto &&value_)
        : _AST(std::forward<decltype(value_)>(value_)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    binary_op(const binary_op &) = delete;
    binary_op(binary_op &&) = default;
    binary_op &operator=(const binary_op &) = delete;
    binary_op &operator=(binary_op &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~binary_op() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    #pragma endregion Attributes

    #pragma region Extras
    
    #pragma endregion Extras
};


class BitInv : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    BitInv() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    BitInv(const BitInv &) = delete;
    BitInv(BitInv &&) = default;
    BitInv &operator=(const BitInv &) = delete;
    BitInv &operator=(BitInv &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<unary_op>() const {
        return ast::make_field<unary_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Not : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Not() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Not(const Not &) = delete;
    Not(Not &&) = default;
    Not &operator=(const Not &) = delete;
    Not &operator=(Not &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<unary_op>() const {
        return ast::make_field<unary_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class UAdd : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    UAdd() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    UAdd(const UAdd &) = delete;
    UAdd(UAdd &&) = default;
    UAdd &operator=(const UAdd &) = delete;
    UAdd &operator=(UAdd &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<unary_op>() const {
        return ast::make_field<unary_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class USub : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    USub() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    USub(const USub &) = delete;
    USub(USub &&) = default;
    USub &operator=(const USub &) = delete;
    USub &operator=(USub &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<unary_op>() const {
        return ast::make_field<unary_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class unary_op : public _AST<BitInv, Not, UAdd, USub> {
public:
    #pragma region Constructors
    unary_op(auto &&value_)
        : _AST(std::forward<decltype(value_)>(value_)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    unary_op(const unary_op &) = delete;
    unary_op(unary_op &&) = default;
    unary_op &operator=(const unary_op &) = delete;
    unary_op &operator=(unary_op &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~unary_op() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    #pragma endregion Attributes

    #pragma region Extras
    
    #pragma endregion Extras
};


class Eq : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Eq() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Eq(const Eq &) = delete;
    Eq(Eq &&) = default;
    Eq &operator=(const Eq &) = delete;
    Eq &operator=(Eq &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<cmp_op>() const {
        return ast::make_field<cmp_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class NotEq : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    NotEq() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    NotEq(const NotEq &) = delete;
    NotEq(NotEq &&) = default;
    NotEq &operator=(const NotEq &) = delete;
    NotEq &operator=(NotEq &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<cmp_op>() const {
        return ast::make_field<cmp_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Lt : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Lt() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Lt(const Lt &) = delete;
    Lt(Lt &&) = default;
    Lt &operator=(const Lt &) = delete;
    Lt &operator=(Lt &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<cmp_op>() const {
        return ast::make_field<cmp_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class LtE : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    LtE() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    LtE(const LtE &) = delete;
    LtE(LtE &&) = default;
    LtE &operator=(const LtE &) = delete;
    LtE &operator=(LtE &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<cmp_op>() const {
        return ast::make_field<cmp_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Gt : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Gt() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Gt(const Gt &) = delete;
    Gt(Gt &&) = default;
    Gt &operator=(const Gt &) = delete;
    Gt &operator=(Gt &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<cmp_op>() const {
        return ast::make_field<cmp_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class GtE : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    GtE() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    GtE(const GtE &) = delete;
    GtE(GtE &&) = default;
    GtE &operator=(const GtE &) = delete;
    GtE &operator=(GtE &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<cmp_op>() const {
        return ast::make_field<cmp_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class In : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    In() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    In(const In &) = delete;
    In(In &&) = default;
    In &operator=(const In &) = delete;
    In &operator=(In &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<cmp_op>() const {
        return ast::make_field<cmp_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class NotIn : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    NotIn() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    NotIn(const NotIn &) = delete;
    NotIn(NotIn &&) = default;
    NotIn &operator=(const NotIn &) = delete;
    NotIn &operator=(NotIn &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<cmp_op>() const {
        return ast::make_field<cmp_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class cmp_op : public _AST<Eq, NotEq, Lt, LtE, Gt, GtE, In, NotIn> {
public:
    #pragma region Constructors
    cmp_op(auto &&value_)
        : _AST(std::forward<decltype(value_)>(value_)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    cmp_op(const cmp_op &) = delete;
    cmp_op(cmp_op &&) = default;
    cmp_op &operator=(const cmp_op &) = delete;
    cmp_op &operator=(cmp_op &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~cmp_op() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    #pragma endregion Attributes

    #pragma region Extras
    
    #pragma endregion Extras
};


class AttrInst : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AttrInst() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AttrInst(const AttrInst &) = delete;
    AttrInst(AttrInst &&) = default;
    AttrInst &operator=(const AttrInst &) = delete;
    AttrInst &operator=(AttrInst &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<attr_op>() const {
        return ast::make_field<attr_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class AttrStatic : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AttrStatic() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AttrStatic(const AttrStatic &) = delete;
    AttrStatic(AttrStatic &&) = default;
    AttrStatic &operator=(const AttrStatic &) = delete;
    AttrStatic &operator=(AttrStatic &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<attr_op>() const {
        return ast::make_field<attr_op>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class attr_op : public _AST<AttrInst, AttrStatic> {
public:
    #pragma region Constructors
    attr_op(auto &&value_)
        : _AST(std::forward<decltype(value_)>(value_)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    attr_op(const attr_op &) = delete;
    attr_op(attr_op &&) = default;
    attr_op &operator=(const attr_op &) = delete;
    attr_op &operator=(attr_op &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~attr_op() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    #pragma endregion Attributes

    #pragma region Extras
    
    #pragma endregion Extras
};


class Load : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Load() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Load(const Load &) = delete;
    Load(Load &&) = default;
    Load &operator=(const Load &) = delete;
    Load &operator=(Load &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr_context>() const {
        return ast::make_field<expr_context>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Store : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Store() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Store(const Store &) = delete;
    Store(Store &&) = default;
    Store &operator=(const Store &) = delete;
    Store &operator=(Store &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr_context>() const {
        return ast::make_field<expr_context>(*this);
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class expr_context : public _AST<Load, Store> {
public:
    #pragma region Constructors
    expr_context(auto &&value_)
        : _AST(std::forward<decltype(value_)>(value_)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    expr_context(const expr_context &) = delete;
    expr_context(expr_context &&) = default;
    expr_context &operator=(const expr_context &) = delete;
    expr_context &operator=(expr_context &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~expr_context() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    #pragma endregion Attributes

    #pragma region Extras
    
    #pragma endregion Extras
};


class arg_defs {
public:
    #pragma region Fields
    sequence<arg_def> args;
    #pragma endregion Fields

    #pragma region Constructors
    arg_defs(sequence<arg_def> args) :
        args{std::move(args)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    arg_defs(const arg_defs &) = delete;
    arg_defs(arg_defs &&) = default;
    arg_defs &operator=(const arg_defs &) = delete;
    arg_defs &operator=(arg_defs &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(args);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class arg_def {
public:
    #pragma region Fields
    identifier name;
    field<expr> type;
    #pragma endregion Fields

    #pragma region Constructors
    arg_def(identifier name, field<expr> type) :
        name{std::move(name)}, type{std::move(type)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    arg_def(const arg_def &) = delete;
    arg_def(arg_def &&) = default;
    arg_def &operator=(const arg_def &) = delete;
    arg_def &operator=(arg_def &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(name, type);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class call_args {
public:
    #pragma region Fields
    sequence<call_arg> args;
    std::optional<identifier> vararg;
    std::optional<identifier> kwarg;
    #pragma endregion Fields

    #pragma region Constructors
    call_args(sequence<call_arg> args, std::optional<identifier> vararg, std::optional<identifier> kwarg) :
        args{std::move(args)}, vararg{std::move(vararg)}, kwarg{std::move(kwarg)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    call_args(const call_args &) = delete;
    call_args(call_args &&) = default;
    call_args &operator=(const call_args &) = delete;
    call_args &operator=(call_args &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(args, vararg, kwarg);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class call_arg {
public:
    #pragma region Fields
    std::optional<identifier> name;
    field<expr> value;
    #pragma endregion Fields

    #pragma region Constructors
    call_arg(std::optional<identifier> name, field<expr> value) :
        name{std::move(name)}, value{std::move(value)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    call_arg(const call_arg &) = delete;
    call_arg(call_arg &&) = default;
    call_arg &operator=(const call_arg &) = delete;
    call_arg &operator=(call_arg &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(name, value);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};
#pragma endregion Implementations


}  // namespace bondrewd::ast::nodes


namespace bondrewd::ast {


// Import all nodes into the bondrewd::ast namespace,
// so that they can be used without the nodes:: prefix.
using namespace nodes;


}  // namespace bondrewd::ast
