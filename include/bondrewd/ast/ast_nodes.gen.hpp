// AUTOGENERATED by bondrewd/tools/asdl++/asdl_cpp.py on 2023-04-24 06:34:01
// DO NOT EDIT

#pragma once

#include <bondrewd/internal/common.hpp>
#include <bondrewd/ast/ast.hpp>


namespace bondrewd::ast::nodes {


#pragma region Forward declarations
class file;
class File;
class stmt;
class Assign;
class CartridgeHeader;
class Expr;
class Pass;
class expr;
class VarRef;
class Constant;
class Attribute;
class Call;
class MacroCall;
class InfixCall;
class Subscript;
class CtimeBlock;
class Block;
class Defn;
class BinOp;
class UnOp;
class Compare;
class BoolOp;
class Flow;
class Return;
class Break;
class Continue;
class Expand;
class Tuple;
class Array;
class TokenStream;
class PassSpec;
class defn;
class VarDef;
class ImplDef;
class FuncDef;
class StructDef;
class NsDef;
class TemplateDef;
class flow;
class If;
class For;
class While;
class Loop;
class assign_op;
class AsgnNone;
class AsgnAdd;
class AsgnSub;
class AsgnMul;
class AsgnDiv;
class AsgnMod;
class AsgnLShift;
class AsgnRShift;
class AsgnBitOr;
class AsgnBitXor;
class AsgnBitAnd;
class bool_op;
class And;
class Or;
class binary_op;
class Add;
class Sub;
class Mul;
class Div;
class Mod;
class Pow;
class LShift;
class RShift;
class BitOr;
class BitXor;
class BitAnd;
class BidirCmp;
class unary_op;
class BitInv;
class Not;
class UAdd;
class USub;
class URef;
class UStar;
class cmp_op;
class Eq;
class NotEq;
class Lt;
class LtE;
class Gt;
class GtE;
class In;
class NotIn;
class attr_op;
class AttrInst;
class AttrStatic;
class expr_context;
class Load;
class Store;
class args_spec;
class arg_spec;
class call_args;
class call_arg;
class xtime_flag;
class CTime;
class RTime;
class DefaultTime;
class pass_kind;
class ByRef;
class ByMove;
class ByCopy;
class token;
#pragma endregion Forward declarations


#pragma region Implementations
class File : public _ConcreteASTNode {
public:
    #pragma region Fields
    sequence<stmt> body;
    #pragma endregion Fields

    #pragma region Constructors
    File(sequence<stmt> body) :
        body{std::move(body)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    File(const File &) = delete;
    File(File &&) = default;
    File &operator=(const File &) = delete;
    File &operator=(File &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(body);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(body);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<file>() {
        return ast::make_field<file>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class file : public _AST<File> {
public:
    #pragma region Constructors
    file(auto &&value_)
        : _AST(std::forward<decltype(value_)>(value_)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    file(const file &) = delete;
    file(file &&) = default;
    file &operator=(const file &) = delete;
    file &operator=(file &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~file() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    #pragma endregion Attributes

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<file>() {
        return ast::make_field<file>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Assign : public _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> target;
    field<expr> value;
    field<assign_op> op;
    #pragma endregion Fields

    #pragma region Constructors
    Assign(field<expr> target, field<expr> value, field<assign_op> op) :
        target{std::move(target)}, value{std::move(value)}, op{std::move(op)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Assign(const Assign &) = delete;
    Assign(Assign &&) = default;
    Assign &operator=(const Assign &) = delete;
    Assign &operator=(Assign &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(target, value, op);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(target, value, op);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<stmt>() {
        return ast::make_field<stmt>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class CartridgeHeader : public _ConcreteASTNode {
public:
    #pragma region Fields
    identifier name;
    #pragma endregion Fields

    #pragma region Constructors
    CartridgeHeader(identifier name) :
        name{std::move(name)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    CartridgeHeader(const CartridgeHeader &) = delete;
    CartridgeHeader(CartridgeHeader &&) = default;
    CartridgeHeader &operator=(const CartridgeHeader &) = delete;
    CartridgeHeader &operator=(CartridgeHeader &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(name);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(name);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<stmt>() {
        return ast::make_field<stmt>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Expr : public _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> value;
    #pragma endregion Fields

    #pragma region Constructors
    Expr(field<expr> value) :
        value{std::move(value)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Expr(const Expr &) = delete;
    Expr(Expr &&) = default;
    Expr &operator=(const Expr &) = delete;
    Expr &operator=(Expr &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(value);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(value);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<stmt>() {
        return ast::make_field<stmt>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Pass : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Pass() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Pass(const Pass &) = delete;
    Pass(Pass &&) = default;
    Pass &operator=(const Pass &) = delete;
    Pass &operator=(Pass &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<stmt>() {
        return ast::make_field<stmt>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class stmt : public _AST<Assign, CartridgeHeader, Expr, Pass> {
public:
    #pragma region Constructors
    stmt(auto &&value_)
        : _AST(std::forward<decltype(value_)>(value_)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    stmt(const stmt &) = delete;
    stmt(stmt &&) = default;
    stmt &operator=(const stmt &) = delete;
    stmt &operator=(stmt &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~stmt() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    #pragma endregion Attributes

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<stmt>() {
        return ast::make_field<stmt>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class VarRef : public _ConcreteASTNode {
public:
    #pragma region Fields
    identifier value;
    #pragma endregion Fields

    #pragma region Constructors
    VarRef(identifier value) :
        value{std::move(value)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    VarRef(const VarRef &) = delete;
    VarRef(VarRef &&) = default;
    VarRef &operator=(const VarRef &) = delete;
    VarRef &operator=(VarRef &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(value);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(value);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Constant : public _ConcreteASTNode {
public:
    #pragma region Fields
    constant value;
    #pragma endregion Fields

    #pragma region Constructors
    Constant(constant value) :
        value{std::move(value)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Constant(const Constant &) = delete;
    Constant(Constant &&) = default;
    Constant &operator=(const Constant &) = delete;
    Constant &operator=(Constant &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(value);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(value);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Attribute : public _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> value;
    identifier attr;
    field<attr_op> type;
    #pragma endregion Fields

    #pragma region Constructors
    Attribute(field<expr> value, identifier attr, field<attr_op> type) :
        value{std::move(value)}, attr{std::move(attr)}, type{std::move(type)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Attribute(const Attribute &) = delete;
    Attribute(Attribute &&) = default;
    Attribute &operator=(const Attribute &) = delete;
    Attribute &operator=(Attribute &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(value, attr, type);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(value, attr, type);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Call : public _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> func;
    field<call_args> args;
    #pragma endregion Fields

    #pragma region Constructors
    Call(field<expr> func, field<call_args> args) :
        func{std::move(func)}, args{std::move(args)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Call(const Call &) = delete;
    Call(Call &&) = default;
    Call &operator=(const Call &) = delete;
    Call &operator=(Call &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(func, args);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(func, args);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class MacroCall : public _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> func;
    field<expr> token_stream;
    #pragma endregion Fields

    #pragma region Constructors
    MacroCall(field<expr> func, field<expr> token_stream) :
        func{std::move(func)}, token_stream{std::move(token_stream)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    MacroCall(const MacroCall &) = delete;
    MacroCall(MacroCall &&) = default;
    MacroCall &operator=(const MacroCall &) = delete;
    MacroCall &operator=(MacroCall &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(func, token_stream);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(func, token_stream);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class InfixCall : public _ConcreteASTNode {
public:
    #pragma region Fields
    identifier name;
    field<expr> left;
    field<expr> right;
    #pragma endregion Fields

    #pragma region Constructors
    InfixCall(identifier name, field<expr> left, field<expr> right) :
        name{std::move(name)}, left{std::move(left)}, right{std::move(right)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    InfixCall(const InfixCall &) = delete;
    InfixCall(InfixCall &&) = default;
    InfixCall &operator=(const InfixCall &) = delete;
    InfixCall &operator=(InfixCall &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(name, left, right);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(name, left, right);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Subscript : public _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> value;
    field<call_args> args;
    #pragma endregion Fields

    #pragma region Constructors
    Subscript(field<expr> value, field<call_args> args) :
        value{std::move(value)}, args{std::move(args)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Subscript(const Subscript &) = delete;
    Subscript(Subscript &&) = default;
    Subscript &operator=(const Subscript &) = delete;
    Subscript &operator=(Subscript &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(value, args);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(value, args);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class CtimeBlock : public _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> body;
    #pragma endregion Fields

    #pragma region Constructors
    CtimeBlock(field<expr> body) :
        body{std::move(body)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    CtimeBlock(const CtimeBlock &) = delete;
    CtimeBlock(CtimeBlock &&) = default;
    CtimeBlock &operator=(const CtimeBlock &) = delete;
    CtimeBlock &operator=(CtimeBlock &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(body);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(body);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Block : public _ConcreteASTNode {
public:
    #pragma region Fields
    sequence<stmt> body;
    field<expr> value;
    #pragma endregion Fields

    #pragma region Constructors
    Block(sequence<stmt> body, field<expr> value) :
        body{std::move(body)}, value{std::move(value)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Block(const Block &) = delete;
    Block(Block &&) = default;
    Block &operator=(const Block &) = delete;
    Block &operator=(Block &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(body, value);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(body, value);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Defn : public _ConcreteASTNode {
public:
    #pragma region Fields
    field<defn> value;
    #pragma endregion Fields

    #pragma region Constructors
    Defn(field<defn> value) :
        value{std::move(value)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Defn(const Defn &) = delete;
    Defn(Defn &&) = default;
    Defn &operator=(const Defn &) = delete;
    Defn &operator=(Defn &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(value);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(value);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class BinOp : public _ConcreteASTNode {
public:
    #pragma region Fields
    field<binary_op> op;
    field<expr> left;
    field<expr> right;
    #pragma endregion Fields

    #pragma region Constructors
    BinOp(field<binary_op> op, field<expr> left, field<expr> right) :
        op{std::move(op)}, left{std::move(left)}, right{std::move(right)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    BinOp(const BinOp &) = delete;
    BinOp(BinOp &&) = default;
    BinOp &operator=(const BinOp &) = delete;
    BinOp &operator=(BinOp &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(op, left, right);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(op, left, right);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class UnOp : public _ConcreteASTNode {
public:
    #pragma region Fields
    field<unary_op> op;
    field<expr> operand;
    #pragma endregion Fields

    #pragma region Constructors
    UnOp(field<unary_op> op, field<expr> operand) :
        op{std::move(op)}, operand{std::move(operand)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    UnOp(const UnOp &) = delete;
    UnOp(UnOp &&) = default;
    UnOp &operator=(const UnOp &) = delete;
    UnOp &operator=(UnOp &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(op, operand);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(op, operand);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Compare : public _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> left;
    sequence<cmp_op> op;
    sequence<expr> operands;
    #pragma endregion Fields

    #pragma region Constructors
    Compare(field<expr> left, sequence<cmp_op> op, sequence<expr> operands) :
        left{std::move(left)}, op{std::move(op)}, operands{std::move(operands)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Compare(const Compare &) = delete;
    Compare(Compare &&) = default;
    Compare &operator=(const Compare &) = delete;
    Compare &operator=(Compare &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(left, op, operands);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(left, op, operands);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class BoolOp : public _ConcreteASTNode {
public:
    #pragma region Fields
    field<bool_op> op;
    sequence<expr> values;
    #pragma endregion Fields

    #pragma region Constructors
    BoolOp(field<bool_op> op, sequence<expr> values) :
        op{std::move(op)}, values{std::move(values)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    BoolOp(const BoolOp &) = delete;
    BoolOp(BoolOp &&) = default;
    BoolOp &operator=(const BoolOp &) = delete;
    BoolOp &operator=(BoolOp &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(op, values);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(op, values);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Flow : public _ConcreteASTNode {
public:
    #pragma region Fields
    field<flow> value;
    #pragma endregion Fields

    #pragma region Constructors
    Flow(field<flow> value) :
        value{std::move(value)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Flow(const Flow &) = delete;
    Flow(Flow &&) = default;
    Flow &operator=(const Flow &) = delete;
    Flow &operator=(Flow &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(value);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(value);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Return : public _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> value;
    #pragma endregion Fields

    #pragma region Constructors
    Return(field<expr> value) :
        value{std::move(value)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Return(const Return &) = delete;
    Return(Return &&) = default;
    Return &operator=(const Return &) = delete;
    Return &operator=(Return &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(value);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(value);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Break : public _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> value;
    #pragma endregion Fields

    #pragma region Constructors
    Break(field<expr> value) :
        value{std::move(value)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Break(const Break &) = delete;
    Break(Break &&) = default;
    Break &operator=(const Break &) = delete;
    Break &operator=(Break &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(value);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(value);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Continue : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Continue() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Continue(const Continue &) = delete;
    Continue(Continue &&) = default;
    Continue &operator=(const Continue &) = delete;
    Continue &operator=(Continue &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Expand : public _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> value;
    #pragma endregion Fields

    #pragma region Constructors
    Expand(field<expr> value) :
        value{std::move(value)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Expand(const Expand &) = delete;
    Expand(Expand &&) = default;
    Expand &operator=(const Expand &) = delete;
    Expand &operator=(Expand &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(value);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(value);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Tuple : public _ConcreteASTNode {
public:
    #pragma region Fields
    sequence<expr> values;
    #pragma endregion Fields

    #pragma region Constructors
    Tuple(sequence<expr> values) :
        values{std::move(values)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Tuple(const Tuple &) = delete;
    Tuple(Tuple &&) = default;
    Tuple &operator=(const Tuple &) = delete;
    Tuple &operator=(Tuple &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(values);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(values);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Array : public _ConcreteASTNode {
public:
    #pragma region Fields
    sequence<expr> values;
    #pragma endregion Fields

    #pragma region Constructors
    Array(sequence<expr> values) :
        values{std::move(values)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Array(const Array &) = delete;
    Array(Array &&) = default;
    Array &operator=(const Array &) = delete;
    Array &operator=(Array &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(values);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(values);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class TokenStream : public _ConcreteASTNode {
public:
    #pragma region Fields
    sequence<lex::Token> tokens;
    #pragma endregion Fields

    #pragma region Constructors
    TokenStream(sequence<lex::Token> tokens) :
        tokens{std::move(tokens)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    TokenStream(const TokenStream &) = delete;
    TokenStream(TokenStream &&) = default;
    TokenStream &operator=(const TokenStream &) = delete;
    TokenStream &operator=(TokenStream &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(tokens);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(tokens);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class PassSpec : public _ConcreteASTNode {
public:
    #pragma region Fields
    field<pass_kind> kind;
    field<expr> value;
    #pragma endregion Fields

    #pragma region Constructors
    PassSpec(field<pass_kind> kind, field<expr> value) :
        kind{std::move(kind)}, value{std::move(value)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    PassSpec(const PassSpec &) = delete;
    PassSpec(PassSpec &&) = default;
    PassSpec &operator=(const PassSpec &) = delete;
    PassSpec &operator=(PassSpec &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(kind, value);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(kind, value);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class expr : public _AST<VarRef, Constant, Attribute, Call, MacroCall, InfixCall, Subscript, CtimeBlock, Block, Defn, BinOp, UnOp, Compare, BoolOp, Flow, Return, Break, Continue, Expand, Tuple, Array, TokenStream, PassSpec> {
public:
    #pragma region Constructors
    expr(auto &&value_)
        : _AST(std::forward<decltype(value_)>(value_)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    expr(const expr &) = delete;
    expr(expr &&) = default;
    expr &operator=(const expr &) = delete;
    expr &operator=(expr &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~expr() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    #pragma endregion Attributes

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr>() {
        return ast::make_field<expr>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class VarDef : public _ConcreteASTNode {
public:
    #pragma region Fields
    identifier name;
    maybe<expr> type;
    maybe<expr> value;
    bool mut;
    #pragma endregion Fields

    #pragma region Constructors
    VarDef(identifier name, maybe<expr> type, maybe<expr> value, bool mut) :
        name{std::move(name)}, type{std::move(type)}, value{std::move(value)}, mut{std::move(mut)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    VarDef(const VarDef &) = delete;
    VarDef(VarDef &&) = default;
    VarDef &operator=(const VarDef &) = delete;
    VarDef &operator=(VarDef &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(name, type, value, mut);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(name, type, value, mut);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<defn>() {
        return ast::make_field<defn>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class ImplDef : public _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> cls;
    maybe<expr> trait;
    sequence<stmt> body;
    #pragma endregion Fields

    #pragma region Constructors
    ImplDef(field<expr> cls, maybe<expr> trait, sequence<stmt> body) :
        cls{std::move(cls)}, trait{std::move(trait)}, body{std::move(body)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    ImplDef(const ImplDef &) = delete;
    ImplDef(ImplDef &&) = default;
    ImplDef &operator=(const ImplDef &) = delete;
    ImplDef &operator=(ImplDef &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(cls, trait, body);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(cls, trait, body);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<defn>() {
        return ast::make_field<defn>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class FuncDef : public _ConcreteASTNode {
public:
    #pragma region Fields
    std::optional<identifier> name;
    field<args_spec> args;
    maybe<expr> return_type;
    field<expr> body;
    #pragma endregion Fields

    #pragma region Constructors
    FuncDef(std::optional<identifier> name, field<args_spec> args, maybe<expr> return_type, field<expr> body) :
        name{std::move(name)}, args{std::move(args)}, return_type{std::move(return_type)}, body{std::move(body)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    FuncDef(const FuncDef &) = delete;
    FuncDef(FuncDef &&) = default;
    FuncDef &operator=(const FuncDef &) = delete;
    FuncDef &operator=(FuncDef &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(name, args, return_type, body);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(name, args, return_type, body);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<defn>() {
        return ast::make_field<defn>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class StructDef : public _ConcreteASTNode {
public:
    #pragma region Fields
    std::optional<identifier> name;
    field<args_spec> fields;
    #pragma endregion Fields

    #pragma region Constructors
    StructDef(std::optional<identifier> name, field<args_spec> fields) :
        name{std::move(name)}, fields{std::move(fields)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    StructDef(const StructDef &) = delete;
    StructDef(StructDef &&) = default;
    StructDef &operator=(const StructDef &) = delete;
    StructDef &operator=(StructDef &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(name, fields);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(name, fields);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<defn>() {
        return ast::make_field<defn>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class NsDef : public _ConcreteASTNode {
public:
    #pragma region Fields
    sequence<identifier> names;
    #pragma endregion Fields

    #pragma region Constructors
    NsDef(sequence<identifier> names) :
        names{std::move(names)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    NsDef(const NsDef &) = delete;
    NsDef(NsDef &&) = default;
    NsDef &operator=(const NsDef &) = delete;
    NsDef &operator=(NsDef &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(names);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(names);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<defn>() {
        return ast::make_field<defn>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class TemplateDef : public _ConcreteASTNode {
public:
    #pragma region Fields
    field<args_spec> args;
    field<defn> body;
    #pragma endregion Fields

    #pragma region Constructors
    TemplateDef(field<args_spec> args, field<defn> body) :
        args{std::move(args)}, body{std::move(body)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    TemplateDef(const TemplateDef &) = delete;
    TemplateDef(TemplateDef &&) = default;
    TemplateDef &operator=(const TemplateDef &) = delete;
    TemplateDef &operator=(TemplateDef &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(args, body);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(args, body);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<defn>() {
        return ast::make_field<defn>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class defn : public _AST<VarDef, ImplDef, FuncDef, StructDef, NsDef, TemplateDef> {
public:
    #pragma region Constructors
    defn(auto &&value_, field<xtime_flag> flag)
        : _AST(std::forward<decltype(value_)>(value_)), std::move(flag) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    defn(const defn &) = delete;
    defn(defn &&) = default;
    defn &operator=(const defn &) = delete;
    defn &operator=(defn &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~defn() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    field<xtime_flag> flag;
    #pragma endregion Attributes

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<defn>() {
        return ast::make_field<defn>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    defn(auto &&value) :
        defn(std::forward<decltype(value)>(value), DefaultTime()) {}

    #pragma endregion Extras
};


class If : public _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> cond;
    field<expr> body;
    field<expr> orelse;
    #pragma endregion Fields

    #pragma region Constructors
    If(field<expr> cond, field<expr> body, field<expr> orelse) :
        cond{std::move(cond)}, body{std::move(body)}, orelse{std::move(orelse)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    If(const If &) = delete;
    If(If &&) = default;
    If &operator=(const If &) = delete;
    If &operator=(If &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(cond, body, orelse);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(cond, body, orelse);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<flow>() {
        return ast::make_field<flow>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class For : public _ConcreteASTNode {
public:
    #pragma region Fields
    identifier var;
    field<expr> iter;
    field<expr> body;
    field<expr> orelse;
    #pragma endregion Fields

    #pragma region Constructors
    For(identifier var, field<expr> iter, field<expr> body, field<expr> orelse) :
        var{std::move(var)}, iter{std::move(iter)}, body{std::move(body)}, orelse{std::move(orelse)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    For(const For &) = delete;
    For(For &&) = default;
    For &operator=(const For &) = delete;
    For &operator=(For &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(var, iter, body, orelse);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(var, iter, body, orelse);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<flow>() {
        return ast::make_field<flow>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class While : public _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> cond;
    field<expr> body;
    maybe<expr> orelse;
    #pragma endregion Fields

    #pragma region Constructors
    While(field<expr> cond, field<expr> body, maybe<expr> orelse) :
        cond{std::move(cond)}, body{std::move(body)}, orelse{std::move(orelse)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    While(const While &) = delete;
    While(While &&) = default;
    While &operator=(const While &) = delete;
    While &operator=(While &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(cond, body, orelse);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(cond, body, orelse);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<flow>() {
        return ast::make_field<flow>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Loop : public _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> body;
    #pragma endregion Fields

    #pragma region Constructors
    Loop(field<expr> body) :
        body{std::move(body)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Loop(const Loop &) = delete;
    Loop(Loop &&) = default;
    Loop &operator=(const Loop &) = delete;
    Loop &operator=(Loop &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(body);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(body);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<flow>() {
        return ast::make_field<flow>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class flow : public _AST<If, For, While, Loop> {
public:
    #pragma region Constructors
    flow(auto &&value_, bool unwrap)
        : _AST(std::forward<decltype(value_)>(value_)), std::move(unwrap) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    flow(const flow &) = delete;
    flow(flow &&) = default;
    flow &operator=(const flow &) = delete;
    flow &operator=(flow &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~flow() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    bool unwrap;
    #pragma endregion Attributes

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<flow>() {
        return ast::make_field<flow>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    flow(auto &&value) :
        flow(std::forward<decltype(value)>(value), false) {}

    #pragma endregion Extras
};


class AsgnNone : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AsgnNone() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AsgnNone(const AsgnNone &) = delete;
    AsgnNone(AsgnNone &&) = default;
    AsgnNone &operator=(const AsgnNone &) = delete;
    AsgnNone &operator=(AsgnNone &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<assign_op>() {
        return ast::make_field<assign_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class AsgnAdd : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AsgnAdd() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AsgnAdd(const AsgnAdd &) = delete;
    AsgnAdd(AsgnAdd &&) = default;
    AsgnAdd &operator=(const AsgnAdd &) = delete;
    AsgnAdd &operator=(AsgnAdd &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<assign_op>() {
        return ast::make_field<assign_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class AsgnSub : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AsgnSub() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AsgnSub(const AsgnSub &) = delete;
    AsgnSub(AsgnSub &&) = default;
    AsgnSub &operator=(const AsgnSub &) = delete;
    AsgnSub &operator=(AsgnSub &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<assign_op>() {
        return ast::make_field<assign_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class AsgnMul : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AsgnMul() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AsgnMul(const AsgnMul &) = delete;
    AsgnMul(AsgnMul &&) = default;
    AsgnMul &operator=(const AsgnMul &) = delete;
    AsgnMul &operator=(AsgnMul &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<assign_op>() {
        return ast::make_field<assign_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class AsgnDiv : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AsgnDiv() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AsgnDiv(const AsgnDiv &) = delete;
    AsgnDiv(AsgnDiv &&) = default;
    AsgnDiv &operator=(const AsgnDiv &) = delete;
    AsgnDiv &operator=(AsgnDiv &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<assign_op>() {
        return ast::make_field<assign_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class AsgnMod : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AsgnMod() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AsgnMod(const AsgnMod &) = delete;
    AsgnMod(AsgnMod &&) = default;
    AsgnMod &operator=(const AsgnMod &) = delete;
    AsgnMod &operator=(AsgnMod &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<assign_op>() {
        return ast::make_field<assign_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class AsgnLShift : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AsgnLShift() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AsgnLShift(const AsgnLShift &) = delete;
    AsgnLShift(AsgnLShift &&) = default;
    AsgnLShift &operator=(const AsgnLShift &) = delete;
    AsgnLShift &operator=(AsgnLShift &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<assign_op>() {
        return ast::make_field<assign_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class AsgnRShift : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AsgnRShift() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AsgnRShift(const AsgnRShift &) = delete;
    AsgnRShift(AsgnRShift &&) = default;
    AsgnRShift &operator=(const AsgnRShift &) = delete;
    AsgnRShift &operator=(AsgnRShift &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<assign_op>() {
        return ast::make_field<assign_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class AsgnBitOr : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AsgnBitOr() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AsgnBitOr(const AsgnBitOr &) = delete;
    AsgnBitOr(AsgnBitOr &&) = default;
    AsgnBitOr &operator=(const AsgnBitOr &) = delete;
    AsgnBitOr &operator=(AsgnBitOr &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<assign_op>() {
        return ast::make_field<assign_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class AsgnBitXor : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AsgnBitXor() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AsgnBitXor(const AsgnBitXor &) = delete;
    AsgnBitXor(AsgnBitXor &&) = default;
    AsgnBitXor &operator=(const AsgnBitXor &) = delete;
    AsgnBitXor &operator=(AsgnBitXor &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<assign_op>() {
        return ast::make_field<assign_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class AsgnBitAnd : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AsgnBitAnd() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AsgnBitAnd(const AsgnBitAnd &) = delete;
    AsgnBitAnd(AsgnBitAnd &&) = default;
    AsgnBitAnd &operator=(const AsgnBitAnd &) = delete;
    AsgnBitAnd &operator=(AsgnBitAnd &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<assign_op>() {
        return ast::make_field<assign_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class assign_op : public _AST<AsgnNone, AsgnAdd, AsgnSub, AsgnMul, AsgnDiv, AsgnMod, AsgnLShift, AsgnRShift, AsgnBitOr, AsgnBitXor, AsgnBitAnd> {
public:
    #pragma region Constructors
    assign_op(auto &&value_)
        : _AST(std::forward<decltype(value_)>(value_)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    assign_op(const assign_op &) = delete;
    assign_op(assign_op &&) = default;
    assign_op &operator=(const assign_op &) = delete;
    assign_op &operator=(assign_op &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~assign_op() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    #pragma endregion Attributes

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<assign_op>() {
        return ast::make_field<assign_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class And : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    And() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    And(const And &) = delete;
    And(And &&) = default;
    And &operator=(const And &) = delete;
    And &operator=(And &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<bool_op>() {
        return ast::make_field<bool_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Or : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Or() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Or(const Or &) = delete;
    Or(Or &&) = default;
    Or &operator=(const Or &) = delete;
    Or &operator=(Or &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<bool_op>() {
        return ast::make_field<bool_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class bool_op : public _AST<And, Or> {
public:
    #pragma region Constructors
    bool_op(auto &&value_)
        : _AST(std::forward<decltype(value_)>(value_)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    bool_op(const bool_op &) = delete;
    bool_op(bool_op &&) = default;
    bool_op &operator=(const bool_op &) = delete;
    bool_op &operator=(bool_op &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~bool_op() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    #pragma endregion Attributes

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<bool_op>() {
        return ast::make_field<bool_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Add : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Add() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Add(const Add &) = delete;
    Add(Add &&) = default;
    Add &operator=(const Add &) = delete;
    Add &operator=(Add &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() {
        return ast::make_field<binary_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Sub : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Sub() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Sub(const Sub &) = delete;
    Sub(Sub &&) = default;
    Sub &operator=(const Sub &) = delete;
    Sub &operator=(Sub &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() {
        return ast::make_field<binary_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Mul : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Mul() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Mul(const Mul &) = delete;
    Mul(Mul &&) = default;
    Mul &operator=(const Mul &) = delete;
    Mul &operator=(Mul &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() {
        return ast::make_field<binary_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Div : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Div() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Div(const Div &) = delete;
    Div(Div &&) = default;
    Div &operator=(const Div &) = delete;
    Div &operator=(Div &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() {
        return ast::make_field<binary_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Mod : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Mod() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Mod(const Mod &) = delete;
    Mod(Mod &&) = default;
    Mod &operator=(const Mod &) = delete;
    Mod &operator=(Mod &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() {
        return ast::make_field<binary_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Pow : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Pow() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Pow(const Pow &) = delete;
    Pow(Pow &&) = default;
    Pow &operator=(const Pow &) = delete;
    Pow &operator=(Pow &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() {
        return ast::make_field<binary_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class LShift : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    LShift() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    LShift(const LShift &) = delete;
    LShift(LShift &&) = default;
    LShift &operator=(const LShift &) = delete;
    LShift &operator=(LShift &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() {
        return ast::make_field<binary_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class RShift : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    RShift() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    RShift(const RShift &) = delete;
    RShift(RShift &&) = default;
    RShift &operator=(const RShift &) = delete;
    RShift &operator=(RShift &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() {
        return ast::make_field<binary_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class BitOr : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    BitOr() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    BitOr(const BitOr &) = delete;
    BitOr(BitOr &&) = default;
    BitOr &operator=(const BitOr &) = delete;
    BitOr &operator=(BitOr &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() {
        return ast::make_field<binary_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class BitXor : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    BitXor() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    BitXor(const BitXor &) = delete;
    BitXor(BitXor &&) = default;
    BitXor &operator=(const BitXor &) = delete;
    BitXor &operator=(BitXor &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() {
        return ast::make_field<binary_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class BitAnd : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    BitAnd() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    BitAnd(const BitAnd &) = delete;
    BitAnd(BitAnd &&) = default;
    BitAnd &operator=(const BitAnd &) = delete;
    BitAnd &operator=(BitAnd &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() {
        return ast::make_field<binary_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class BidirCmp : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    BidirCmp() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    BidirCmp(const BidirCmp &) = delete;
    BidirCmp(BidirCmp &&) = default;
    BidirCmp &operator=(const BidirCmp &) = delete;
    BidirCmp &operator=(BidirCmp &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() {
        return ast::make_field<binary_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class binary_op : public _AST<Add, Sub, Mul, Div, Mod, Pow, LShift, RShift, BitOr, BitXor, BitAnd, BidirCmp> {
public:
    #pragma region Constructors
    binary_op(auto &&value_)
        : _AST(std::forward<decltype(value_)>(value_)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    binary_op(const binary_op &) = delete;
    binary_op(binary_op &&) = default;
    binary_op &operator=(const binary_op &) = delete;
    binary_op &operator=(binary_op &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~binary_op() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    #pragma endregion Attributes

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<binary_op>() {
        return ast::make_field<binary_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class BitInv : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    BitInv() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    BitInv(const BitInv &) = delete;
    BitInv(BitInv &&) = default;
    BitInv &operator=(const BitInv &) = delete;
    BitInv &operator=(BitInv &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<unary_op>() {
        return ast::make_field<unary_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Not : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Not() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Not(const Not &) = delete;
    Not(Not &&) = default;
    Not &operator=(const Not &) = delete;
    Not &operator=(Not &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<unary_op>() {
        return ast::make_field<unary_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class UAdd : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    UAdd() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    UAdd(const UAdd &) = delete;
    UAdd(UAdd &&) = default;
    UAdd &operator=(const UAdd &) = delete;
    UAdd &operator=(UAdd &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<unary_op>() {
        return ast::make_field<unary_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class USub : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    USub() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    USub(const USub &) = delete;
    USub(USub &&) = default;
    USub &operator=(const USub &) = delete;
    USub &operator=(USub &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<unary_op>() {
        return ast::make_field<unary_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class URef : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    URef() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    URef(const URef &) = delete;
    URef(URef &&) = default;
    URef &operator=(const URef &) = delete;
    URef &operator=(URef &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<unary_op>() {
        return ast::make_field<unary_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class UStar : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    UStar() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    UStar(const UStar &) = delete;
    UStar(UStar &&) = default;
    UStar &operator=(const UStar &) = delete;
    UStar &operator=(UStar &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<unary_op>() {
        return ast::make_field<unary_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class unary_op : public _AST<BitInv, Not, UAdd, USub, URef, UStar> {
public:
    #pragma region Constructors
    unary_op(auto &&value_)
        : _AST(std::forward<decltype(value_)>(value_)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    unary_op(const unary_op &) = delete;
    unary_op(unary_op &&) = default;
    unary_op &operator=(const unary_op &) = delete;
    unary_op &operator=(unary_op &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~unary_op() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    #pragma endregion Attributes

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<unary_op>() {
        return ast::make_field<unary_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Eq : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Eq() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Eq(const Eq &) = delete;
    Eq(Eq &&) = default;
    Eq &operator=(const Eq &) = delete;
    Eq &operator=(Eq &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<cmp_op>() {
        return ast::make_field<cmp_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class NotEq : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    NotEq() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    NotEq(const NotEq &) = delete;
    NotEq(NotEq &&) = default;
    NotEq &operator=(const NotEq &) = delete;
    NotEq &operator=(NotEq &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<cmp_op>() {
        return ast::make_field<cmp_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Lt : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Lt() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Lt(const Lt &) = delete;
    Lt(Lt &&) = default;
    Lt &operator=(const Lt &) = delete;
    Lt &operator=(Lt &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<cmp_op>() {
        return ast::make_field<cmp_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class LtE : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    LtE() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    LtE(const LtE &) = delete;
    LtE(LtE &&) = default;
    LtE &operator=(const LtE &) = delete;
    LtE &operator=(LtE &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<cmp_op>() {
        return ast::make_field<cmp_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Gt : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Gt() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Gt(const Gt &) = delete;
    Gt(Gt &&) = default;
    Gt &operator=(const Gt &) = delete;
    Gt &operator=(Gt &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<cmp_op>() {
        return ast::make_field<cmp_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class GtE : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    GtE() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    GtE(const GtE &) = delete;
    GtE(GtE &&) = default;
    GtE &operator=(const GtE &) = delete;
    GtE &operator=(GtE &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<cmp_op>() {
        return ast::make_field<cmp_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class In : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    In() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    In(const In &) = delete;
    In(In &&) = default;
    In &operator=(const In &) = delete;
    In &operator=(In &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<cmp_op>() {
        return ast::make_field<cmp_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class NotIn : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    NotIn() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    NotIn(const NotIn &) = delete;
    NotIn(NotIn &&) = default;
    NotIn &operator=(const NotIn &) = delete;
    NotIn &operator=(NotIn &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<cmp_op>() {
        return ast::make_field<cmp_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class cmp_op : public _AST<Eq, NotEq, Lt, LtE, Gt, GtE, In, NotIn> {
public:
    #pragma region Constructors
    cmp_op(auto &&value_)
        : _AST(std::forward<decltype(value_)>(value_)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    cmp_op(const cmp_op &) = delete;
    cmp_op(cmp_op &&) = default;
    cmp_op &operator=(const cmp_op &) = delete;
    cmp_op &operator=(cmp_op &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~cmp_op() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    #pragma endregion Attributes

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<cmp_op>() {
        return ast::make_field<cmp_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class AttrInst : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AttrInst() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AttrInst(const AttrInst &) = delete;
    AttrInst(AttrInst &&) = default;
    AttrInst &operator=(const AttrInst &) = delete;
    AttrInst &operator=(AttrInst &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<attr_op>() {
        return ast::make_field<attr_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class AttrStatic : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    AttrStatic() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    AttrStatic(const AttrStatic &) = delete;
    AttrStatic(AttrStatic &&) = default;
    AttrStatic &operator=(const AttrStatic &) = delete;
    AttrStatic &operator=(AttrStatic &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<attr_op>() {
        return ast::make_field<attr_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class attr_op : public _AST<AttrInst, AttrStatic> {
public:
    #pragma region Constructors
    attr_op(auto &&value_)
        : _AST(std::forward<decltype(value_)>(value_)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    attr_op(const attr_op &) = delete;
    attr_op(attr_op &&) = default;
    attr_op &operator=(const attr_op &) = delete;
    attr_op &operator=(attr_op &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~attr_op() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    #pragma endregion Attributes

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<attr_op>() {
        return ast::make_field<attr_op>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Load : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Load() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Load(const Load &) = delete;
    Load(Load &&) = default;
    Load &operator=(const Load &) = delete;
    Load &operator=(Load &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr_context>() {
        return ast::make_field<expr_context>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class Store : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    Store() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    Store(const Store &) = delete;
    Store(Store &&) = default;
    Store &operator=(const Store &) = delete;
    Store &operator=(Store &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr_context>() {
        return ast::make_field<expr_context>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class expr_context : public _AST<Load, Store> {
public:
    #pragma region Constructors
    expr_context(auto &&value_)
        : _AST(std::forward<decltype(value_)>(value_)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    expr_context(const expr_context &) = delete;
    expr_context(expr_context &&) = default;
    expr_context &operator=(const expr_context &) = delete;
    expr_context &operator=(expr_context &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~expr_context() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    #pragma endregion Attributes

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<expr_context>() {
        return ast::make_field<expr_context>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class args_spec {
public:
    #pragma region Fields
    sequence<arg_spec> args;
    bool with_self;
    #pragma endregion Fields

    #pragma region Constructors
    args_spec(sequence<arg_spec> args, bool with_self) :
        args{std::move(args)}, with_self{std::move(with_self)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    args_spec(const args_spec &) = delete;
    args_spec(args_spec &&) = default;
    args_spec &operator=(const args_spec &) = delete;
    args_spec &operator=(args_spec &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(args, with_self);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(args, with_self);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<args_spec>() {
        return ast::make_field<args_spec>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class arg_spec {
public:
    #pragma region Fields
    identifier name;
    field<expr> type;
    maybe<expr> default_value;
    #pragma endregion Fields

    #pragma region Constructors
    arg_spec(identifier name, field<expr> type, maybe<expr> default_value) :
        name{std::move(name)}, type{std::move(type)}, default_value{std::move(default_value)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    arg_spec(const arg_spec &) = delete;
    arg_spec(arg_spec &&) = default;
    arg_spec &operator=(const arg_spec &) = delete;
    arg_spec &operator=(arg_spec &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(name, type, default_value);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(name, type, default_value);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<arg_spec>() {
        return ast::make_field<arg_spec>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class call_args {
public:
    #pragma region Fields
    sequence<call_arg> args;
    std::optional<identifier> vararg;
    std::optional<identifier> kwarg;
    #pragma endregion Fields

    #pragma region Constructors
    call_args(sequence<call_arg> args, std::optional<identifier> vararg, std::optional<identifier> kwarg) :
        args{std::move(args)}, vararg{std::move(vararg)}, kwarg{std::move(kwarg)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    call_args(const call_args &) = delete;
    call_args(call_args &&) = default;
    call_args &operator=(const call_args &) = delete;
    call_args &operator=(call_args &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(args, vararg, kwarg);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(args, vararg, kwarg);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<call_args>() {
        return ast::make_field<call_args>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class call_arg {
public:
    #pragma region Fields
    std::optional<identifier> name;
    field<expr> value;
    #pragma endregion Fields

    #pragma region Constructors
    call_arg(std::optional<identifier> name, field<expr> value) :
        name{std::move(name)}, value{std::move(value)} {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    call_arg(const call_arg &) = delete;
    call_arg(call_arg &&) = default;
    call_arg &operator=(const call_arg &) = delete;
    call_arg &operator=(call_arg &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(name, value);
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie(name, value);
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<call_arg>() {
        return ast::make_field<call_arg>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class CTime : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    CTime() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    CTime(const CTime &) = delete;
    CTime(CTime &&) = default;
    CTime &operator=(const CTime &) = delete;
    CTime &operator=(CTime &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<xtime_flag>() {
        return ast::make_field<xtime_flag>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class RTime : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    RTime() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    RTime(const RTime &) = delete;
    RTime(RTime &&) = default;
    RTime &operator=(const RTime &) = delete;
    RTime &operator=(RTime &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<xtime_flag>() {
        return ast::make_field<xtime_flag>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class DefaultTime : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    DefaultTime() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    DefaultTime(const DefaultTime &) = delete;
    DefaultTime(DefaultTime &&) = default;
    DefaultTime &operator=(const DefaultTime &) = delete;
    DefaultTime &operator=(DefaultTime &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<xtime_flag>() {
        return ast::make_field<xtime_flag>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class xtime_flag : public _AST<CTime, RTime, DefaultTime> {
public:
    #pragma region Constructors
    xtime_flag(auto &&value_)
        : _AST(std::forward<decltype(value_)>(value_)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    xtime_flag(const xtime_flag &) = delete;
    xtime_flag(xtime_flag &&) = default;
    xtime_flag &operator=(const xtime_flag &) = delete;
    xtime_flag &operator=(xtime_flag &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~xtime_flag() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    #pragma endregion Attributes

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<xtime_flag>() {
        return ast::make_field<xtime_flag>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class ByRef : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    ByRef() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    ByRef(const ByRef &) = delete;
    ByRef(ByRef &&) = default;
    ByRef &operator=(const ByRef &) = delete;
    ByRef &operator=(ByRef &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<pass_kind>() {
        return ast::make_field<pass_kind>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class ByMove : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    ByMove() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    ByMove(const ByMove &) = delete;
    ByMove(ByMove &&) = default;
    ByMove &operator=(const ByMove &) = delete;
    ByMove &operator=(ByMove &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<pass_kind>() {
        return ast::make_field<pass_kind>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class ByCopy : public _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields

    #pragma region Constructors
    ByCopy() {};
    #pragma endregion Constructors
    
    #pragma region Service constructors
    ByCopy(const ByCopy &) = delete;
    ByCopy(ByCopy &&) = default;
    ByCopy &operator=(const ByCopy &) = delete;
    ByCopy &operator=(ByCopy &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }

    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() const {
        return std::tie();
    }
    #pragma endregion Uniform fields access

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<pass_kind>() {
        return ast::make_field<pass_kind>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


class pass_kind : public _AST<ByRef, ByMove, ByCopy> {
public:
    #pragma region Constructors
    pass_kind(auto &&value_)
        : _AST(std::forward<decltype(value_)>(value_)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    pass_kind(const pass_kind &) = delete;
    pass_kind(pass_kind &&) = default;
    pass_kind &operator=(const pass_kind &) = delete;
    pass_kind &operator=(pass_kind &&) = default;
    #pragma endregion Service constructors

    #pragma region Destructor
    ~pass_kind() = default;
    #pragma endregion Destructor

    #pragma region Attributes
    
    #pragma endregion Attributes

    #pragma region Casts
    // TODO: Explicit?
    operator ast::field<pass_kind>() {
        return ast::make_field<pass_kind>(std::move(*this));
    }
    #pragma endregion Casts

    #pragma region Extras
    
    #pragma endregion Extras
};


#pragma endregion Implementations


}  // namespace bondrewd::ast::nodes


namespace bondrewd::ast {


// Import all nodes into the bondrewd::ast namespace,
// so that they can be used without the nodes:: prefix.
using namespace nodes;


}  // namespace bondrewd::ast
