// AUTOGENERATED by tools\asdl++\asdl_cpp.py on 2023-02-12 17:21:41
// DO NOT EDIT

#pragma once

#include <bondrewd/internal/common.hpp>
#include <bondrewd/ast/ast.hpp>


namespace bondrewd::ast::nodes {


class cartridge : public _AST<Cartridge> {
public:
    #pragma region Constructors
    cartridge(auto &&value)
        : _AST(std::forward<decltype(value)>(value)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    cartridge(const cartridge &) = delete;
    cartridge(cartridge &&) = default;
    cartridge &operator=(const cartridge &) = delete;
    cartridge &operator=(cartridge &&) = default;
    #pragma endregion Service constructors

    ~cartridge() = default;
    
};


class Cartridge : _ConcreteASTNode {
public:
    #pragma region Fields
    sequence<declaration> body;
    #pragma endregion Fields
    
    #pragma region Service constructors
    Cartridge(const Cartridge &) = delete;
    Cartridge(Cartridge &&) = default;
    Cartridge &operator=(const Cartridge &) = delete;
    Cartridge &operator=(Cartridge &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(body);
    }
    #pragma endregion Uniform fields access
};


class declaration : public _AST<FuncDef, VarDef> {
public:
    #pragma region Constructors
    declaration(auto &&value)
        : _AST(std::forward<decltype(value)>(value)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    declaration(const declaration &) = delete;
    declaration(declaration &&) = default;
    declaration &operator=(const declaration &) = delete;
    declaration &operator=(declaration &&) = default;
    #pragma endregion Service constructors

    ~declaration() = default;
    
};


class FuncDef : _ConcreteASTNode {
public:
    #pragma region Fields
    field<identifier> name;
    field<arguments> args;
    sequence<stmt> body;
    #pragma endregion Fields
    
    #pragma region Service constructors
    FuncDef(const FuncDef &) = delete;
    FuncDef(FuncDef &&) = default;
    FuncDef &operator=(const FuncDef &) = delete;
    FuncDef &operator=(FuncDef &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(name, args, body);
    }
    #pragma endregion Uniform fields access
};


class VarDef : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    VarDef(const VarDef &) = default;
    VarDef(VarDef &&) = default;
    VarDef &operator=(const VarDef &) = default;
    VarDef &operator=(VarDef &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class stmt : public _AST<For, While, Decl, Assign, Expr, Pass> {
public:
    #pragma region Constructors
    stmt(auto &&value)
        : _AST(std::forward<decltype(value)>(value)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    stmt(const stmt &) = delete;
    stmt(stmt &&) = default;
    stmt &operator=(const stmt &) = delete;
    stmt &operator=(stmt &&) = default;
    #pragma endregion Service constructors

    ~stmt() = default;
    
};


class For : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    For(const For &) = default;
    For(For &&) = default;
    For &operator=(const For &) = default;
    For &operator=(For &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class While : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    While(const While &) = default;
    While(While &&) = default;
    While &operator=(const While &) = default;
    While &operator=(While &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class Decl : _ConcreteASTNode {
public:
    #pragma region Fields
    field<declaration> value;
    #pragma endregion Fields
    
    #pragma region Service constructors
    Decl(const Decl &) = delete;
    Decl(Decl &&) = default;
    Decl &operator=(const Decl &) = delete;
    Decl &operator=(Decl &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(value);
    }
    #pragma endregion Uniform fields access
};


class Assign : _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> target;
    field<expr> value;
    #pragma endregion Fields
    
    #pragma region Service constructors
    Assign(const Assign &) = delete;
    Assign(Assign &&) = default;
    Assign &operator=(const Assign &) = delete;
    Assign &operator=(Assign &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(target, value);
    }
    #pragma endregion Uniform fields access
};


class Expr : _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> value;
    #pragma endregion Fields
    
    #pragma region Service constructors
    Expr(const Expr &) = delete;
    Expr(Expr &&) = default;
    Expr &operator=(const Expr &) = delete;
    Expr &operator=(Expr &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(value);
    }
    #pragma endregion Uniform fields access
};


class Pass : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    Pass(const Pass &) = default;
    Pass(Pass &&) = default;
    Pass &operator=(const Pass &) = default;
    Pass &operator=(Pass &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class expr : public _AST<Name, Constant, Call, Block, BinOp, UnOp, Compare, BoolOp, If, Return, Break> {
public:
    #pragma region Constructors
    expr(auto &&value)
        : _AST(std::forward<decltype(value)>(value)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    expr(const expr &) = delete;
    expr(expr &&) = default;
    expr &operator=(const expr &) = delete;
    expr &operator=(expr &&) = default;
    #pragma endregion Service constructors

    ~expr() = default;
    
};


class Name : _ConcreteASTNode {
public:
    #pragma region Fields
    field<identifier> value;
    #pragma endregion Fields
    
    #pragma region Service constructors
    Name(const Name &) = delete;
    Name(Name &&) = default;
    Name &operator=(const Name &) = delete;
    Name &operator=(Name &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(value);
    }
    #pragma endregion Uniform fields access
};


class Constant : _ConcreteASTNode {
public:
    #pragma region Fields
    field<constant> value;
    #pragma endregion Fields
    
    #pragma region Service constructors
    Constant(const Constant &) = delete;
    Constant(Constant &&) = default;
    Constant &operator=(const Constant &) = delete;
    Constant &operator=(Constant &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(value);
    }
    #pragma endregion Uniform fields access
};


class Call : _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> func;
    sequence<expr> args;
    #pragma endregion Fields
    
    #pragma region Service constructors
    Call(const Call &) = delete;
    Call(Call &&) = default;
    Call &operator=(const Call &) = delete;
    Call &operator=(Call &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(func, args);
    }
    #pragma endregion Uniform fields access
};


class Block : _ConcreteASTNode {
public:
    #pragma region Fields
    sequence<stmt> body;
    #pragma endregion Fields
    
    #pragma region Service constructors
    Block(const Block &) = delete;
    Block(Block &&) = default;
    Block &operator=(const Block &) = delete;
    Block &operator=(Block &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(body);
    }
    #pragma endregion Uniform fields access
};


class BinOp : _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> left;
    field<binary_op> op;
    field<expr> right;
    #pragma endregion Fields
    
    #pragma region Service constructors
    BinOp(const BinOp &) = delete;
    BinOp(BinOp &&) = default;
    BinOp &operator=(const BinOp &) = delete;
    BinOp &operator=(BinOp &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(left, op, right);
    }
    #pragma endregion Uniform fields access
};


class UnOp : _ConcreteASTNode {
public:
    #pragma region Fields
    field<unary_op> op;
    field<expr> operand;
    #pragma endregion Fields
    
    #pragma region Service constructors
    UnOp(const UnOp &) = delete;
    UnOp(UnOp &&) = default;
    UnOp &operator=(const UnOp &) = delete;
    UnOp &operator=(UnOp &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(op, operand);
    }
    #pragma endregion Uniform fields access
};


class Compare : _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> left;
    sequence<cmp_op> op;
    sequence<expr> operands;
    #pragma endregion Fields
    
    #pragma region Service constructors
    Compare(const Compare &) = delete;
    Compare(Compare &&) = default;
    Compare &operator=(const Compare &) = delete;
    Compare &operator=(Compare &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(left, op, operands);
    }
    #pragma endregion Uniform fields access
};


class BoolOp : _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> left;
    field<bool_op> op;
    field<expr> right;
    #pragma endregion Fields
    
    #pragma region Service constructors
    BoolOp(const BoolOp &) = delete;
    BoolOp(BoolOp &&) = default;
    BoolOp &operator=(const BoolOp &) = delete;
    BoolOp &operator=(BoolOp &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(left, op, right);
    }
    #pragma endregion Uniform fields access
};


class If : _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> cond;
    field<expr> body;
    field<expr> /* nullable */ orelse;
    #pragma endregion Fields
    
    #pragma region Service constructors
    If(const If &) = delete;
    If(If &&) = default;
    If &operator=(const If &) = delete;
    If &operator=(If &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(cond, body, orelse);
    }
    #pragma endregion Uniform fields access
};


class Return : _ConcreteASTNode {
public:
    #pragma region Fields
    field<expr> /* nullable */ value;
    #pragma endregion Fields
    
    #pragma region Service constructors
    Return(const Return &) = delete;
    Return(Return &&) = default;
    Return &operator=(const Return &) = delete;
    Return &operator=(Return &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(value);
    }
    #pragma endregion Uniform fields access
};


class Break : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    Break(const Break &) = default;
    Break(Break &&) = default;
    Break &operator=(const Break &) = default;
    Break &operator=(Break &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class bool_op : public _AST<And, Or> {
public:
    #pragma region Constructors
    bool_op(auto &&value)
        : _AST(std::forward<decltype(value)>(value)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    bool_op(const bool_op &) = default;
    bool_op(bool_op &&) = default;
    bool_op &operator=(const bool_op &) = default;
    bool_op &operator=(bool_op &&) = default;
    #pragma endregion Service constructors

    ~bool_op() = default;
    
};


class And : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    And(const And &) = default;
    And(And &&) = default;
    And &operator=(const And &) = default;
    And &operator=(And &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class Or : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    Or(const Or &) = default;
    Or(Or &&) = default;
    Or &operator=(const Or &) = default;
    Or &operator=(Or &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class binary_op : public _AST<Add, Sub, Mul, Div, Mod, LShift, RShift, BitOr, BitXor, BitAnd, BidirCmp> {
public:
    #pragma region Constructors
    binary_op(auto &&value)
        : _AST(std::forward<decltype(value)>(value)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    binary_op(const binary_op &) = default;
    binary_op(binary_op &&) = default;
    binary_op &operator=(const binary_op &) = default;
    binary_op &operator=(binary_op &&) = default;
    #pragma endregion Service constructors

    ~binary_op() = default;
    
};


class Add : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    Add(const Add &) = default;
    Add(Add &&) = default;
    Add &operator=(const Add &) = default;
    Add &operator=(Add &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class Sub : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    Sub(const Sub &) = default;
    Sub(Sub &&) = default;
    Sub &operator=(const Sub &) = default;
    Sub &operator=(Sub &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class Mul : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    Mul(const Mul &) = default;
    Mul(Mul &&) = default;
    Mul &operator=(const Mul &) = default;
    Mul &operator=(Mul &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class Div : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    Div(const Div &) = default;
    Div(Div &&) = default;
    Div &operator=(const Div &) = default;
    Div &operator=(Div &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class Mod : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    Mod(const Mod &) = default;
    Mod(Mod &&) = default;
    Mod &operator=(const Mod &) = default;
    Mod &operator=(Mod &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class LShift : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    LShift(const LShift &) = default;
    LShift(LShift &&) = default;
    LShift &operator=(const LShift &) = default;
    LShift &operator=(LShift &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class RShift : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    RShift(const RShift &) = default;
    RShift(RShift &&) = default;
    RShift &operator=(const RShift &) = default;
    RShift &operator=(RShift &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class BitOr : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    BitOr(const BitOr &) = default;
    BitOr(BitOr &&) = default;
    BitOr &operator=(const BitOr &) = default;
    BitOr &operator=(BitOr &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class BitXor : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    BitXor(const BitXor &) = default;
    BitXor(BitXor &&) = default;
    BitXor &operator=(const BitXor &) = default;
    BitXor &operator=(BitXor &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class BitAnd : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    BitAnd(const BitAnd &) = default;
    BitAnd(BitAnd &&) = default;
    BitAnd &operator=(const BitAnd &) = default;
    BitAnd &operator=(BitAnd &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class BidirCmp : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    BidirCmp(const BidirCmp &) = default;
    BidirCmp(BidirCmp &&) = default;
    BidirCmp &operator=(const BidirCmp &) = default;
    BidirCmp &operator=(BidirCmp &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class unary_op : public _AST<BitInv, Not, UAdd, USub> {
public:
    #pragma region Constructors
    unary_op(auto &&value)
        : _AST(std::forward<decltype(value)>(value)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    unary_op(const unary_op &) = default;
    unary_op(unary_op &&) = default;
    unary_op &operator=(const unary_op &) = default;
    unary_op &operator=(unary_op &&) = default;
    #pragma endregion Service constructors

    ~unary_op() = default;
    
};


class BitInv : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    BitInv(const BitInv &) = default;
    BitInv(BitInv &&) = default;
    BitInv &operator=(const BitInv &) = default;
    BitInv &operator=(BitInv &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class Not : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    Not(const Not &) = default;
    Not(Not &&) = default;
    Not &operator=(const Not &) = default;
    Not &operator=(Not &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class UAdd : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    UAdd(const UAdd &) = default;
    UAdd(UAdd &&) = default;
    UAdd &operator=(const UAdd &) = default;
    UAdd &operator=(UAdd &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class USub : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    USub(const USub &) = default;
    USub(USub &&) = default;
    USub &operator=(const USub &) = default;
    USub &operator=(USub &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class cmp_op : public _AST<Eq, NotEq, Lt, LtE, Gt, GtE, In, NotIn> {
public:
    #pragma region Constructors
    cmp_op(auto &&value)
        : _AST(std::forward<decltype(value)>(value)) {}
    #pragma endregion Constructors
    
    #pragma region Service constructors
    cmp_op(const cmp_op &) = default;
    cmp_op(cmp_op &&) = default;
    cmp_op &operator=(const cmp_op &) = default;
    cmp_op &operator=(cmp_op &&) = default;
    #pragma endregion Service constructors

    ~cmp_op() = default;
    
};


class Eq : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    Eq(const Eq &) = default;
    Eq(Eq &&) = default;
    Eq &operator=(const Eq &) = default;
    Eq &operator=(Eq &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class NotEq : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    NotEq(const NotEq &) = default;
    NotEq(NotEq &&) = default;
    NotEq &operator=(const NotEq &) = default;
    NotEq &operator=(NotEq &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class Lt : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    Lt(const Lt &) = default;
    Lt(Lt &&) = default;
    Lt &operator=(const Lt &) = default;
    Lt &operator=(Lt &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class LtE : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    LtE(const LtE &) = default;
    LtE(LtE &&) = default;
    LtE &operator=(const LtE &) = default;
    LtE &operator=(LtE &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class Gt : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    Gt(const Gt &) = default;
    Gt(Gt &&) = default;
    Gt &operator=(const Gt &) = default;
    Gt &operator=(Gt &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class GtE : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    GtE(const GtE &) = default;
    GtE(GtE &&) = default;
    GtE &operator=(const GtE &) = default;
    GtE &operator=(GtE &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class In : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    In(const In &) = default;
    In(In &&) = default;
    In &operator=(const In &) = default;
    In &operator=(In &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class NotIn : _ConcreteASTNode {
public:
    #pragma region Fields
    #pragma endregion Fields
    
    #pragma region Service constructors
    NotIn(const NotIn &) = default;
    NotIn(NotIn &&) = default;
    NotIn &operator=(const NotIn &) = default;
    NotIn &operator=(NotIn &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie();
    }
    #pragma endregion Uniform fields access
};


class arguments {
public:
    #pragma region Fields
    sequence<arg> args;
    #pragma endregion Fields
    
    #pragma region Service constructors
    arguments(const arguments &) = delete;
    arguments(arguments &&) = default;
    arguments &operator=(const arguments &) = delete;
    arguments &operator=(arguments &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(args);
    }
    #pragma endregion Uniform fields access
};


class arg {
public:
    #pragma region Fields
    field<identifier> name;
    field<expr> type;
    #pragma endregion Fields
    
    #pragma region Service constructors
    arg(const arg &) = delete;
    arg(arg &&) = default;
    arg &operator=(const arg &) = delete;
    arg &operator=(arg &&) = default;
    #pragma endregion Service constructors

    #pragma region Uniform fields access
    /**
     * Returns a tuple of references to all fields.
     * Note that the tuple may include sequences (std::vector) and optional fields (null unique_ptr's).
     */
    auto get_fields_tuple() {
        return std::tie(name, type);
    }
    #pragma endregion Uniform fields access
};


}  // namespace bondrewd::ast::nodes
