// AUTOGENERATED by bondrewd/tools/pegen++/pegenxx.py on 2023-03-13 07:05:46
// DO NOT EDIT

#pragma once

#include <bondrewd/internal/common.hpp>
#include <bondrewd/parse/parser_base.hpp>
#include <bondrewd/ast/ast_nodes.gen.hpp>

#include <map>
#include <vector>
#include <optional>
#include <algorithm>


#pragma region Subheader
#include <string>


#pragma endregion Subheader


namespace bondrewd::parse {


#pragma region Parser
class Parser : public ParserBase<Parser> {
public:
    #pragma region Constructors
    Parser(lex::Lexer lexer_) : ParserBase(std::move(lexer_)) {}
    #pragma endregion Constructors

    #pragma region Service constructors
    Parser(const Parser &) = delete;
    Parser(Parser &&) = default;
    Parser &operator=(const Parser &) = delete;
    Parser &operator=(Parser &&) = default;
    #pragma endregion Service constructors

    #pragma region API
    auto parse() {
        return parse_start_rule();
    }

    #pragma endregion API

protected:
    #pragma region Constants and typedefs
    using state_t = lex::Lexer::state_t;
    #pragma endregion Constants and typedefs

    #pragma region Fields
    #pragma endregion Fields

    #pragma region Rule types
    enum class RuleType: unsigned {
        _gather_7,
        _gather_9,
        _loop0_1,
        _loop0_10,
        _loop0_11,
        _loop0_8,
        _loop1_3,
        _loop1_4,
        _loop1_5,
        _loop1_6,
        _tmp_12,
        _tmp_13,
        _tmp_2,
        array_expr,
        assign_op,
        assign_stmt,
        atom_expr,
        bidir_cmp_expr,
        bitand_expr,  // Left-recursive
        bitor_expr,  // Left-recursive
        bitxor_expr,  // Left-recursive
        block_expr,
        call_args,
        cartridge,
        cartridge_header,
        class_def,
        comparison_expr,
        comparison_followup_pair,
        comparison_op,
        conjunction_expr,
        disjunction_expr,
        expr,
        expr_or_unit,
        expr_stmt,
        factor_expr,
        func_args_def,
        func_def,
        group_expr,
        impl_stmt,
        inversion_expr,
        name,
        power_expr,
        primary_expr,  // Left-recursive
        shift_expr,  // Left-recursive
        start,
        stmt,
        strings,
        sum_expr,  // Left-recursive
        term_expr,  // Left-recursive
        tuple_expr,
        type_annotation,
        var_def_stmt,
    };

    static constexpr bool is_left_recursive(RuleType rule) {
        switch (rule) {
            case RuleType::bitand_expr:  return true;
            case RuleType::bitor_expr:  return true;
            case RuleType::bitxor_expr:  return true;
            case RuleType::primary_expr:  return true;
            case RuleType::shift_expr:  return true;
            case RuleType::sum_expr:  return true;
            case RuleType::term_expr:  return true;
            default:  return false;
        }
    }

    template <RuleType R>
    using rule_result_t = std::tuple_element_t<
        (unsigned)R,
        std::tuple<
            std::vector<lex::Token>,
            std::vector<lex::Token>,
            ast::sequence<ast::stmt>,
            std::vector<lex::Token>,
            ast::sequence<ast::stmt>,
            std::vector<lex::Token>,
            ast::sequence<ast::expr>,
            ast::sequence<ast::expr>,
            std::vector<std::pair < ast::cmp_op , ast::expr >>,
            std::vector<lex::Token>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::assign_op>,
            ast::field<ast::stmt>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::call_args>,
            ast::field<ast::cartridge>,
            std::string,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            std::pair < ast::cmp_op , ast::expr >,
            ast::field<ast::cmp_op>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::stmt>,
            ast::field<ast::expr>,
            ast::field<ast::arg_defs>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::stmt>,
            ast::field<ast::expr>,
            std::string,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::cartridge>,
            ast::field<ast::stmt>,
            std::string,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::stmt>
        >
    >;
    #pragma endregion Rule types

    #pragma region Helpers
    bool lookahead(bool positive, auto rule_func) {
        auto guard = lexer.lookahead(positive);

        // TODO: Pass this?
        return positive == (bool)rule_func();
    }

    template <typename U>
    U forced(U result) {
        if (!result) {
            // TODO: More info?
            fatal_error("Forced rule failed");
        }

        return std::move(result);
    }

    state_t tell() {
        return lexer.tell();
    }

    void seek(state_t state) {
        lexer.seek(state);
    }
    #pragma endregion Helpers

    #pragma region CacheHelper
    #if 0
    template <RuleType rule_type>
    class CacheHelper {
    public:
        using result_t = std::optional<rule_result_t<rule_type>>;

        CacheHelper(Parser &parser, state_t state, result_t &result) :
            parser{parser}, state{std::move(state)}, rule_type{rule_type}, result{result} {}
        
        CacheHelper(const CacheHelper &) = delete;
        CacheHelper(CacheHelper &&) = delete;
        CacheHelper &operator=(const CacheHelper &) = delete;
        CacheHelper &operator=(CacheHelper &&) = delete;

        void accept() {
            is_success = true;
        }

        ~CacheHelper() {
            if (is_success) {
                parser.store_cached<rule_type>(state, result);
            }
        }
        
    private:
        Parser &parser;
        state_t state;
        result_t &result;
        bool is_success = false;
    
    };
    #endif
    #pragma endregion CacheHelper

    #pragma region Caching
    template <RuleType rule_type>
    constexpr std::map<state_t, rule_result_t<rule_type>> &_get_cache() { {
            // Hack to bypass msvc's static_assert in templates optimization
            // (it was triggered despite being within a non-instantiated template function...)
            static_assert(false && rule_type == rule_type, "Uncachable rule type");
        }
    }

    template <RuleType rule_type>
    std::optional<rule_result_t<rule_type>> get_cached(state_t state) {
        auto &cache = _get_cache<rule_type>();

        auto it = cache.find(state);

        if (it == cache.end()) {
            return std::nullopt;
        }

        return it->second;
    }

    /// Updates, if present
    template <RuleType rule_type>
    void store_cached(state_t state, std::optional<rule_result_t<rule_type>> result) {
        auto &cache = _get_cache<rule_type>();

        cache.emplace(state, std::move(result));
    }
    #pragma endregion Caching

    #pragma region Rule parsers
    
    // start: cartridge
    std::optional<ast::field<ast::cartridge>> parse_start_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::cartridge>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // cartridge
            auto cartridge_var = parse_cartridge_rule();
            if (cartridge_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('cartridge'))]) (rule: Rule('start', 'ast::field<ast::cartridge>', Rhs([Alt([NamedItem(None, NameLeaf('cartridge'))])])))
                _res = cartridge_var;
                return _res;
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // cartridge: cartridge_header stmt*
    std::optional<ast::field<ast::cartridge>> parse_cartridge_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::cartridge>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // cartridge_header stmt*
            auto h = parse_cartridge_header_rule();
            if (h) {
            auto b = parse__loop0_1_rule();
            if (b) {
                _res = make_field<ast::cartridge>( ast::Cartridge ( std::move ( h ) , std::move ( b ) ));
                return _res;
            }
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // cartridge_header: 'cartridge' name ';'
    std::optional<std::string> parse_cartridge_header_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<std::string> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // 'cartridge' name ';'
            auto _keyword = lexer.expect().keyword(lex::HardKeyword::CARTRIDGE);
            if (_keyword) {
            auto n = parse_name_rule();
            if (n) {
            auto _literal = lexer.expect().punct(lex::Punct::SEMI);
            if (_literal) {
                _res = std::move ( n );
                return _res;
            }
            }
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // stmt: var_def_stmt | impl_stmt | assign_stmt | expr_stmt | ';'
    std::optional<ast::field<ast::stmt>> parse_stmt_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::stmt>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // var_def_stmt
            auto var_def_stmt_var = parse_var_def_stmt_rule();
            if (var_def_stmt_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('var_def_stmt'))]) (rule: Rule('stmt', 'ast::field<ast::stmt>', Rhs([Alt([NamedItem(None, NameLeaf('var_def_stmt'))]), Alt([NamedItem(None, NameLeaf('impl_stmt'))]), Alt([NamedItem(None, NameLeaf('assign_stmt'))]), Alt([NamedItem(None, NameLeaf('expr_stmt'))]), Alt([NamedItem(None, StringLeaf("';'"))], action='_field_ ast::Pass ( )')])))
                _res = var_def_stmt_var;
                return _res;
            }
            seek(_state);
        }
        { // impl_stmt
            auto impl_stmt_var = parse_impl_stmt_rule();
            if (impl_stmt_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('impl_stmt'))]) (rule: Rule('stmt', 'ast::field<ast::stmt>', Rhs([Alt([NamedItem(None, NameLeaf('var_def_stmt'))]), Alt([NamedItem(None, NameLeaf('impl_stmt'))]), Alt([NamedItem(None, NameLeaf('assign_stmt'))]), Alt([NamedItem(None, NameLeaf('expr_stmt'))]), Alt([NamedItem(None, StringLeaf("';'"))], action='_field_ ast::Pass ( )')])))
                _res = impl_stmt_var;
                return _res;
            }
            seek(_state);
        }
        { // assign_stmt
            auto assign_stmt_var = parse_assign_stmt_rule();
            if (assign_stmt_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('assign_stmt'))]) (rule: Rule('stmt', 'ast::field<ast::stmt>', Rhs([Alt([NamedItem(None, NameLeaf('var_def_stmt'))]), Alt([NamedItem(None, NameLeaf('impl_stmt'))]), Alt([NamedItem(None, NameLeaf('assign_stmt'))]), Alt([NamedItem(None, NameLeaf('expr_stmt'))]), Alt([NamedItem(None, StringLeaf("';'"))], action='_field_ ast::Pass ( )')])))
                _res = assign_stmt_var;
                return _res;
            }
            seek(_state);
        }
        { // expr_stmt
            auto expr_stmt_var = parse_expr_stmt_rule();
            if (expr_stmt_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('expr_stmt'))]) (rule: Rule('stmt', 'ast::field<ast::stmt>', Rhs([Alt([NamedItem(None, NameLeaf('var_def_stmt'))]), Alt([NamedItem(None, NameLeaf('impl_stmt'))]), Alt([NamedItem(None, NameLeaf('assign_stmt'))]), Alt([NamedItem(None, NameLeaf('expr_stmt'))]), Alt([NamedItem(None, StringLeaf("';'"))], action='_field_ ast::Pass ( )')])))
                _res = expr_stmt_var;
                return _res;
            }
            seek(_state);
        }
        { // ';'
            auto _literal = lexer.expect().punct(lex::Punct::SEMI);
            if (_literal) {
                _res = make_field<ast::stmt>( ast::Pass ( ));
                return _res;
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // assign_stmt: expr assign_op expr ';'
    std::optional<ast::field<ast::stmt>> parse_assign_stmt_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::stmt>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // expr assign_op expr ';'
            auto a = parse_expr_rule();
            if (a) {
            auto op = parse_assign_op_rule();
            if (op) {
            auto b = parse_expr_rule();
            if (b) {
            auto _literal = lexer.expect().punct(lex::Punct::SEMI);
            if (_literal) {
                _res = make_field<ast::stmt>( ast::Assign ( std::move ( a ) , std::move ( b ) , std::move ( op ) ));
                return _res;
            }
            }
            }
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // assign_op: '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '|=' | '^='
    std::optional<ast::field<ast::assign_op>> parse_assign_op_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::assign_op>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // '='
            auto _literal = lexer.expect().punct(lex::Punct::EQUAL);
            if (_literal) {
                _res = make_field<ast::assign_op>( ast::AsgnNone ( ));
                return _res;
            }
            seek(_state);
        }
        { // '+='
            auto _literal = lexer.expect().punct(lex::Punct::PLUSEQUAL);
            if (_literal) {
                _res = make_field<ast::assign_op>( ast::AsgnAdd ( ));
                return _res;
            }
            seek(_state);
        }
        { // '-='
            auto _literal = lexer.expect().punct(lex::Punct::MINEQUAL);
            if (_literal) {
                _res = make_field<ast::assign_op>( ast::AsgnSub ( ));
                return _res;
            }
            seek(_state);
        }
        { // '*='
            auto _literal = lexer.expect().punct(lex::Punct::STAREQUAL);
            if (_literal) {
                _res = make_field<ast::assign_op>( ast::AsgnMul ( ));
                return _res;
            }
            seek(_state);
        }
        { // '/='
            auto _literal = lexer.expect().punct(lex::Punct::SLASHEQUAL);
            if (_literal) {
                _res = make_field<ast::assign_op>( ast::AsgnDiv ( ));
                return _res;
            }
            seek(_state);
        }
        { // '%='
            auto _literal = lexer.expect().punct(lex::Punct::PERCENTEQUAL);
            if (_literal) {
                _res = make_field<ast::assign_op>( ast::AsgnMod ( ));
                return _res;
            }
            seek(_state);
        }
        { // '<<='
            auto _literal = lexer.expect().punct(lex::Punct::LEFTSHIFTEQUAL);
            if (_literal) {
                _res = make_field<ast::assign_op>( ast::AsgnLShift ( ));
                return _res;
            }
            seek(_state);
        }
        { // '>>='
            auto _literal = lexer.expect().punct(lex::Punct::RIGHTSHIFTEQUAL);
            if (_literal) {
                _res = make_field<ast::assign_op>( ast::AsgnRShift ( ));
                return _res;
            }
            seek(_state);
        }
        { // '&='
            auto _literal = lexer.expect().punct(lex::Punct::AMPEREQUAL);
            if (_literal) {
                _res = make_field<ast::assign_op>( ast::AsgnBitAnd ( ));
                return _res;
            }
            seek(_state);
        }
        { // '|='
            auto _literal = lexer.expect().punct(lex::Punct::VBAREQUAL);
            if (_literal) {
                _res = make_field<ast::assign_op>( ast::AsgnBitOr ( ));
                return _res;
            }
            seek(_state);
        }
        { // '^='
            auto _literal = lexer.expect().punct(lex::Punct::CIRCUMFLEXEQUAL);
            if (_literal) {
                _res = make_field<ast::assign_op>( ast::AsgnBitXor ( ));
                return _res;
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // var_def_stmt: 'ctime'? 'var' name type_annotation? ['=' expr] ';'
    std::optional<ast::field<ast::stmt>> parse_var_def_stmt_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::stmt>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // 'ctime'? 'var' name type_annotation? ['=' expr] ';'
            auto c = lexer.expect().keyword(lex::HardKeyword::CTIME);
            if (true) {
            auto _keyword = lexer.expect().keyword(lex::HardKeyword::VAR);
            if (_keyword) {
            auto n = parse_name_rule();
            if (n) {
            auto t = parse_type_annotation_rule();
            if (true) {
            auto v = parse__tmp_2_rule();
            if (true) {
            auto _literal = lexer.expect().punct(lex::Punct::SEMI);
            if (_literal) {
                _res = make_field<ast::stmt>( ast::VarDef ( std::move ( n ) , std::move ( t ) , std::move ( v ) , true , bool ( c ) ));
                return _res;
            }
            }
            }
            }
            }
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // impl_stmt: 
    std::optional<ast::field<ast::stmt>> parse_impl_stmt_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::stmt>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        return std::nullopt;
    }
    #else
    ;
    #endif

    // expr_stmt: expr ';'
    std::optional<ast::field<ast::stmt>> parse_expr_stmt_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::stmt>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // expr ';'
            auto a = parse_expr_rule();
            if (a) {
            auto _literal = lexer.expect().punct(lex::Punct::SEMI);
            if (_literal) {
                _res = make_field<ast::stmt>( ast::Expr ( std::move ( a ) ));
                return _res;
            }
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // expr:
    //     | func_def
    //     | class_def
    //     | block_expr
    //     | 'return' expr_or_unit
    //     | 'break' expr_or_unit
    //     | disjunction_expr
    std::optional<ast::field<ast::expr>> parse_expr_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // func_def
            auto func_def_var = parse_func_def_rule();
            if (func_def_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('func_def'))]) (rule: Rule('expr', 'ast::field<ast::expr>', Rhs([Alt([NamedItem(None, NameLeaf('func_def'))]), Alt([NamedItem(None, NameLeaf('class_def'))]), Alt([NamedItem(None, NameLeaf('block_expr'))]), Alt([NamedItem(None, StringLeaf("'return'")), NamedItem('a', NameLeaf('expr_or_unit'))], action='_field_ ast::Return ( std::move ( a ) )'), Alt([NamedItem(None, StringLeaf("'break'")), NamedItem('a', NameLeaf('expr_or_unit'))], action='_field_ ast::Break ( std::move ( a ) )'), Alt([NamedItem(None, NameLeaf('disjunction_expr'))])])))
                _res = func_def_var;
                return _res;
            }
            seek(_state);
        }
        { // class_def
            auto class_def_var = parse_class_def_rule();
            if (class_def_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('class_def'))]) (rule: Rule('expr', 'ast::field<ast::expr>', Rhs([Alt([NamedItem(None, NameLeaf('func_def'))]), Alt([NamedItem(None, NameLeaf('class_def'))]), Alt([NamedItem(None, NameLeaf('block_expr'))]), Alt([NamedItem(None, StringLeaf("'return'")), NamedItem('a', NameLeaf('expr_or_unit'))], action='_field_ ast::Return ( std::move ( a ) )'), Alt([NamedItem(None, StringLeaf("'break'")), NamedItem('a', NameLeaf('expr_or_unit'))], action='_field_ ast::Break ( std::move ( a ) )'), Alt([NamedItem(None, NameLeaf('disjunction_expr'))])])))
                _res = class_def_var;
                return _res;
            }
            seek(_state);
        }
        { // block_expr
            auto block_expr_var = parse_block_expr_rule();
            if (block_expr_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('block_expr'))]) (rule: Rule('expr', 'ast::field<ast::expr>', Rhs([Alt([NamedItem(None, NameLeaf('func_def'))]), Alt([NamedItem(None, NameLeaf('class_def'))]), Alt([NamedItem(None, NameLeaf('block_expr'))]), Alt([NamedItem(None, StringLeaf("'return'")), NamedItem('a', NameLeaf('expr_or_unit'))], action='_field_ ast::Return ( std::move ( a ) )'), Alt([NamedItem(None, StringLeaf("'break'")), NamedItem('a', NameLeaf('expr_or_unit'))], action='_field_ ast::Break ( std::move ( a ) )'), Alt([NamedItem(None, NameLeaf('disjunction_expr'))])])))
                _res = block_expr_var;
                return _res;
            }
            seek(_state);
        }
        { // 'return' expr_or_unit
            auto _keyword = lexer.expect().keyword(lex::HardKeyword::RETURN);
            if (_keyword) {
            auto a = parse_expr_or_unit_rule();
            if (a) {
                _res = make_field<ast::expr>( ast::Return ( std::move ( a ) ));
                return _res;
            }
            }
            seek(_state);
        }
        { // 'break' expr_or_unit
            auto _keyword = lexer.expect().keyword(lex::HardKeyword::BREAK);
            if (_keyword) {
            auto a = parse_expr_or_unit_rule();
            if (a) {
                _res = make_field<ast::expr>( ast::Break ( std::move ( a ) ));
                return _res;
            }
            }
            seek(_state);
        }
        { // disjunction_expr
            auto disjunction_expr_var = parse_disjunction_expr_rule();
            if (disjunction_expr_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('disjunction_expr'))]) (rule: Rule('expr', 'ast::field<ast::expr>', Rhs([Alt([NamedItem(None, NameLeaf('func_def'))]), Alt([NamedItem(None, NameLeaf('class_def'))]), Alt([NamedItem(None, NameLeaf('block_expr'))]), Alt([NamedItem(None, StringLeaf("'return'")), NamedItem('a', NameLeaf('expr_or_unit'))], action='_field_ ast::Return ( std::move ( a ) )'), Alt([NamedItem(None, StringLeaf("'break'")), NamedItem('a', NameLeaf('expr_or_unit'))], action='_field_ ast::Break ( std::move ( a ) )'), Alt([NamedItem(None, NameLeaf('disjunction_expr'))])])))
                _res = disjunction_expr_var;
                return _res;
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // expr_or_unit: expr | 
    std::optional<ast::field<ast::expr>> parse_expr_or_unit_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // expr
            auto expr_var = parse_expr_rule();
            if (expr_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('expr'))]) (rule: Rule('expr_or_unit', 'ast::field<ast::expr>', Rhs([Alt([NamedItem(None, NameLeaf('expr'))]), Alt([], action='_field_ ast::Constant ( std::monostate ( ) )')])))
                _res = expr_var;
                return _res;
            }
            seek(_state);
        }
        { // 
                _res = make_field<ast::expr>( ast::Constant ( std::monostate ( ) ));
                return _res;
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // disjunction_expr: conjunction_expr (('or' conjunction_expr))+ | conjunction_expr
    std::optional<ast::field<ast::expr>> parse_disjunction_expr_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // conjunction_expr (('or' conjunction_expr))+
            auto a = parse_conjunction_expr_rule();
            if (a) {
            auto b = parse__loop1_3_rule();
            if (b) {
                _res = make_field<ast::expr>( ast::BoolOp ( ast::Or ( ) , ... ));
                return _res;
            }
            }
            seek(_state);
        }
        { // conjunction_expr
            auto conjunction_expr_var = parse_conjunction_expr_rule();
            if (conjunction_expr_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('conjunction_expr'))]) (rule: Rule('disjunction_expr', 'ast::field<ast::expr>', Rhs([Alt([NamedItem('a', NameLeaf('conjunction_expr')), NamedItem('b', Repeat1(Group(Rhs([Alt([NamedItem(None, StringLeaf("'or'")), NamedItem('c', NameLeaf('conjunction_expr'))], action='c')]))))], action='_field_ ast::BoolOp ( ast::Or ( ) , ... )'), Alt([NamedItem(None, NameLeaf('conjunction_expr'))])])))
                _res = conjunction_expr_var;
                return _res;
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // conjunction_expr: inversion_expr (('and' inversion_expr))+ | inversion_expr
    std::optional<ast::field<ast::expr>> parse_conjunction_expr_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // inversion_expr (('and' inversion_expr))+
            auto a = parse_inversion_expr_rule();
            if (a) {
            auto b = parse__loop1_4_rule();
            if (b) {
                _res = make_field<ast::expr>( ast::BoolOp ( ast::And ( ) , ... ));
                return _res;
            }
            }
            seek(_state);
        }
        { // inversion_expr
            auto inversion_expr_var = parse_inversion_expr_rule();
            if (inversion_expr_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('inversion_expr'))]) (rule: Rule('conjunction_expr', 'ast::field<ast::expr>', Rhs([Alt([NamedItem('a', NameLeaf('inversion_expr')), NamedItem('b', Repeat1(Group(Rhs([Alt([NamedItem(None, StringLeaf("'and'")), NamedItem('c', NameLeaf('inversion_expr'))], action='c')]))))], action='_field_ ast::BoolOp ( ast::And ( ) , ... )'), Alt([NamedItem(None, NameLeaf('inversion_expr'))])])))
                _res = inversion_expr_var;
                return _res;
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // inversion_expr: 'not' inversion_expr | comparison_expr
    std::optional<ast::field<ast::expr>> parse_inversion_expr_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // 'not' inversion_expr
            auto _keyword = lexer.expect().keyword(lex::HardKeyword::NOT);
            if (_keyword) {
            auto a = parse_inversion_expr_rule();
            if (a) {
                _res = make_field<ast::expr>( ast::UnaryOp ( ast::Not ( ) , std::move ( a ) ));
                return _res;
            }
            }
            seek(_state);
        }
        { // comparison_expr
            auto comparison_expr_var = parse_comparison_expr_rule();
            if (comparison_expr_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('comparison_expr'))]) (rule: Rule('inversion_expr', 'ast::field<ast::expr>', Rhs([Alt([NamedItem(None, StringLeaf("'not'")), NamedItem('a', NameLeaf('inversion_expr'))], action='_field_ ast::UnaryOp ( ast::Not ( ) , std::move ( a ) )'), Alt([NamedItem(None, NameLeaf('comparison_expr'))])])))
                _res = comparison_expr_var;
                return _res;
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // comparison_expr: bidir_cmp_expr comparison_followup_pair+ | bidir_cmp_expr
    std::optional<ast::field<ast::expr>> parse_comparison_expr_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // bidir_cmp_expr comparison_followup_pair+
            auto a = parse_bidir_cmp_expr_rule();
            if (a) {
            auto b = parse__loop1_5_rule();
            if (b) {
                _res = make_field<ast::expr>( ast::Compare ( std::move ( a ) , make_sequence ( ... ) , make_sequence ( ... ) ));
                return _res;
            }
            }
            seek(_state);
        }
        { // bidir_cmp_expr
            auto bidir_cmp_expr_var = parse_bidir_cmp_expr_rule();
            if (bidir_cmp_expr_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('bidir_cmp_expr'))]) (rule: Rule('comparison_expr', 'ast::field<ast::expr>', Rhs([Alt([NamedItem('a', NameLeaf('bidir_cmp_expr')), NamedItem('b', Repeat1(NameLeaf('comparison_followup_pair')))], action='_field_ ast::Compare ( std::move ( a ) , make_sequence ( ... ) , make_sequence ( ... ) )'), Alt([NamedItem(None, NameLeaf('bidir_cmp_expr'))])])))
                _res = bidir_cmp_expr_var;
                return _res;
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // comparison_followup_pair: comparison_op bidir_cmp_expr
    std::optional<std::pair < ast::cmp_op , ast::expr >> parse_comparison_followup_pair_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<std::pair < ast::cmp_op , ast::expr >> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // comparison_op bidir_cmp_expr
            auto o = parse_comparison_op_rule();
            if (o) {
            auto a = parse_bidir_cmp_expr_rule();
            if (a) {
                _res = std::make_pair ( std::move ( o ) , std::move ( a ) );
                return _res;
            }
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // comparison_op: '==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in'
    std::optional<ast::field<ast::cmp_op>> parse_comparison_op_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::cmp_op>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // '=='
            auto _literal = lexer.expect().punct(lex::Punct::DOUBLEEQUAL);
            if (_literal) {
                _res = make_field<ast::cmp_op>( ast::Eq ( ));
                return _res;
            }
            seek(_state);
        }
        { // '!='
            auto _literal = lexer.expect().punct(lex::Punct::NOTEQUAL);
            if (_literal) {
                _res = make_field<ast::cmp_op>( ast::NotEq ( ));
                return _res;
            }
            seek(_state);
        }
        { // '<'
            auto _literal = lexer.expect().punct(lex::Punct::LESS);
            if (_literal) {
                _res = make_field<ast::cmp_op>( ast::Lt ( ));
                return _res;
            }
            seek(_state);
        }
        { // '<='
            auto _literal = lexer.expect().punct(lex::Punct::LESSEQUAL);
            if (_literal) {
                _res = make_field<ast::cmp_op>( ast::LtE ( ));
                return _res;
            }
            seek(_state);
        }
        { // '>'
            auto _literal = lexer.expect().punct(lex::Punct::GREATER);
            if (_literal) {
                _res = make_field<ast::cmp_op>( ast::Gt ( ));
                return _res;
            }
            seek(_state);
        }
        { // '>='
            auto _literal = lexer.expect().punct(lex::Punct::GREATEREQUAL);
            if (_literal) {
                _res = make_field<ast::cmp_op>( ast::GtE ( ));
                return _res;
            }
            seek(_state);
        }
        { // 'in'
            auto _keyword = lexer.expect().keyword(lex::HardKeyword::IN);
            if (_keyword) {
                _res = make_field<ast::cmp_op>( ast::In ( ));
                return _res;
            }
            seek(_state);
        }
        { // 'not' 'in'
            auto _keyword = lexer.expect().keyword(lex::HardKeyword::NOT);
            if (_keyword) {
            auto _keyword_1 = lexer.expect().keyword(lex::HardKeyword::IN);
            if (_keyword_1) {
                _res = make_field<ast::cmp_op>( ast::NotIn ( ));
                return _res;
            }
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // bidir_cmp_expr: bitor_expr '<=>' bitor_expr | bitor_expr
    std::optional<ast::field<ast::expr>> parse_bidir_cmp_expr_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // bitor_expr '<=>' bitor_expr
            auto a = parse_bitor_expr_rule();
            if (a) {
            auto _literal = lexer.expect().punct(lex::Punct::BIDIRCMP);
            if (_literal) {
            auto b = parse_bitor_expr_rule();
            if (b) {
                _res = make_field<ast::expr>( ast::Compare ( std::move ( a ) , std::move ( b ) ));
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // bitor_expr
            auto bitor_expr_var = parse_bitor_expr_rule();
            if (bitor_expr_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('bitor_expr'))]) (rule: Rule('bidir_cmp_expr', 'ast::field<ast::expr>', Rhs([Alt([NamedItem('a', NameLeaf('bitor_expr')), NamedItem(None, StringLeaf("'<=>'")), NamedItem('b', NameLeaf('bitor_expr'))], action='_field_ ast::Compare ( std::move ( a ) , std::move ( b ) )'), Alt([NamedItem(None, NameLeaf('bitor_expr'))])])))
                _res = bitor_expr_var;
                return _res;
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // Left-recursive
    // bitor_expr: bitor_expr '|' bitxor_expr | bitxor_expr
    std::optional<ast::field<ast::expr>> parse_bitor_expr_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        if (_res = get_cached<RuleType::bitor_expr>(_state)) {
            return _res;
        }
        auto _state = tell();
        auto _res_state = tell();
        while (true) {
            store_cached<RuleType::bitor_expr>(_state, _res);
            seek(_state);
            auto _raw = parse_raw_bitor_expr();
            if (!_raw || tell() <= _res_state) {
                break;
            }
            _res = std::move(_raw);
            _res_state = tell();
        }
        seek(_res_state);
        return _res;
    }
    #else
    ;
    #endif
    std::optional<ast::field<ast::expr>> parse_raw_bitor_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // bitor_expr '|' bitxor_expr
            auto a = parse_bitor_expr_rule();
            if (a) {
            auto _literal = lexer.expect().punct(lex::Punct::VBAR);
            if (_literal) {
            auto b = parse_bitxor_expr_rule();
            if (b) {
                _res = make_field<ast::expr>( ast::BinOp ( ast::BitOr ( ) , std::move ( a ) , std::move ( b ) ));
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // bitxor_expr
            auto bitxor_expr_var = parse_bitxor_expr_rule();
            if (bitxor_expr_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('bitxor_expr'))]) (rule: Rule('bitor_expr', 'ast::field<ast::expr>', Rhs([Alt([NamedItem('a', NameLeaf('bitor_expr')), NamedItem(None, StringLeaf("'|'")), NamedItem('b', NameLeaf('bitxor_expr'))], action='_field_ ast::BinOp ( ast::BitOr ( ) , std::move ( a ) , std::move ( b ) )'), Alt([NamedItem(None, NameLeaf('bitxor_expr'))])])))
                _res = bitxor_expr_var;
                return _res;
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // Left-recursive
    // bitxor_expr: bitxor_expr '^' bitand_expr | bitand_expr
    std::optional<ast::field<ast::expr>> parse_bitxor_expr_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        if (_res = get_cached<RuleType::bitxor_expr>(_state)) {
            return _res;
        }
        auto _state = tell();
        auto _res_state = tell();
        while (true) {
            store_cached<RuleType::bitxor_expr>(_state, _res);
            seek(_state);
            auto _raw = parse_raw_bitxor_expr();
            if (!_raw || tell() <= _res_state) {
                break;
            }
            _res = std::move(_raw);
            _res_state = tell();
        }
        seek(_res_state);
        return _res;
    }
    #else
    ;
    #endif
    std::optional<ast::field<ast::expr>> parse_raw_bitxor_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // bitxor_expr '^' bitand_expr
            auto a = parse_bitxor_expr_rule();
            if (a) {
            auto _literal = lexer.expect().punct(lex::Punct::CIRCUMFLEX);
            if (_literal) {
            auto b = parse_bitand_expr_rule();
            if (b) {
                _res = make_field<ast::expr>( ast::BinOp ( ast::BitXor ( ) , std::move ( a ) , std::move ( b ) ));
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // bitand_expr
            auto bitand_expr_var = parse_bitand_expr_rule();
            if (bitand_expr_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('bitand_expr'))]) (rule: Rule('bitxor_expr', 'ast::field<ast::expr>', Rhs([Alt([NamedItem('a', NameLeaf('bitxor_expr')), NamedItem(None, StringLeaf("'^'")), NamedItem('b', NameLeaf('bitand_expr'))], action='_field_ ast::BinOp ( ast::BitXor ( ) , std::move ( a ) , std::move ( b ) )'), Alt([NamedItem(None, NameLeaf('bitand_expr'))])])))
                _res = bitand_expr_var;
                return _res;
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // Left-recursive
    // bitand_expr: bitand_expr '&' shift_expr | shift_expr
    std::optional<ast::field<ast::expr>> parse_bitand_expr_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        if (_res = get_cached<RuleType::bitand_expr>(_state)) {
            return _res;
        }
        auto _state = tell();
        auto _res_state = tell();
        while (true) {
            store_cached<RuleType::bitand_expr>(_state, _res);
            seek(_state);
            auto _raw = parse_raw_bitand_expr();
            if (!_raw || tell() <= _res_state) {
                break;
            }
            _res = std::move(_raw);
            _res_state = tell();
        }
        seek(_res_state);
        return _res;
    }
    #else
    ;
    #endif
    std::optional<ast::field<ast::expr>> parse_raw_bitand_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // bitand_expr '&' shift_expr
            auto a = parse_bitand_expr_rule();
            if (a) {
            auto _literal = lexer.expect().punct(lex::Punct::AMPER);
            if (_literal) {
            auto b = parse_shift_expr_rule();
            if (b) {
                _res = make_field<ast::expr>( ast::BinOp ( ast::BitAnd ( ) , std::move ( a ) , std::move ( b ) ));
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // shift_expr
            auto shift_expr_var = parse_shift_expr_rule();
            if (shift_expr_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('shift_expr'))]) (rule: Rule('bitand_expr', 'ast::field<ast::expr>', Rhs([Alt([NamedItem('a', NameLeaf('bitand_expr')), NamedItem(None, StringLeaf("'&'")), NamedItem('b', NameLeaf('shift_expr'))], action='_field_ ast::BinOp ( ast::BitAnd ( ) , std::move ( a ) , std::move ( b ) )'), Alt([NamedItem(None, NameLeaf('shift_expr'))])])))
                _res = shift_expr_var;
                return _res;
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // Left-recursive
    // shift_expr: shift_expr '<<' sum_expr | shift_expr '>>' sum_expr | sum_expr
    std::optional<ast::field<ast::expr>> parse_shift_expr_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        if (_res = get_cached<RuleType::shift_expr>(_state)) {
            return _res;
        }
        auto _state = tell();
        auto _res_state = tell();
        while (true) {
            store_cached<RuleType::shift_expr>(_state, _res);
            seek(_state);
            auto _raw = parse_raw_shift_expr();
            if (!_raw || tell() <= _res_state) {
                break;
            }
            _res = std::move(_raw);
            _res_state = tell();
        }
        seek(_res_state);
        return _res;
    }
    #else
    ;
    #endif
    std::optional<ast::field<ast::expr>> parse_raw_shift_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // shift_expr '<<' sum_expr
            auto a = parse_shift_expr_rule();
            if (a) {
            auto _literal = lexer.expect().punct(lex::Punct::LEFTSHIFT);
            if (_literal) {
            auto b = parse_sum_expr_rule();
            if (b) {
                _res = make_field<ast::expr>( ast::BinOp ( ast::LShift ( ) , std::move ( a ) , std::move ( b ) ));
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // shift_expr '>>' sum_expr
            auto a = parse_shift_expr_rule();
            if (a) {
            auto _literal = lexer.expect().punct(lex::Punct::RIGHTSHIFT);
            if (_literal) {
            auto b = parse_sum_expr_rule();
            if (b) {
                _res = make_field<ast::expr>( ast::BinOp ( ast::RShift ( ) , std::move ( a ) , std::move ( b ) ));
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // sum_expr
            auto sum_expr_var = parse_sum_expr_rule();
            if (sum_expr_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('sum_expr'))]) (rule: Rule('shift_expr', 'ast::field<ast::expr>', Rhs([Alt([NamedItem('a', NameLeaf('shift_expr')), NamedItem(None, StringLeaf("'<<'")), NamedItem('b', NameLeaf('sum_expr'))], action='_field_ ast::BinOp ( ast::LShift ( ) , std::move ( a ) , std::move ( b ) )'), Alt([NamedItem('a', NameLeaf('shift_expr')), NamedItem(None, StringLeaf("'>>'")), NamedItem('b', NameLeaf('sum_expr'))], action='_field_ ast::BinOp ( ast::RShift ( ) , std::move ( a ) , std::move ( b ) )'), Alt([NamedItem(None, NameLeaf('sum_expr'))])])))
                _res = sum_expr_var;
                return _res;
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // Left-recursive
    // sum_expr: sum_expr '+' term_expr | sum_expr '-' term_expr | term_expr
    std::optional<ast::field<ast::expr>> parse_sum_expr_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        if (_res = get_cached<RuleType::sum_expr>(_state)) {
            return _res;
        }
        auto _state = tell();
        auto _res_state = tell();
        while (true) {
            store_cached<RuleType::sum_expr>(_state, _res);
            seek(_state);
            auto _raw = parse_raw_sum_expr();
            if (!_raw || tell() <= _res_state) {
                break;
            }
            _res = std::move(_raw);
            _res_state = tell();
        }
        seek(_res_state);
        return _res;
    }
    #else
    ;
    #endif
    std::optional<ast::field<ast::expr>> parse_raw_sum_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // sum_expr '+' term_expr
            auto a = parse_sum_expr_rule();
            if (a) {
            auto _literal = lexer.expect().punct(lex::Punct::PLUS);
            if (_literal) {
            auto b = parse_term_expr_rule();
            if (b) {
                _res = make_field<ast::expr>( ast::BinOp ( ast::Add ( ) , std::move ( a ) , std::move ( b ) ));
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // sum_expr '-' term_expr
            auto a = parse_sum_expr_rule();
            if (a) {
            auto _literal = lexer.expect().punct(lex::Punct::MINUS);
            if (_literal) {
            auto b = parse_term_expr_rule();
            if (b) {
                _res = make_field<ast::expr>( ast::BinOp ( ast::Sub ( ) , std::move ( a ) , std::move ( b ) ));
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // term_expr
            auto term_expr_var = parse_term_expr_rule();
            if (term_expr_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('term_expr'))]) (rule: Rule('sum_expr', 'ast::field<ast::expr>', Rhs([Alt([NamedItem('a', NameLeaf('sum_expr')), NamedItem(None, StringLeaf("'+'")), NamedItem('b', NameLeaf('term_expr'))], action='_field_ ast::BinOp ( ast::Add ( ) , std::move ( a ) , std::move ( b ) )'), Alt([NamedItem('a', NameLeaf('sum_expr')), NamedItem(None, StringLeaf("'-'")), NamedItem('b', NameLeaf('term_expr'))], action='_field_ ast::BinOp ( ast::Sub ( ) , std::move ( a ) , std::move ( b ) )'), Alt([NamedItem(None, NameLeaf('term_expr'))])])))
                _res = term_expr_var;
                return _res;
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // Left-recursive
    // term_expr:
    //     | term_expr '*' factor_expr
    //     | term_expr '/' factor_expr
    //     | term_expr '%' factor_expr
    //     | factor_expr
    std::optional<ast::field<ast::expr>> parse_term_expr_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        if (_res = get_cached<RuleType::term_expr>(_state)) {
            return _res;
        }
        auto _state = tell();
        auto _res_state = tell();
        while (true) {
            store_cached<RuleType::term_expr>(_state, _res);
            seek(_state);
            auto _raw = parse_raw_term_expr();
            if (!_raw || tell() <= _res_state) {
                break;
            }
            _res = std::move(_raw);
            _res_state = tell();
        }
        seek(_res_state);
        return _res;
    }
    #else
    ;
    #endif
    std::optional<ast::field<ast::expr>> parse_raw_term_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // term_expr '*' factor_expr
            auto a = parse_term_expr_rule();
            if (a) {
            auto _literal = lexer.expect().punct(lex::Punct::STAR);
            if (_literal) {
            auto b = parse_factor_expr_rule();
            if (b) {
                _res = make_field<ast::expr>( ast::BinOp ( ast::Mul ( ) , std::move ( a ) , std::move ( b ) ));
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // term_expr '/' factor_expr
            auto a = parse_term_expr_rule();
            if (a) {
            auto _literal = lexer.expect().punct(lex::Punct::SLASH);
            if (_literal) {
            auto b = parse_factor_expr_rule();
            if (b) {
                _res = make_field<ast::expr>( ast::BinOp ( ast::Div ( ) , std::move ( a ) , std::move ( b ) ));
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // term_expr '%' factor_expr
            auto a = parse_term_expr_rule();
            if (a) {
            auto _literal = lexer.expect().punct(lex::Punct::PERCENT);
            if (_literal) {
            auto b = parse_factor_expr_rule();
            if (b) {
                _res = make_field<ast::expr>( ast::BinOp ( ast::Mod ( ) , std::move ( a ) , std::move ( b ) ));
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // factor_expr
            auto factor_expr_var = parse_factor_expr_rule();
            if (factor_expr_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('factor_expr'))]) (rule: Rule('term_expr', 'ast::field<ast::expr>', Rhs([Alt([NamedItem('a', NameLeaf('term_expr')), NamedItem(None, StringLeaf("'*'")), NamedItem('b', NameLeaf('factor_expr'))], action='_field_ ast::BinOp ( ast::Mul ( ) , std::move ( a ) , std::move ( b ) )'), Alt([NamedItem('a', NameLeaf('term_expr')), NamedItem(None, StringLeaf("'/'")), NamedItem('b', NameLeaf('factor_expr'))], action='_field_ ast::BinOp ( ast::Div ( ) , std::move ( a ) , std::move ( b ) )'), Alt([NamedItem('a', NameLeaf('term_expr')), NamedItem(None, StringLeaf("'%'")), NamedItem('b', NameLeaf('factor_expr'))], action='_field_ ast::BinOp ( ast::Mod ( ) , std::move ( a ) , std::move ( b ) )'), Alt([NamedItem(None, NameLeaf('factor_expr'))])])))
                _res = factor_expr_var;
                return _res;
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // factor_expr: '+' factor_expr | '-' factor_expr | '~' factor_expr | power_expr
    std::optional<ast::field<ast::expr>> parse_factor_expr_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // '+' factor_expr
            auto _literal = lexer.expect().punct(lex::Punct::PLUS);
            if (_literal) {
            auto a = parse_factor_expr_rule();
            if (a) {
                _res = make_field<ast::expr>( ast::UnaryOp ( ast::UAdd ( ) , std::move ( a ) ));
                return _res;
            }
            }
            seek(_state);
        }
        { // '-' factor_expr
            auto _literal = lexer.expect().punct(lex::Punct::MINUS);
            if (_literal) {
            auto a = parse_factor_expr_rule();
            if (a) {
                _res = make_field<ast::expr>( ast::UnaryOp ( ast::USub ( ) , std::move ( a ) ));
                return _res;
            }
            }
            seek(_state);
        }
        { // '~' factor_expr
            auto _literal = lexer.expect().punct(lex::Punct::TILDE);
            if (_literal) {
            auto a = parse_factor_expr_rule();
            if (a) {
                _res = make_field<ast::expr>( ast::UnaryOp ( ast::BitInv ( ) , std::move ( a ) ));
                return _res;
            }
            }
            seek(_state);
        }
        { // power_expr
            auto power_expr_var = parse_power_expr_rule();
            if (power_expr_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('power_expr'))]) (rule: Rule('factor_expr', 'ast::field<ast::expr>', Rhs([Alt([NamedItem(None, StringLeaf("'+'")), NamedItem('a', NameLeaf('factor_expr'))], action='_field_ ast::UnaryOp ( ast::UAdd ( ) , std::move ( a ) )'), Alt([NamedItem(None, StringLeaf("'-'")), NamedItem('a', NameLeaf('factor_expr'))], action='_field_ ast::UnaryOp ( ast::USub ( ) , std::move ( a ) )'), Alt([NamedItem(None, StringLeaf("'~'")), NamedItem('a', NameLeaf('factor_expr'))], action='_field_ ast::UnaryOp ( ast::BitInv ( ) , std::move ( a ) )'), Alt([NamedItem(None, NameLeaf('power_expr'))])])))
                _res = power_expr_var;
                return _res;
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // power_expr: primary_expr '**' factor_expr | primary_expr
    std::optional<ast::field<ast::expr>> parse_power_expr_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // primary_expr '**' factor_expr
            auto a = parse_primary_expr_rule();
            if (a) {
            auto _literal = lexer.expect().punct(lex::Punct::POWER);
            if (_literal) {
            auto b = parse_factor_expr_rule();
            if (b) {
                _res = make_field<ast::expr>( ast::BinOp ( ast::Pow ( ) , std::move ( a ) , std::move ( b ) ));
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // primary_expr
            auto primary_expr_var = parse_primary_expr_rule();
            if (primary_expr_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('primary_expr'))]) (rule: Rule('power_expr', 'ast::field<ast::expr>', Rhs([Alt([NamedItem('a', NameLeaf('primary_expr')), NamedItem(None, StringLeaf("'**'")), NamedItem('b', NameLeaf('factor_expr'))], action='_field_ ast::BinOp ( ast::Pow ( ) , std::move ( a ) , std::move ( b ) )'), Alt([NamedItem(None, NameLeaf('primary_expr'))])])))
                _res = primary_expr_var;
                return _res;
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // Left-recursive
    // primary_expr:
    //     | primary_expr '.' name
    //     | primary_expr '::' name
    //     | primary_expr '[' call_args ']'
    //     | primary_expr '(' call_args ')'
    //     | atom_expr
    std::optional<ast::field<ast::expr>> parse_primary_expr_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        if (_res = get_cached<RuleType::primary_expr>(_state)) {
            return _res;
        }
        auto _state = tell();
        auto _res_state = tell();
        while (true) {
            store_cached<RuleType::primary_expr>(_state, _res);
            seek(_state);
            auto _raw = parse_raw_primary_expr();
            if (!_raw || tell() <= _res_state) {
                break;
            }
            _res = std::move(_raw);
            _res_state = tell();
        }
        seek(_res_state);
        return _res;
    }
    #else
    ;
    #endif
    std::optional<ast::field<ast::expr>> parse_raw_primary_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // primary_expr '.' name
            auto a = parse_primary_expr_rule();
            if (a) {
            auto _literal = lexer.expect().punct(lex::Punct::DOT);
            if (_literal) {
            auto b = parse_name_rule();
            if (b) {
                _res = make_field<ast::expr>( ast::Attribute ( std::move ( a ) , std::move ( b ) , ast::AttrInst ( ) ));
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // primary_expr '::' name
            auto a = parse_primary_expr_rule();
            if (a) {
            auto _literal = lexer.expect().punct(lex::Punct::DOUBLECOLON);
            if (_literal) {
            auto b = parse_name_rule();
            if (b) {
                _res = make_field<ast::expr>( ast::Attribute ( std::move ( a ) , std::move ( b ) , ast::AttrStatic ( ) ));
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // primary_expr '[' call_args ']'
            auto a = parse_primary_expr_rule();
            if (a) {
            auto _literal = lexer.expect().punct(lex::Punct::LSQB);
            if (_literal) {
            auto b = parse_call_args_rule();
            if (b) {
            auto _literal_1 = lexer.expect().punct(lex::Punct::RSQB);
            if (_literal_1) {
                _res = make_field<ast::expr>( ast::Subscript ( std::move ( a ) , std::move ( b ) ));
                return _res;
            }
            }
            }
            }
            seek(_state);
        }
        { // primary_expr '(' call_args ')'
            auto a = parse_primary_expr_rule();
            if (a) {
            auto _literal = lexer.expect().punct(lex::Punct::LPAR);
            if (_literal) {
            auto b = parse_call_args_rule();
            if (b) {
            auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
            if (_literal_1) {
                _res = make_field<ast::expr>( ast::Call ( std::move ( a ) , std::move ( b ) ));
                return _res;
            }
            }
            }
            }
            seek(_state);
        }
        { // atom_expr
            auto atom_expr_var = parse_atom_expr_rule();
            if (atom_expr_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('atom_expr'))]) (rule: Rule('primary_expr', 'ast::field<ast::expr>', Rhs([Alt([NamedItem('a', NameLeaf('primary_expr')), NamedItem(None, StringLeaf("'.'")), NamedItem('b', NameLeaf('name'))], action='_field_ ast::Attribute ( std::move ( a ) , std::move ( b ) , ast::AttrInst ( ) )'), Alt([NamedItem('a', NameLeaf('primary_expr')), NamedItem(None, StringLeaf("'::'")), NamedItem('b', NameLeaf('name'))], action='_field_ ast::Attribute ( std::move ( a ) , std::move ( b ) , ast::AttrStatic ( ) )'), Alt([NamedItem('a', NameLeaf('primary_expr')), NamedItem(None, StringLeaf("'['")), NamedItem('b', NameLeaf('call_args')), NamedItem(None, StringLeaf("']'"))], action='_field_ ast::Subscript ( std::move ( a ) , std::move ( b ) )'), Alt([NamedItem('a', NameLeaf('primary_expr')), NamedItem(None, StringLeaf("'('")), NamedItem('b', NameLeaf('call_args')), NamedItem(None, StringLeaf("')'"))], action='_field_ ast::Call ( std::move ( a ) , std::move ( b ) )'), Alt([NamedItem(None, NameLeaf('atom_expr'))])])))
                _res = atom_expr_var;
                return _res;
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // atom_expr:
    //     | name
    //     | NUMBER
    //     | &STRING strings
    //     | group_expr
    //     | tuple_expr
    //     | array_expr
    //     | block_expr
    std::optional<ast::field<ast::expr>> parse_atom_expr_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // name
            auto a = parse_name_rule();
            if (a) {
                _res = make_field<ast::expr>( ast::Name ( std::move ( a ) ));
                return _res;
            }
            seek(_state);
        }
        { // NUMBER
            auto a = lexer.expect().token(TokenType::NUMBER);
            if (a) {
                _res = make_field<ast::expr>( ast::Constant ( a . get_number ( ) . value ));
                return _res;
            }
            seek(_state);
        }
        { // &STRING strings
            auto _tmpvar = lexer.lookahead(true).token(TokenType::STRING);
            if (_tmpvar) {
            auto a = parse_strings_rule();
            if (a) {
                _res = make_field<ast::expr>( std::move ( a ));
                return _res;
            }
            }
            seek(_state);
        }
        { // group_expr
            auto group_expr_var = parse_group_expr_rule();
            if (group_expr_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('group_expr'))]) (rule: Rule('atom_expr', 'ast::field<ast::expr>', Rhs([Alt([NamedItem('a', NameLeaf('name'))], action='_field_ ast::Name ( std::move ( a ) )'), Alt([NamedItem('a', NameLeaf('NUMBER'))], action='_field_ ast::Constant ( a . get_number ( ) . value )'), Alt([NamedItem(None, PositiveLookahead(NameLeaf('STRING'))), NamedItem('a', NameLeaf('strings'))], action='_field_ std::move ( a )'), Alt([NamedItem(None, NameLeaf('group_expr'))]), Alt([NamedItem(None, NameLeaf('tuple_expr'))]), Alt([NamedItem(None, NameLeaf('array_expr'))]), Alt([NamedItem(None, NameLeaf('block_expr'))])])))
                _res = group_expr_var;
                return _res;
            }
            seek(_state);
        }
        { // tuple_expr
            auto tuple_expr_var = parse_tuple_expr_rule();
            if (tuple_expr_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('tuple_expr'))]) (rule: Rule('atom_expr', 'ast::field<ast::expr>', Rhs([Alt([NamedItem('a', NameLeaf('name'))], action='_field_ ast::Name ( std::move ( a ) )'), Alt([NamedItem('a', NameLeaf('NUMBER'))], action='_field_ ast::Constant ( a . get_number ( ) . value )'), Alt([NamedItem(None, PositiveLookahead(NameLeaf('STRING'))), NamedItem('a', NameLeaf('strings'))], action='_field_ std::move ( a )'), Alt([NamedItem(None, NameLeaf('group_expr'))]), Alt([NamedItem(None, NameLeaf('tuple_expr'))]), Alt([NamedItem(None, NameLeaf('array_expr'))]), Alt([NamedItem(None, NameLeaf('block_expr'))])])))
                _res = tuple_expr_var;
                return _res;
            }
            seek(_state);
        }
        { // array_expr
            auto array_expr_var = parse_array_expr_rule();
            if (array_expr_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('array_expr'))]) (rule: Rule('atom_expr', 'ast::field<ast::expr>', Rhs([Alt([NamedItem('a', NameLeaf('name'))], action='_field_ ast::Name ( std::move ( a ) )'), Alt([NamedItem('a', NameLeaf('NUMBER'))], action='_field_ ast::Constant ( a . get_number ( ) . value )'), Alt([NamedItem(None, PositiveLookahead(NameLeaf('STRING'))), NamedItem('a', NameLeaf('strings'))], action='_field_ std::move ( a )'), Alt([NamedItem(None, NameLeaf('group_expr'))]), Alt([NamedItem(None, NameLeaf('tuple_expr'))]), Alt([NamedItem(None, NameLeaf('array_expr'))]), Alt([NamedItem(None, NameLeaf('block_expr'))])])))
                _res = array_expr_var;
                return _res;
            }
            seek(_state);
        }
        { // block_expr
            auto block_expr_var = parse_block_expr_rule();
            if (block_expr_var) {
                // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('block_expr'))]) (rule: Rule('atom_expr', 'ast::field<ast::expr>', Rhs([Alt([NamedItem('a', NameLeaf('name'))], action='_field_ ast::Name ( std::move ( a ) )'), Alt([NamedItem('a', NameLeaf('NUMBER'))], action='_field_ ast::Constant ( a . get_number ( ) . value )'), Alt([NamedItem(None, PositiveLookahead(NameLeaf('STRING'))), NamedItem('a', NameLeaf('strings'))], action='_field_ std::move ( a )'), Alt([NamedItem(None, NameLeaf('group_expr'))]), Alt([NamedItem(None, NameLeaf('tuple_expr'))]), Alt([NamedItem(None, NameLeaf('array_expr'))]), Alt([NamedItem(None, NameLeaf('block_expr'))])])))
                _res = block_expr_var;
                return _res;
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // call_args: 
    std::optional<ast::field<ast::call_args>> parse_call_args_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::call_args>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // 
                _res = make_field<ast::call_args>( ast::call_args ( make_sequence ( ) , nullptr , nullptr ));
                return _res;
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // name: NAME
    std::optional<std::string> parse_name_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<std::string> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // NAME
            auto a = lexer.expect().token(TokenType::NAME);
            if (a) {
                _res = a . get_name ( ) . value;
                return _res;
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // strings: STRING+
    std::optional<std::string> parse_strings_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<std::string> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // STRING+
            auto a = parse__loop1_6_rule();
            if (a) {
                _res = _concat_strings ( a );
                return _res;
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // group_expr: '(' expr ')'
    std::optional<ast::field<ast::expr>> parse_group_expr_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // '(' expr ')'
            auto _literal = lexer.expect().punct(lex::Punct::LPAR);
            if (_literal) {
            auto a = parse_expr_rule();
            if (a) {
            auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
            if (_literal_1) {
                _res = std::move ( a );
                return _res;
            }
            }
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // tuple_expr: '(' ')' | '(' ','.expr+ ','? ')'
    std::optional<ast::field<ast::expr>> parse_tuple_expr_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // '(' ')'
            auto _literal = lexer.expect().punct(lex::Punct::LPAR);
            if (_literal) {
            auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
            if (_literal_1) {
                _res = make_field<ast::expr>( ast::Tuple ( make_sequence ( ) ));
                return _res;
            }
            }
            seek(_state);
        }
        { // '(' ','.expr+ ','? ')'
            auto _literal = lexer.expect().punct(lex::Punct::LPAR);
            if (_literal) {
            auto a = parse__gather_7_rule();
            if (a) {
            auto _opt_var = lexer.expect().punct(lex::Punct::COMMA);
            if (true) {
            auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
            if (_literal_1) {
                _res = make_field<ast::expr>( ast::Tuple ( std::move ( a ) ));
                return _res;
            }
            }
            }
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // array_expr: '[' ']' | '[' ','.expr+ ','? ']'
    std::optional<ast::field<ast::expr>> parse_array_expr_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // '[' ']'
            auto _literal = lexer.expect().punct(lex::Punct::LSQB);
            if (_literal) {
            auto _literal_1 = lexer.expect().punct(lex::Punct::RSQB);
            if (_literal_1) {
                _res = make_field<ast::expr>( ast::Array ( make_sequence ( ) ));
                return _res;
            }
            }
            seek(_state);
        }
        { // '[' ','.expr+ ','? ']'
            auto _literal = lexer.expect().punct(lex::Punct::LSQB);
            if (_literal) {
            auto a = parse__gather_9_rule();
            if (a) {
            auto _opt_var = lexer.expect().punct(lex::Punct::COMMA);
            if (true) {
            auto _literal_1 = lexer.expect().punct(lex::Punct::RSQB);
            if (_literal_1) {
                _res = make_field<ast::expr>( ast::Array ( std::move ( a ) ));
                return _res;
            }
            }
            }
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // block_expr: 'ctime'? '{' stmt* expr_or_unit '}'
    std::optional<ast::field<ast::expr>> parse_block_expr_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // 'ctime'? '{' stmt* expr_or_unit '}'
            auto c = lexer.expect().keyword(lex::HardKeyword::CTIME);
            if (true) {
            auto _literal = lexer.expect().punct(lex::Punct::LBRACE);
            if (_literal) {
            auto b = parse__loop0_11_rule();
            if (b) {
            auto v = parse_expr_or_unit_rule();
            if (v) {
            auto _literal_1 = lexer.expect().punct(lex::Punct::RBRACE);
            if (_literal_1) {
                _res = make_field<ast::expr>( ast::Block ( std::move ( b ) , std::move ( v ) , bool ( c ) ));
                return _res;
            }
            }
            }
            }
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // type_annotation: ':' expr
    std::optional<ast::field<ast::expr>> parse_type_annotation_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // ':' expr
            auto _literal = lexer.expect().punct(lex::Punct::COLON);
            if (_literal) {
            auto a = parse_expr_rule();
            if (a) {
                _res = std::move ( a );
                return _res;
            }
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // func_def: 'func' name '(' func_args_def ')' type_annotation? '=>' expr ';'
    std::optional<ast::field<ast::expr>> parse_func_def_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // 'func' name '(' func_args_def ')' type_annotation? '=>' expr ';'
            auto _keyword = lexer.expect().keyword(lex::HardKeyword::FUNC);
            if (_keyword) {
            auto n = parse_name_rule();
            if (n) {
            auto _literal = lexer.expect().punct(lex::Punct::LPAR);
            if (_literal) {
            auto a = parse_func_args_def_rule();
            if (a) {
            auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
            if (_literal_1) {
            auto t = parse_type_annotation_rule();
            if (true) {
            auto _literal_2 = lexer.expect().punct(lex::Punct::RARROW2);
            if (_literal_2) {
            auto b = parse_expr_rule();
            if (b) {
            auto _literal_3 = lexer.expect().punct(lex::Punct::SEMI);
            if (_literal_3) {
                _res = make_field<ast::expr>( ast::FuncDef ( std::move ( n ) , std::move ( a ) , std::move ( t ) , std::move ( b ) ));
                return _res;
            }
            }
            }
            }
            }
            }
            }
            }
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // func_args_def: 
    std::optional<ast::field<ast::arg_defs>> parse_func_args_def_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::arg_defs>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // 
                _res = make_field<ast::arg_defs>( ast::arg_defs ( make_sequence ( ) ));
                return _res;
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // class_def: 'ctime'? 'class' name '(' func_args_def ')' ';'
    std::optional<ast::field<ast::expr>> parse_class_def_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // 'ctime'? 'class' name '(' func_args_def ')' ';'
            auto c = lexer.expect().keyword(lex::HardKeyword::CTIME);
            if (true) {
            auto _keyword = lexer.expect().keyword(lex::HardKeyword::CLASS);
            if (_keyword) {
            auto n = parse_name_rule();
            if (n) {
            auto _literal = lexer.expect().punct(lex::Punct::LPAR);
            if (_literal) {
            auto a = parse_func_args_def_rule();
            if (a) {
            auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
            if (_literal_1) {
            auto _literal_2 = lexer.expect().punct(lex::Punct::SEMI);
            if (_literal_2) {
                // !!! DBG: BAD ACTION: Alt([NamedItem('c', Opt(StringLeaf("'ctime'"))), NamedItem(None, StringLeaf("'class'")), NamedItem('n', NameLeaf('name')), NamedItem(None, StringLeaf("'('")), NamedItem('a', NameLeaf('func_args_def')), NamedItem(None, StringLeaf("')'")), NamedItem(None, StringLeaf("';'"))]) (rule: Rule('class_def', 'ast::field<ast::expr>', Rhs([Alt([NamedItem('c', Opt(StringLeaf("'ctime'"))), NamedItem(None, StringLeaf("'class'")), NamedItem('n', NameLeaf('name')), NamedItem(None, StringLeaf("'('")), NamedItem('a', NameLeaf('func_args_def')), NamedItem(None, StringLeaf("')'")), NamedItem(None, StringLeaf("';'"))])])))
                _res = _dummy_whatever_(c, _keyword, n, _literal, a, _literal_1, _literal_2);
                return _res;
            }
            }
            }
            }
            }
            }
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // _loop0_1: stmt
    std::optional<ast::sequence<ast::stmt>> parse__loop0_1_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        const auto _state = tell();
        (void)_state;
        std::optional<ast::sequence<ast::stmt>> _res = std::nullopt;
        auto _state = tell();
        int _start_state = tell();
        std::vector<ast::sequence<ast::stmt>> _children{};
        size_t _n = 0;
        { // stmt
            while (true) {
                auto stmt_var = parse_stmt_rule();
                if (stmt_var) {
                    // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('stmt'))]) (rule: Rule('_loop0_1', 'ast::sequence<ast::stmt>', Rhs([Alt([NamedItem(None, NameLeaf('stmt'))])])))
                    _res = stmt_var;
                    _children.push_back(_res);
                    _state = tell();
                    continue;
                }
                break;
            }
            seek(_state);
        }
        auto _seq = ast::make_sequence(std::move(_res));
        return _seq;
    }
    #else
    ;
    #endif

    // _tmp_2: '=' expr
    std::optional<ast::field<ast::expr>> parse__tmp_2_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // '=' expr
            auto _literal = lexer.expect().punct(lex::Punct::EQUAL);
            if (_literal) {
            auto a = parse_expr_rule();
            if (a) {
                _res = a;
                return _res;
            }
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // _loop1_3: ('or' conjunction_expr)
    std::optional<ast::sequence<ast::expr>> parse__loop1_3_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        const auto _state = tell();
        (void)_state;
        std::optional<ast::sequence<ast::expr>> _res = std::nullopt;
        auto _state = tell();
        int _start_state = tell();
        std::vector<ast::sequence<ast::expr>> _children{};
        size_t _n = 0;
        { // ('or' conjunction_expr)
            while (true) {
                auto _tmp_12_var = parse__tmp_12_rule();
                if (_tmp_12_var) {
                    // !!! DBG: BAD ACTION: Alt([NamedItem(None, Group(Rhs([Alt([NamedItem(None, StringLeaf("'or'")), NamedItem('c', NameLeaf('conjunction_expr'))], action='c')])))]) (rule: Rule('_loop1_3', 'ast::sequence<ast::expr>', Rhs([Alt([NamedItem(None, Group(Rhs([Alt([NamedItem(None, StringLeaf("'or'")), NamedItem('c', NameLeaf('conjunction_expr'))], action='c')])))])])))
                    _res = _tmp_12_var;
                    _children.push_back(_res);
                    _state = tell();
                    continue;
                }
                break;
            }
            seek(_state);
        }
        if (_n == 0) {
            return std::nullopt;
        }
        auto _seq = ast::make_sequence(std::move(_res));
        return _seq;
    }
    #else
    ;
    #endif

    // _loop1_4: ('and' inversion_expr)
    std::optional<ast::sequence<ast::expr>> parse__loop1_4_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        const auto _state = tell();
        (void)_state;
        std::optional<ast::sequence<ast::expr>> _res = std::nullopt;
        auto _state = tell();
        int _start_state = tell();
        std::vector<ast::sequence<ast::expr>> _children{};
        size_t _n = 0;
        { // ('and' inversion_expr)
            while (true) {
                auto _tmp_13_var = parse__tmp_13_rule();
                if (_tmp_13_var) {
                    // !!! DBG: BAD ACTION: Alt([NamedItem(None, Group(Rhs([Alt([NamedItem(None, StringLeaf("'and'")), NamedItem('c', NameLeaf('inversion_expr'))], action='c')])))]) (rule: Rule('_loop1_4', 'ast::sequence<ast::expr>', Rhs([Alt([NamedItem(None, Group(Rhs([Alt([NamedItem(None, StringLeaf("'and'")), NamedItem('c', NameLeaf('inversion_expr'))], action='c')])))])])))
                    _res = _tmp_13_var;
                    _children.push_back(_res);
                    _state = tell();
                    continue;
                }
                break;
            }
            seek(_state);
        }
        if (_n == 0) {
            return std::nullopt;
        }
        auto _seq = ast::make_sequence(std::move(_res));
        return _seq;
    }
    #else
    ;
    #endif

    // _loop1_5: comparison_followup_pair
    std::optional<std::vector<std::pair < ast::cmp_op , ast::expr >>> parse__loop1_5_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        const auto _state = tell();
        (void)_state;
        std::optional<std::vector<std::pair < ast::cmp_op , ast::expr >>> _res = std::nullopt;
        auto _state = tell();
        int _start_state = tell();
        std::vector<std::vector<std::pair < ast::cmp_op , ast::expr >>> _children{};
        size_t _n = 0;
        { // comparison_followup_pair
            while (true) {
                auto comparison_followup_pair_var = parse_comparison_followup_pair_rule();
                if (comparison_followup_pair_var) {
                    // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('comparison_followup_pair'))]) (rule: Rule('_loop1_5', 'std::vector<std::pair < ast::cmp_op , ast::expr >>', Rhs([Alt([NamedItem(None, NameLeaf('comparison_followup_pair'))])])))
                    _res = comparison_followup_pair_var;
                    _children.push_back(_res);
                    _state = tell();
                    continue;
                }
                break;
            }
            seek(_state);
        }
        if (_n == 0) {
            return std::nullopt;
        }
        auto _seq = ast::make_sequence(std::move(_res));
        return _seq;
    }
    #else
    ;
    #endif

    // _loop1_6: STRING
    std::optional<std::vector<lex::Token>> parse__loop1_6_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        const auto _state = tell();
        (void)_state;
        std::optional<std::vector<lex::Token>> _res = std::nullopt;
        auto _state = tell();
        int _start_state = tell();
        std::vector<std::vector<lex::Token>> _children{};
        size_t _n = 0;
        { // STRING
            while (true) {
                auto STRING_var = lexer.expect().token(TokenType::STRING);
                if (STRING_var) {
                    // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('STRING'))]) (rule: Rule('_loop1_6', 'std::vector<lex::Token>', Rhs([Alt([NamedItem(None, NameLeaf('STRING'))])])))
                    _res = STRING_var;
                    _children.push_back(_res);
                    _state = tell();
                    continue;
                }
                break;
            }
            seek(_state);
        }
        if (_n == 0) {
            return std::nullopt;
        }
        auto _seq = ast::make_sequence(std::move(_res));
        return _seq;
    }
    #else
    ;
    #endif

    // _loop0_8: ',' expr
    std::optional<std::vector<lex::Token>> parse__loop0_8_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        const auto _state = tell();
        (void)_state;
        std::optional<std::vector<lex::Token>> _res = std::nullopt;
        auto _state = tell();
        int _start_state = tell();
        std::vector<std::vector<lex::Token>> _children{};
        size_t _n = 0;
        { // ',' expr
            while (true) {
                auto _literal = lexer.expect().punct(lex::Punct::COMMA);
                if (_literal) {
                auto elem = parse_expr_rule();
                if (elem) {
                    _res = elem;
                    _children.push_back(_res);
                    _state = tell();
                    continue;
                }
                }
                break;
            }
            seek(_state);
        }
        auto _seq = ast::make_sequence(std::move(_res));
        return _seq;
    }
    #else
    ;
    #endif

    // _gather_7: expr _loop0_8
    std::optional<std::vector<lex::Token>> parse__gather_7_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<std::vector<lex::Token>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // expr _loop0_8
            auto elem = parse_expr_rule();
            if (elem) {
            auto seq = parse__loop0_8_rule();
            if (seq) {
                // !!! DBG: BAD ACTION: Alt([NamedItem('elem', NameLeaf('expr')), NamedItem('seq', NameLeaf('_loop0_8'))]) (rule: Rule('_gather_7', 'std::vector<lex::Token>', Rhs([Alt([NamedItem('elem', NameLeaf('expr')), NamedItem('seq', NameLeaf('_loop0_8'))])])))
                // !!! DBG: emit_default_action(gather) locals: ['elem', 'seq']
                _res.push_back(std::move(seq));
                return _res;
            }
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // _loop0_10: ',' expr
    std::optional<std::vector<lex::Token>> parse__loop0_10_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        const auto _state = tell();
        (void)_state;
        std::optional<std::vector<lex::Token>> _res = std::nullopt;
        auto _state = tell();
        int _start_state = tell();
        std::vector<std::vector<lex::Token>> _children{};
        size_t _n = 0;
        { // ',' expr
            while (true) {
                auto _literal = lexer.expect().punct(lex::Punct::COMMA);
                if (_literal) {
                auto elem = parse_expr_rule();
                if (elem) {
                    _res = elem;
                    _children.push_back(_res);
                    _state = tell();
                    continue;
                }
                }
                break;
            }
            seek(_state);
        }
        auto _seq = ast::make_sequence(std::move(_res));
        return _seq;
    }
    #else
    ;
    #endif

    // _gather_9: expr _loop0_10
    std::optional<std::vector<lex::Token>> parse__gather_9_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<std::vector<lex::Token>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // expr _loop0_10
            auto elem = parse_expr_rule();
            if (elem) {
            auto seq = parse__loop0_10_rule();
            if (seq) {
                // !!! DBG: BAD ACTION: Alt([NamedItem('elem', NameLeaf('expr')), NamedItem('seq', NameLeaf('_loop0_10'))]) (rule: Rule('_gather_9', 'std::vector<lex::Token>', Rhs([Alt([NamedItem('elem', NameLeaf('expr')), NamedItem('seq', NameLeaf('_loop0_10'))])])))
                // !!! DBG: emit_default_action(gather) locals: ['elem', 'seq']
                _res.push_back(std::move(seq));
                return _res;
            }
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // _loop0_11: stmt
    std::optional<ast::sequence<ast::stmt>> parse__loop0_11_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        const auto _state = tell();
        (void)_state;
        std::optional<ast::sequence<ast::stmt>> _res = std::nullopt;
        auto _state = tell();
        int _start_state = tell();
        std::vector<ast::sequence<ast::stmt>> _children{};
        size_t _n = 0;
        { // stmt
            while (true) {
                auto stmt_var = parse_stmt_rule();
                if (stmt_var) {
                    // !!! DBG: BAD ACTION: Alt([NamedItem(None, NameLeaf('stmt'))]) (rule: Rule('_loop0_11', 'ast::sequence<ast::stmt>', Rhs([Alt([NamedItem(None, NameLeaf('stmt'))])])))
                    _res = stmt_var;
                    _children.push_back(_res);
                    _state = tell();
                    continue;
                }
                break;
            }
            seek(_state);
        }
        auto _seq = ast::make_sequence(std::move(_res));
        return _seq;
    }
    #else
    ;
    #endif

    // _tmp_12: 'or' conjunction_expr
    std::optional<ast::field<ast::expr>> parse__tmp_12_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // 'or' conjunction_expr
            auto _keyword = lexer.expect().keyword(lex::HardKeyword::OR);
            if (_keyword) {
            auto c = parse_conjunction_expr_rule();
            if (c) {
                _res = c;
                return _res;
            }
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    // _tmp_13: 'and' inversion_expr
    std::optional<ast::field<ast::expr>> parse__tmp_13_rule()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::field<ast::expr>> _res = std::nullopt;
        const auto _state = tell();
        (void)_state;
        { // 'and' inversion_expr
            auto _keyword = lexer.expect().keyword(lex::HardKeyword::AND);
            if (_keyword) {
            auto c = parse_inversion_expr_rule();
            if (c) {
                _res = c;
                return _res;
            }
            }
            seek(_state);
        }
        return std::nullopt;
    }
    #else
    ;
    #endif

    #pragma endregion Rule parsers

};
#pragma endregion Parser


}  // namespace bondrewd::parse
