// AUTOGENERATED by bondrewd/tools/pegen++/pegenxx.py on 2023-04-03 10:36:45
// DO NOT EDIT

#pragma once

#include <bondrewd/internal/common.hpp>
#include <bondrewd/parse/parser_base.hpp>
#include <bondrewd/ast/ast_nodes.gen.hpp>
#include <bondrewd/lex/src_location.hpp>

#include <map>
#include <vector>
#include <optional>
#include <algorithm>
#include <fmt/format.h>


#pragma region Subheader
#include <string>


#pragma endregion Subheader


namespace bondrewd::parse {


#pragma region Parser
class Parser : public ParserBase<Parser> {
public:
    #pragma region Constructors
    Parser(lex::Lexer lexer_) : ParserBase(std::move(lexer_)) {}
    #pragma endregion Constructors

    #pragma region Service constructors
    Parser(const Parser &) = delete;
    Parser(Parser &&) = default;
    Parser &operator=(const Parser &) = delete;
    Parser &operator=(Parser &&) = default;
    #pragma endregion Service constructors

    #pragma region API
    auto parse() {
        auto result = parse_start_rule();

        if (!result) {
            auto &scanner = lexer.get_scanner();

            lex::SrcLocation err_loc = scanner.tell();

            throw SyntaxError(fmt::format("Syntax error at {} (`{}`)", err_loc.to_string(), scanner.view_context(err_loc, 5)));
        }

        return *result;
    }
    #pragma endregion API

protected:
    #pragma region Constants and typedefs
    using state_t = lex::Lexer::state_t;

    static constexpr unsigned MAX_RECURSION_LEVEL = 6000;
    #pragma endregion Constants and typedefs

    #pragma region Fields
    unsigned _level = 0;

    // Cache-related fields in a following region
    #pragma endregion Fields

    #pragma region Rule types
    enum class RuleType: unsigned {
        _gather_10,
        _gather_12,
        _loop0_1,
        _loop0_11,
        _loop0_13,
        _loop0_14,
        _loop1_6,
        _loop1_7,
        _loop1_8,
        _loop1_9,
        _tmp_15,
        _tmp_16,
        _tmp_2,
        _tmp_3,
        _tmp_4,
        _tmp_5,
        array_expr,
        assign_op,
        assign_stmt,
        atom_expr,
        bidir_cmp_expr,
        bitand_expr,  // Left-recursive
        bitor_expr,  // Left-recursive
        bitxor_expr,  // Left-recursive
        block_expr,
        break_expr,
        call_args,
        cartridge,
        cartridge_header,
        comparison_expr,
        comparison_followup_pair,
        comparison_op,
        conjunction_expr,
        continue_expr,
        defn,
        defn_expr,
        disjunction_expr,
        expr,
        expr_or_unit,
        expr_stmt,
        factor_expr,
        flow,
        flow_block,
        flow_expr,
        for_flow,
        func_args_def,
        func_def,
        group_expr,
        if_flow,
        inversion_expr,
        loop_flow,
        name,
        power_expr,
        primary_expr,  // Left-recursive
        raw_defn,
        raw_flow,
        return_expr,
        shift_expr,  // Left-recursive
        start,
        stmt,
        strings,
        sum_expr,  // Left-recursive
        term_expr,  // Left-recursive
        tuple_expr,
        type_annotation,
        var_def,
        while_flow,
    };

    template <RuleType R>
    using rule_raw_result_t = std::tuple_element_t<
        (unsigned)R,
        std::tuple<
            ast::sequence<ast::expr>,
            ast::sequence<ast::expr>,
            ast::sequence<ast::stmt>,
            ast::sequence<ast::expr>,
            ast::sequence<ast::expr>,
            ast::sequence<ast::stmt>,
            ast::sequence<ast::expr>,
            ast::sequence<ast::expr>,
            std::vector<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>>,
            std::vector<lex::Token>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::assign_op>,
            ast::field<ast::stmt>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::call_args>,
            ast::field<ast::cartridge>,
            std::string,
            ast::field<ast::expr>,
            std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>,
            ast::field<ast::cmp_op>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::defn>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::stmt>,
            ast::field<ast::expr>,
            ast::field<ast::flow>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::flow>,
            ast::field<ast::arg_defs>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::flow>,
            ast::field<ast::expr>,
            ast::field<ast::flow>,
            std::string,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::defn>,
            ast::field<ast::flow>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::cartridge>,
            ast::field<ast::stmt>,
            std::string,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::stmt>,
            ast::field<ast::flow>
        >
    >;

    template <RuleType R>
    using rule_result_t = std::optional<rule_raw_result_t<R>>;
    #pragma endregion Rule types

    #pragma region Helpers
    bool lookahead(bool positive, auto rule_func) {
        auto guard = lexer.lookahead(positive);

        // TODO: Pass this?
        return positive == (bool)rule_func();
    }

    template <typename U>
    U forced(U result) {
        if (!result) {
            // TODO: More info?
            fatal_error("Forced rule failed");
        }

        return std::move(result);
    }

    state_t tell() {
        return lexer.tell();
    }

    void seek(state_t state) {
        lexer.seek(state);
    }
    #pragma endregion Helpers

    #pragma region Extras
    std::string _concat_strings(const std::vector<lex::Token> &strings) const {
        if (strings.empty()) {
            return "";
        }

        std::string result{};
        std::string_view quotes = "";
        bool first = true;

        for (auto &s: strings) {
            if (first) {
                quotes = s.get_string().quotes;
                first = false;
            }

            result += s.get_string().value;
            if (s.get_string().quotes != quotes) {
                // TODO: Custom error type!
                throw std::runtime_error("String literals must have the same quotes");
            }
        }

        return result;
    }

    template <typename T>
    ast::maybe<T> _opt2maybe(std::optional<ast::field<T>> opt) {
        if (opt) {
            return std::move(*opt);
        } else {
            return nullptr;
        }
    }


    #pragma endregion Extras

    #pragma region Caching
    #pragma region CacheNode
    template <RuleType rule_type>
    class CacheNode {
    public:
        rule_result_t<rule_type> value;
        state_t end_state;

        CacheNode(rule_result_t<rule_type> value, state_t end_state)
            : value{std::move(value)}, end_state{std::move(end_state)} {}
        
        CacheNode(const CacheNode &) = delete;
        CacheNode(CacheNode &&) = default;
        CacheNode &operator=(const CacheNode &) = delete;
        CacheNode &operator=(CacheNode &&) = default;

    };
    #pragma endregion CacheNode

    #pragma region Fields
    std::map<state_t, CacheNode<RuleType::bitand_expr>> cache_bitand_expr{};
    std::map<state_t, CacheNode<RuleType::bitor_expr>> cache_bitor_expr{};
    std::map<state_t, CacheNode<RuleType::bitxor_expr>> cache_bitxor_expr{};
    std::map<state_t, CacheNode<RuleType::block_expr>> cache_block_expr{};
    std::map<state_t, CacheNode<RuleType::call_args>> cache_call_args{};
    std::map<state_t, CacheNode<RuleType::conjunction_expr>> cache_conjunction_expr{};
    std::map<state_t, CacheNode<RuleType::defn>> cache_defn{};
    std::map<state_t, CacheNode<RuleType::disjunction_expr>> cache_disjunction_expr{};
    std::map<state_t, CacheNode<RuleType::expr>> cache_expr{};
    std::map<state_t, CacheNode<RuleType::factor_expr>> cache_factor_expr{};
    std::map<state_t, CacheNode<RuleType::flow>> cache_flow{};
    std::map<state_t, CacheNode<RuleType::inversion_expr>> cache_inversion_expr{};
    std::map<state_t, CacheNode<RuleType::primary_expr>> cache_primary_expr{};
    std::map<state_t, CacheNode<RuleType::shift_expr>> cache_shift_expr{};
    std::map<state_t, CacheNode<RuleType::stmt>> cache_stmt{};
    std::map<state_t, CacheNode<RuleType::strings>> cache_strings{};
    std::map<state_t, CacheNode<RuleType::sum_expr>> cache_sum_expr{};
    std::map<state_t, CacheNode<RuleType::term_expr>> cache_term_expr{};
    
    #pragma endregion Fields

    template <RuleType rule_type>
    constexpr std::map<state_t, CacheNode<rule_type>> &_get_cache() {
        if constexpr (rule_type == RuleType::bitand_expr) {
            return cache_bitand_expr;
        } else 
        if constexpr (rule_type == RuleType::bitor_expr) {
            return cache_bitor_expr;
        } else 
        if constexpr (rule_type == RuleType::bitxor_expr) {
            return cache_bitxor_expr;
        } else 
        if constexpr (rule_type == RuleType::block_expr) {
            return cache_block_expr;
        } else 
        if constexpr (rule_type == RuleType::call_args) {
            return cache_call_args;
        } else 
        if constexpr (rule_type == RuleType::conjunction_expr) {
            return cache_conjunction_expr;
        } else 
        if constexpr (rule_type == RuleType::defn) {
            return cache_defn;
        } else 
        if constexpr (rule_type == RuleType::disjunction_expr) {
            return cache_disjunction_expr;
        } else 
        if constexpr (rule_type == RuleType::expr) {
            return cache_expr;
        } else 
        if constexpr (rule_type == RuleType::factor_expr) {
            return cache_factor_expr;
        } else 
        if constexpr (rule_type == RuleType::flow) {
            return cache_flow;
        } else 
        if constexpr (rule_type == RuleType::inversion_expr) {
            return cache_inversion_expr;
        } else 
        if constexpr (rule_type == RuleType::primary_expr) {
            return cache_primary_expr;
        } else 
        if constexpr (rule_type == RuleType::shift_expr) {
            return cache_shift_expr;
        } else 
        if constexpr (rule_type == RuleType::stmt) {
            return cache_stmt;
        } else 
        if constexpr (rule_type == RuleType::strings) {
            return cache_strings;
        } else 
        if constexpr (rule_type == RuleType::sum_expr) {
            return cache_sum_expr;
        } else 
        if constexpr (rule_type == RuleType::term_expr) {
            return cache_term_expr;
        } else  {
            // Hack to bypass msvc's static_assert in templates optimization
            // (it was triggered despite being within a non-instantiated template function...)
            static_assert(false && rule_type == rule_type, "Uncachable rule type");
        }
    }

    template <RuleType rule_type>
    std::optional<rule_result_t<rule_type>> get_cached(state_t state) {
        auto &cache = _get_cache<rule_type>();

        auto it = cache.find(state);

        if (it == cache.end()) {
            return std::nullopt;
        }

        seek(it->second.end_state);

        return it->second.value;
    }

    /// Updates, if present
    template <RuleType rule_type>
    void store_cached(state_t state, rule_result_t<rule_type> result) {
        auto &cache = _get_cache<rule_type>();

        cache.insert_or_assign(state, CacheNode<rule_type>(std::move(result), tell()));
    }
    #pragma endregion Caching

    #pragma region Rule parsers
    
    // start: cartridge
    std::optional<ast::field<ast::cartridge>> parse_start_rule();

    // cartridge: cartridge_header stmt* $
    std::optional<ast::field<ast::cartridge>> parse_cartridge_rule();

    // cartridge_header: 'cartridge' name ';'
    std::optional<std::string> parse_cartridge_header_rule();

    // stmt: assign_stmt | expr_stmt | ';'
    std::optional<ast::field<ast::stmt>> parse_stmt_rule();

    // assign_stmt: expr assign_op expr ';'
    std::optional<ast::field<ast::stmt>> parse_assign_stmt_rule();

    // assign_op: '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '|=' | '^='
    std::optional<ast::field<ast::assign_op>> parse_assign_op_rule();

    // defn_expr: defn
    std::optional<ast::field<ast::expr>> parse_defn_expr_rule();

    // defn: 'ctime' raw_defn | 'rtime' raw_defn | raw_defn
    std::optional<ast::field<ast::defn>> parse_defn_rule();

    // raw_defn: var_def | func_def
    std::optional<ast::field<ast::defn>> parse_raw_defn_rule();

    // type_annotation: ':' expr
    std::optional<ast::field<ast::expr>> parse_type_annotation_rule();

    // var_def: 'var' name type_annotation? ['=' expr] ';'
    std::optional<ast::field<ast::stmt>> parse_var_def_rule();

    // func_def: 'func' name '(' func_args_def ')' type_annotation? '=>' expr
    std::optional<ast::field<ast::expr>> parse_func_def_rule();

    // func_args_def: 
    std::optional<ast::field<ast::arg_defs>> parse_func_args_def_rule();

    // flow_expr: flow
    std::optional<ast::field<ast::expr>> parse_flow_expr_rule();

    // flow: 'ctime' raw_flow | 'rtime' raw_flow | raw_flow
    std::optional<ast::field<ast::flow>> parse_flow_rule();

    // raw_flow: if_flow | for_flow | while_flow | loop_flow
    std::optional<ast::field<ast::flow>> parse_raw_flow_rule();

    // if_flow: 'if' expr flow_block [('else' flow_block)]
    std::optional<ast::field<ast::flow>> parse_if_flow_rule();

    // for_flow: 'for' name 'in' expr flow_block [('else' flow_block)]
    std::optional<ast::field<ast::flow>> parse_for_flow_rule();

    // while_flow: 'while' expr flow_block [('else' flow_block)]
    std::optional<ast::field<ast::flow>> parse_while_flow_rule();

    // loop_flow: 'loop' flow_block
    std::optional<ast::field<ast::flow>> parse_loop_flow_rule();

    // flow_block: block_expr | flow_expr | return_expr | break_expr | continue_expr
    std::optional<ast::field<ast::expr>> parse_flow_block_rule();

    // expr_stmt: expr ';'
    std::optional<ast::field<ast::stmt>> parse_expr_stmt_rule();

    // expr:
    //     | defn_expr
    //     | flow_expr
    //     | return_expr
    //     | break_expr
    //     | continue_expr
    //     | disjunction_expr
    std::optional<ast::field<ast::expr>> parse_expr_rule();

    // expr_or_unit: expr | 
    std::optional<ast::field<ast::expr>> parse_expr_or_unit_rule();

    // return_expr: 'return' expr_or_unit
    std::optional<ast::field<ast::expr>> parse_return_expr_rule();

    // break_expr: 'break' expr_or_unit
    std::optional<ast::field<ast::expr>> parse_break_expr_rule();

    // continue_expr: 'continue'
    std::optional<ast::field<ast::expr>> parse_continue_expr_rule();

    // disjunction_expr: conjunction_expr (('or' conjunction_expr))+ | conjunction_expr
    std::optional<ast::field<ast::expr>> parse_disjunction_expr_rule();

    // conjunction_expr: inversion_expr (('and' inversion_expr))+ | inversion_expr
    std::optional<ast::field<ast::expr>> parse_conjunction_expr_rule();

    // inversion_expr: 'not' inversion_expr | comparison_expr
    std::optional<ast::field<ast::expr>> parse_inversion_expr_rule();

    // comparison_expr: bidir_cmp_expr comparison_followup_pair+ | bidir_cmp_expr
    std::optional<ast::field<ast::expr>> parse_comparison_expr_rule();

    // comparison_followup_pair: comparison_op bidir_cmp_expr
    std::optional<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>> parse_comparison_followup_pair_rule();

    // comparison_op: '==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in'
    std::optional<ast::field<ast::cmp_op>> parse_comparison_op_rule();

    // bidir_cmp_expr: bitor_expr '<=>' bitor_expr | bitor_expr
    std::optional<ast::field<ast::expr>> parse_bidir_cmp_expr_rule();

    // Left-recursive
    // bitor_expr: bitor_expr '|' bitxor_expr | bitxor_expr
    std::optional<ast::field<ast::expr>> parse_bitor_expr_rule();
    std::optional<ast::field<ast::expr>> parse_raw_bitor_expr();

    // Left-recursive
    // bitxor_expr: bitxor_expr '^' bitand_expr | bitand_expr
    std::optional<ast::field<ast::expr>> parse_bitxor_expr_rule();
    std::optional<ast::field<ast::expr>> parse_raw_bitxor_expr();

    // Left-recursive
    // bitand_expr: bitand_expr '&' shift_expr | shift_expr
    std::optional<ast::field<ast::expr>> parse_bitand_expr_rule();
    std::optional<ast::field<ast::expr>> parse_raw_bitand_expr();

    // Left-recursive
    // shift_expr: shift_expr '<<' sum_expr | shift_expr '>>' sum_expr | sum_expr
    std::optional<ast::field<ast::expr>> parse_shift_expr_rule();
    std::optional<ast::field<ast::expr>> parse_raw_shift_expr();

    // Left-recursive
    // sum_expr: sum_expr '+' term_expr | sum_expr '-' term_expr | term_expr
    std::optional<ast::field<ast::expr>> parse_sum_expr_rule();
    std::optional<ast::field<ast::expr>> parse_raw_sum_expr();

    // Left-recursive
    // term_expr:
    //     | term_expr '*' factor_expr
    //     | term_expr '/' factor_expr
    //     | term_expr '%' factor_expr
    //     | factor_expr
    std::optional<ast::field<ast::expr>> parse_term_expr_rule();
    std::optional<ast::field<ast::expr>> parse_raw_term_expr();

    // factor_expr:
    //     | '+' factor_expr
    //     | '-' factor_expr
    //     | '~' factor_expr
    //     | '&' factor_expr
    //     | '*' factor_expr
    //     | power_expr
    std::optional<ast::field<ast::expr>> parse_factor_expr_rule();

    // power_expr: primary_expr '**' factor_expr | primary_expr
    std::optional<ast::field<ast::expr>> parse_power_expr_rule();

    // Left-recursive
    // primary_expr:
    //     | primary_expr '.' name
    //     | primary_expr '::' name
    //     | primary_expr '[' call_args ']'
    //     | primary_expr '(' call_args ')'
    //     | atom_expr
    std::optional<ast::field<ast::expr>> parse_primary_expr_rule();
    std::optional<ast::field<ast::expr>> parse_raw_primary_expr();

    // atom_expr:
    //     | name
    //     | NUMBER
    //     | &STRING strings
    //     | '...'
    //     | group_expr
    //     | tuple_expr
    //     | array_expr
    //     | block_expr
    std::optional<ast::field<ast::expr>> parse_atom_expr_rule();

    // call_args: 
    std::optional<ast::field<ast::call_args>> parse_call_args_rule();

    // name: NAME
    std::optional<std::string> parse_name_rule();

    // strings: STRING+
    std::optional<std::string> parse_strings_rule();

    // group_expr: '(' expr ')'
    std::optional<ast::field<ast::expr>> parse_group_expr_rule();

    // tuple_expr: '(' ')' | '(' ','.expr+ ','? ')'
    std::optional<ast::field<ast::expr>> parse_tuple_expr_rule();

    // array_expr: '[' ']' | '[' ','.expr+ ','? ']'
    std::optional<ast::field<ast::expr>> parse_array_expr_rule();

    // block_expr: 'ctime'? '{' stmt* expr_or_unit '}'
    std::optional<ast::field<ast::expr>> parse_block_expr_rule();

    // _loop0_1: stmt
    std::optional<ast::sequence<ast::stmt>> parse__loop0_1_rule();

    // _tmp_2: '=' expr
    std::optional<ast::field<ast::expr>> parse__tmp_2_rule();

    // _tmp_3: 'else' flow_block
    std::optional<ast::field<ast::expr>> parse__tmp_3_rule();

    // _tmp_4: 'else' flow_block
    std::optional<ast::field<ast::expr>> parse__tmp_4_rule();

    // _tmp_5: 'else' flow_block
    std::optional<ast::field<ast::expr>> parse__tmp_5_rule();

    // _loop1_6: ('or' conjunction_expr)
    std::optional<ast::sequence<ast::expr>> parse__loop1_6_rule();

    // _loop1_7: ('and' inversion_expr)
    std::optional<ast::sequence<ast::expr>> parse__loop1_7_rule();

    // _loop1_8: comparison_followup_pair
    std::optional<std::vector<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>>> parse__loop1_8_rule();

    // _loop1_9: STRING
    std::optional<std::vector<lex::Token>> parse__loop1_9_rule();

    // _loop0_11: ',' expr
    std::optional<ast::sequence<ast::expr>> parse__loop0_11_rule();

    // _gather_10: expr _loop0_11
    std::optional<ast::sequence<ast::expr>> parse__gather_10_rule();

    // _loop0_13: ',' expr
    std::optional<ast::sequence<ast::expr>> parse__loop0_13_rule();

    // _gather_12: expr _loop0_13
    std::optional<ast::sequence<ast::expr>> parse__gather_12_rule();

    // _loop0_14: stmt
    std::optional<ast::sequence<ast::stmt>> parse__loop0_14_rule();

    // _tmp_15: 'or' conjunction_expr
    std::optional<ast::field<ast::expr>> parse__tmp_15_rule();

    // _tmp_16: 'and' inversion_expr
    std::optional<ast::field<ast::expr>> parse__tmp_16_rule();

    #pragma endregion Rule parsers

};
#pragma endregion Parser


}  // namespace bondrewd::parse
