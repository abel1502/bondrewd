// AUTOGENERATED by bondrewd/tools/pegen++/pegenxx.py on 2023-03-15 07:47:38
// DO NOT EDIT

#pragma once

#include <bondrewd/internal/common.hpp>
#include <bondrewd/parse/parser_base.hpp>
#include <bondrewd/ast/ast_nodes.gen.hpp>

#include <map>
#include <vector>
#include <optional>
#include <algorithm>


#pragma region Subheader
#include <string>


#pragma endregion Subheader


namespace bondrewd::parse {


#pragma region Parser
class Parser : public ParserBase<Parser> {
public:
    #pragma region Constructors
    Parser(lex::Lexer lexer_) : ParserBase(std::move(lexer_)) {}
    #pragma endregion Constructors

    #pragma region Service constructors
    Parser(const Parser &) = delete;
    Parser(Parser &&) = default;
    Parser &operator=(const Parser &) = delete;
    Parser &operator=(Parser &&) = default;
    #pragma endregion Service constructors

    #pragma region API
    auto parse() {
        return parse_start_rule();
    }

    #pragma endregion API

protected:
    #pragma region Constants and typedefs
    using state_t = lex::Lexer::state_t;
    #pragma endregion Constants and typedefs

    #pragma region Fields
    std::map<state_t, std::optional<ast::field<ast::expr>>> cache_bitand_expr{};
    std::map<state_t, std::optional<ast::field<ast::expr>>> cache_bitor_expr{};
    std::map<state_t, std::optional<ast::field<ast::expr>>> cache_bitxor_expr{};
    std::map<state_t, std::optional<ast::field<ast::expr>>> cache_primary_expr{};
    std::map<state_t, std::optional<ast::field<ast::expr>>> cache_shift_expr{};
    std::map<state_t, std::optional<ast::field<ast::expr>>> cache_sum_expr{};
    std::map<state_t, std::optional<ast::field<ast::expr>>> cache_term_expr{};
    #pragma endregion Fields

    #pragma region Rule types
    enum class RuleType: unsigned {
        _gather_7,
        _gather_9,
        _loop0_1,
        _loop0_10,
        _loop0_11,
        _loop0_8,
        _loop1_3,
        _loop1_4,
        _loop1_5,
        _loop1_6,
        _tmp_12,
        _tmp_13,
        _tmp_2,
        array_expr,
        assign_op,
        assign_stmt,
        atom_expr,
        bidir_cmp_expr,
        bitand_expr,  // Left-recursive
        bitor_expr,  // Left-recursive
        bitxor_expr,  // Left-recursive
        block_expr,
        call_args,
        cartridge,
        cartridge_header,
        comparison_expr,
        comparison_followup_pair,
        comparison_op,
        conjunction_expr,
        disjunction_expr,
        expr,
        expr_or_unit,
        expr_stmt,
        factor_expr,
        func_args_def,
        func_def,
        group_expr,
        impl_stmt,
        inversion_expr,
        name,
        power_expr,
        primary_expr,  // Left-recursive
        shift_expr,  // Left-recursive
        start,
        stmt,
        strings,
        sum_expr,  // Left-recursive
        term_expr,  // Left-recursive
        tuple_expr,
        type_annotation,
        var_def_stmt,
    };

    template <RuleType R>
    using rule_raw_result_t = std::tuple_element_t<
        (unsigned)R,
        std::tuple<
            ast::sequence<ast::expr>,
            ast::sequence<ast::expr>,
            ast::sequence<ast::stmt>,
            ast::sequence<ast::expr>,
            ast::sequence<ast::stmt>,
            ast::sequence<ast::expr>,
            ast::sequence<ast::expr>,
            ast::sequence<ast::expr>,
            std::vector<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>>,
            std::vector<lex::Token>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::assign_op>,
            ast::field<ast::stmt>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::call_args>,
            ast::field<ast::cartridge>,
            std::string,
            ast::field<ast::expr>,
            std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>,
            ast::field<ast::cmp_op>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::stmt>,
            ast::field<ast::expr>,
            ast::field<ast::arg_defs>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::stmt>,
            ast::field<ast::expr>,
            std::string,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::cartridge>,
            ast::field<ast::stmt>,
            std::string,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::expr>,
            ast::field<ast::stmt>
        >
    >;

    template <RuleType R>
    using rule_result_t = std::optional<rule_raw_result_t<R>>;
    #pragma endregion Rule types

    #pragma region Helpers
    bool lookahead(bool positive, auto rule_func) {
        auto guard = lexer.lookahead(positive);

        // TODO: Pass this?
        return positive == (bool)rule_func();
    }

    template <typename U>
    U forced(U result) {
        if (!result) {
            // TODO: More info?
            fatal_error("Forced rule failed");
        }

        return std::move(result);
    }

    state_t tell() {
        return lexer.tell();
    }

    void seek(state_t state) {
        lexer.seek(state);
    }
    #pragma endregion Helpers

    #pragma region Extras
    std::string _concat_strings(const std::vector<lex::Token> &strings) const {
        if (strings.empty()) {
            return "";
        }

        std::string result{};
        std::string_view quotes = "";
        bool first = true;

        for (auto &s: strings) {
            if (first) {
                quotes = s.get_string().quotes;
                first = false;
            }

            result += s.get_string().value;
            if (s.get_string().quotes != quotes) {
                // TODO: Custom error type!
                throw std::runtime_error("String literals must have the same quotes");
            }
        }

        return result;
    }

    template <typename T>
    ast::maybe<T> _opt2maybe(std::optional<ast::field<T>> opt) {
        if (opt) {
            return std::move(*opt);
        } else {
            return nullptr;
        }
    }


    #pragma endregion Extras

    #pragma region Caching
    template <RuleType rule_type>
    constexpr std::map<state_t, rule_result_t<rule_type>> &_get_cache() {
        if constexpr (rule_type == RuleType::bitand_expr) {
            return cache_bitand_expr;
        } else 
        if constexpr (rule_type == RuleType::bitor_expr) {
            return cache_bitor_expr;
        } else 
        if constexpr (rule_type == RuleType::bitxor_expr) {
            return cache_bitxor_expr;
        } else 
        if constexpr (rule_type == RuleType::primary_expr) {
            return cache_primary_expr;
        } else 
        if constexpr (rule_type == RuleType::shift_expr) {
            return cache_shift_expr;
        } else 
        if constexpr (rule_type == RuleType::sum_expr) {
            return cache_sum_expr;
        } else 
        if constexpr (rule_type == RuleType::term_expr) {
            return cache_term_expr;
        } else  {
            // Hack to bypass msvc's static_assert in templates optimization
            // (it was triggered despite being within a non-instantiated template function...)
            static_assert(false && rule_type == rule_type, "Uncachable rule type");
        }
    }

    template <RuleType rule_type>
    rule_result_t<rule_type> get_cached(state_t state) {
        auto &cache = _get_cache<rule_type>();

        auto it = cache.find(state);

        if (it == cache.end()) {
            return std::nullopt;
        }

        return it->second;
    }

    /// Updates, if present
    template <RuleType rule_type>
    void store_cached(state_t state, rule_result_t<rule_type> result) {
        auto &cache = _get_cache<rule_type>();

        cache.emplace(state, std::move(result));
    }
    #pragma endregion Caching

    #pragma region Rule parsers
    
    // start: cartridge
    std::optional<ast::field<ast::cartridge>> parse_start_rule();

    // cartridge: cartridge_header stmt*
    std::optional<ast::field<ast::cartridge>> parse_cartridge_rule();

    // cartridge_header: 'cartridge' name ';'
    std::optional<std::string> parse_cartridge_header_rule();

    // stmt: var_def_stmt | impl_stmt | assign_stmt | expr_stmt | ';'
    std::optional<ast::field<ast::stmt>> parse_stmt_rule();

    // assign_stmt: expr assign_op expr ';'
    std::optional<ast::field<ast::stmt>> parse_assign_stmt_rule();

    // assign_op: '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '|=' | '^='
    std::optional<ast::field<ast::assign_op>> parse_assign_op_rule();

    // var_def_stmt: 'ctime'? 'var' name type_annotation? ['=' expr] ';'
    std::optional<ast::field<ast::stmt>> parse_var_def_stmt_rule();

    // impl_stmt: 
    std::optional<ast::field<ast::stmt>> parse_impl_stmt_rule();

    // expr_stmt: expr ';'
    std::optional<ast::field<ast::stmt>> parse_expr_stmt_rule();

    // expr:
    //     | func_def
    //     | block_expr
    //     | 'return' expr_or_unit
    //     | 'break' expr_or_unit
    //     | disjunction_expr
    std::optional<ast::field<ast::expr>> parse_expr_rule();

    // expr_or_unit: expr | 
    std::optional<ast::field<ast::expr>> parse_expr_or_unit_rule();

    // disjunction_expr: conjunction_expr (('or' conjunction_expr))+ | conjunction_expr
    std::optional<ast::field<ast::expr>> parse_disjunction_expr_rule();

    // conjunction_expr: inversion_expr (('and' inversion_expr))+ | inversion_expr
    std::optional<ast::field<ast::expr>> parse_conjunction_expr_rule();

    // inversion_expr: 'not' inversion_expr | comparison_expr
    std::optional<ast::field<ast::expr>> parse_inversion_expr_rule();

    // comparison_expr: bidir_cmp_expr comparison_followup_pair+ | bidir_cmp_expr
    std::optional<ast::field<ast::expr>> parse_comparison_expr_rule();

    // comparison_followup_pair: comparison_op bidir_cmp_expr
    std::optional<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>> parse_comparison_followup_pair_rule();

    // comparison_op: '==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in'
    std::optional<ast::field<ast::cmp_op>> parse_comparison_op_rule();

    // bidir_cmp_expr: bitor_expr '<=>' bitor_expr | bitor_expr
    std::optional<ast::field<ast::expr>> parse_bidir_cmp_expr_rule();

    // Left-recursive
    // bitor_expr: bitor_expr '|' bitxor_expr | bitxor_expr
    std::optional<ast::field<ast::expr>> parse_bitor_expr_rule();
    std::optional<ast::field<ast::expr>> parse_raw_bitor_expr();

    // Left-recursive
    // bitxor_expr: bitxor_expr '^' bitand_expr | bitand_expr
    std::optional<ast::field<ast::expr>> parse_bitxor_expr_rule();
    std::optional<ast::field<ast::expr>> parse_raw_bitxor_expr();

    // Left-recursive
    // bitand_expr: bitand_expr '&' shift_expr | shift_expr
    std::optional<ast::field<ast::expr>> parse_bitand_expr_rule();
    std::optional<ast::field<ast::expr>> parse_raw_bitand_expr();

    // Left-recursive
    // shift_expr: shift_expr '<<' sum_expr | shift_expr '>>' sum_expr | sum_expr
    std::optional<ast::field<ast::expr>> parse_shift_expr_rule();
    std::optional<ast::field<ast::expr>> parse_raw_shift_expr();

    // Left-recursive
    // sum_expr: sum_expr '+' term_expr | sum_expr '-' term_expr | term_expr
    std::optional<ast::field<ast::expr>> parse_sum_expr_rule();
    std::optional<ast::field<ast::expr>> parse_raw_sum_expr();

    // Left-recursive
    // term_expr:
    //     | term_expr '*' factor_expr
    //     | term_expr '/' factor_expr
    //     | term_expr '%' factor_expr
    //     | factor_expr
    std::optional<ast::field<ast::expr>> parse_term_expr_rule();
    std::optional<ast::field<ast::expr>> parse_raw_term_expr();

    // factor_expr: '+' factor_expr | '-' factor_expr | '~' factor_expr | power_expr
    std::optional<ast::field<ast::expr>> parse_factor_expr_rule();

    // power_expr: primary_expr '**' factor_expr | primary_expr
    std::optional<ast::field<ast::expr>> parse_power_expr_rule();

    // Left-recursive
    // primary_expr:
    //     | primary_expr '.' name
    //     | primary_expr '::' name
    //     | primary_expr '[' call_args ']'
    //     | primary_expr '(' call_args ')'
    //     | atom_expr
    std::optional<ast::field<ast::expr>> parse_primary_expr_rule();
    std::optional<ast::field<ast::expr>> parse_raw_primary_expr();

    // atom_expr:
    //     | name
    //     | NUMBER
    //     | &STRING strings
    //     | group_expr
    //     | tuple_expr
    //     | array_expr
    //     | block_expr
    std::optional<ast::field<ast::expr>> parse_atom_expr_rule();

    // call_args: 
    std::optional<ast::field<ast::call_args>> parse_call_args_rule();

    // name: NAME
    std::optional<std::string> parse_name_rule();

    // strings: STRING+
    std::optional<std::string> parse_strings_rule();

    // group_expr: '(' expr ')'
    std::optional<ast::field<ast::expr>> parse_group_expr_rule();

    // tuple_expr: '(' ')' | '(' ','.expr+ ','? ')'
    std::optional<ast::field<ast::expr>> parse_tuple_expr_rule();

    // array_expr: '[' ']' | '[' ','.expr+ ','? ']'
    std::optional<ast::field<ast::expr>> parse_array_expr_rule();

    // block_expr: 'ctime'? '{' stmt* expr_or_unit '}'
    std::optional<ast::field<ast::expr>> parse_block_expr_rule();

    // type_annotation: ':' expr
    std::optional<ast::field<ast::expr>> parse_type_annotation_rule();

    // func_def: 'func' name '(' func_args_def ')' type_annotation? '=>' expr ';'
    std::optional<ast::field<ast::expr>> parse_func_def_rule();

    // func_args_def: 
    std::optional<ast::field<ast::arg_defs>> parse_func_args_def_rule();

    // _loop0_1: stmt
    std::optional<ast::sequence<ast::stmt>> parse__loop0_1_rule();

    // _tmp_2: '=' expr
    std::optional<ast::field<ast::expr>> parse__tmp_2_rule();

    // _loop1_3: ('or' conjunction_expr)
    std::optional<ast::sequence<ast::expr>> parse__loop1_3_rule();

    // _loop1_4: ('and' inversion_expr)
    std::optional<ast::sequence<ast::expr>> parse__loop1_4_rule();

    // _loop1_5: comparison_followup_pair
    std::optional<std::vector<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>>> parse__loop1_5_rule();

    // _loop1_6: STRING
    std::optional<std::vector<lex::Token>> parse__loop1_6_rule();

    // _loop0_8: ',' expr
    std::optional<ast::sequence<ast::expr>> parse__loop0_8_rule();

    // _gather_7: expr _loop0_8
    std::optional<ast::sequence<ast::expr>> parse__gather_7_rule();

    // _loop0_10: ',' expr
    std::optional<ast::sequence<ast::expr>> parse__loop0_10_rule();

    // _gather_9: expr _loop0_10
    std::optional<ast::sequence<ast::expr>> parse__gather_9_rule();

    // _loop0_11: stmt
    std::optional<ast::sequence<ast::stmt>> parse__loop0_11_rule();

    // _tmp_12: 'or' conjunction_expr
    std::optional<ast::field<ast::expr>> parse__tmp_12_rule();

    // _tmp_13: 'and' inversion_expr
    std::optional<ast::field<ast::expr>> parse__tmp_13_rule();

    #pragma endregion Rule parsers

};
#pragma endregion Parser


}  // namespace bondrewd::parse
