// AUTOGENERATED by bondrewd/tools/pegen++/pegenxx.py on 2023-03-11 12:04:23
// DO NOT EDIT

#pragma once

#include <bondrewd/internal/common.hpp>
#include <bondrewd/parse/parser_base.hpp>
#include <bondrewd/ast/ast_nodes.gen.hpp>

#include <map>
#include <optional>


#pragma region Subheader
#include <algorithm>
#include <string>


#pragma endregion Subheader


namespace bondrewd::parse {


#pragma region Parser
class Parser : public ParserBase<Parser> {
public:
    #pragma region Constructors
    Parser(lex::Lexer lexer) : ParserBase(std::move(lexer)) {}
    #pragma endregion Constructors

    #pragma region Service constructors
    Parser(const Parser &) = delete;
    Parser(Parser &&) = default;
    Parser &operator=(const Parser &) = delete;
    Parser &operator=(Parser &&) = default;
    #pragma endregion Service constructors

    #pragma region API
    auto parse() {
        return parse_start();
    }

    #pragma endregion API

protected:
    #pragma region Constants and typedefs
    using state_t = lex::Lexer::state_t;
    #pragma endregion Constants and typedefs

    #pragma region Fields
    #pragma endregion Fields

    #pragma region Rule types
    enum class RuleType: unsigned {
        _gather_7,
        _gather_9,
        _loop0_1,
        _loop0_10,
        _loop0_11,
        _loop0_8,
        _loop1_3,
        _loop1_4,
        _loop1_5,
        _loop1_6,
        _tmp_12,
        _tmp_13,
        _tmp_2,
        array_expr,
        assign_op,
        assign_stmt,
        atom_expr,
        bidir_cmp_expr,
        bitand_expr,  // Left-recursive
        bitor_expr,  // Left-recursive
        bitxor_expr,  // Left-recursive
        block_expr,
        call_args,
        cartridge,
        cartridge_header,
        class_def,
        comparison_expr,
        comparison_followup_pair,
        comparison_op,
        conjunction_expr,
        disjunction_expr,
        expr,
        expr_or_unit,
        expr_stmt,
        factor_expr,
        func_args_def,
        func_def,
        group_expr,
        impl_stmt,
        inversion_expr,
        name,
        power_expr,
        primary_expr,  // Left-recursive
        shift_expr,  // Left-recursive
        start,
        stmt,
        strings,
        sum_expr,  // Left-recursive
        term_expr,  // Left-recursive
        tuple_expr,
        type_annotation,
        var_def_stmt,
    };

    static constexpr bool is_left_recursive(RuleType rule) {
        switch (rule) {
            case RuleType::bitand_expr:  return true;
            case RuleType::bitor_expr:  return true;
            case RuleType::bitxor_expr:  return true;
            case RuleType::primary_expr:  return true;
            case RuleType::shift_expr:  return true;
            case RuleType::sum_expr:  return true;
            case RuleType::term_expr:  return true;
            default:  return false;
        }
    }

    template <RuleType R>
    using rule_result_t = std::tuple_element_t<
        (unsigned)R,
        std::tuple<
            std::vector<lex::Token>,
            std::vector<lex::Token>,
            std::vector<ast::stmt>,
            std::vector<lex::Token>,
            std::vector<ast::stmt>,
            std::vector<lex::Token>,
            std::vector<ast::expr>,
            std::vector<ast::expr>,
            std::vector<std::pair < ast::cmp_op , ast::expr >>,
            std::vector<lex::Token>,
            ast::expr,
            ast::expr,
            ast::expr,
            ast::expr,
            ast::assign_op,
            ast::stmt,
            ast::expr,
            ast::expr,
            ast::expr,
            ast::expr,
            ast::expr,
            ast::expr,
            ast::call_args,
            ast::cartridge,
            std::string,
            ast::expr,
            ast::expr,
            std::pair < ast::cmp_op , ast::expr >,
            ast::cmp_op,
            ast::expr,
            ast::expr,
            ast::expr,
            ast::expr,
            ast::stmt,
            ast::expr,
            ast::arg_defs,
            ast::expr,
            ast::expr,
            ast::stmt,
            ast::expr,
            std::string,
            ast::expr,
            ast::expr,
            ast::expr,
            ast::cartridge,
            ast::stmt,
            std::string,
            ast::expr,
            ast::expr,
            ast::expr,
            ast::expr,
            ast::stmt,
        >
    >;
    #pragma endregion Rule types

    #pragma region Helpers
    bool lookahead(bool positive, auto rule_func) {
        auto guard = lexer.lookahead();

        // TODO: Pass this?
        return positive == (bool)rule_func();
    }

    template <typename U>
    U forced(U result) {
        if (!result) {
            // TODO: More info?
            fatal_error("Forced rule failed");
        }

        return std::move(result);
    }

    state_t tell() {
        return lexer.tell();
    }

    void seek(state_t state) {
        lexer.seek(state);
    }
    #pragma endregion Helpers

    #pragma region CacheHelper
    template <RuleType rule_type>
    class CacheHelper {
    public:
        using result_t = std::optional<rule_result_t<rule_type>>;

        CacheHelper(Parser &parser, state_t state, result_t &result) :
            parser{parser}, state{std::move(state)}, rule_type{rule_type}, result{result} {}
        
        CacheHelper(const CacheHelper &) = delete;
        CacheHelper(CacheHelper &&) = delete;
        CacheHelper &operator=(const CacheHelper &) = delete;
        CacheHelper &operator=(CacheHelper &&) = delete;

        void accept() {
            is_success = true;
        }

        ~CacheHelper() {
            if (is_success) {
                parser.store_cached<rule_type>(state, result);
            }
        }
        
    private:
        Parser &parser;
        state_t state;
        result_t &result;
        bool is_success = false;
    
    };
    #pragma endregion CacheHelper

    #pragma region Caching
    template <RuleType rule_type>
    constexpr std::map<state_t, rule_result_t<rule_type>> &_get_cache() { {
            static_assert(false, "Uncachable rule type");
        }
    }

    template <RuleType rule_type>
    std::optional<rule_result_t<rule_type>> get_cached(state_t state) {
        auto &cache = _get_cache<rule_type>();

        auto it = cache.find(state);

        if (it == cache.end()) {
            return std::nullopt;
        }

        return it->second;
    }

    // Updates, if present
    template <RuleType rule_type>
    void store_cached(state_t state, std::optional<rule_result_t<rule_type>> result) {
        auto &cache = _get_cache<rule_type>();

        cache.emplace(state, std::move(result));
    }
    #pragma endregion Caching

    #pragma region Rule parsers
    
    // start: cartridge
    std::optional<ast::cartridge> parse_start()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::cartridge> _res = std::nullopt;
        { // cartridge
            auto cartridge_var = cartridge_var = parse_cartridge_rule();
            if (cartridge_var) {
                _res = cartridge_var;
                return _res;
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // cartridge: cartridge_header stmt*
    std::optional<ast::cartridge> parse_cartridge()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::cartridge> _res = std::nullopt;
        { // cartridge_header stmt*
            auto h = h = parse_cartridge_header_rule();
            if (h) {
            auto b = b = parse__loop0_1_rule();
            if (b) {
                _res = ast::Cartridge ( std::move ( h ) , std::move ( b ) );
                return _res;
            }
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // cartridge_header: 'cartridge' name ';'
    std::optional<std::string> parse_cartridge_header()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<std::string> _res = std::nullopt;
        { // 'cartridge' name ';'
            auto _keyword = _keyword = lexer.expect().keyword(CARTRIDGE);
            if (_keyword) {
            auto n = n = parse_name_rule();
            if (n) {
            auto _literal = _literal = lexer.expect().punct(SEMI);
            if (_literal) {
                _res = std::move ( n );
                return _res;
            }
            }
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // stmt: var_def_stmt | impl_stmt | assign_stmt | expr_stmt | ';'
    std::optional<ast::stmt> parse_stmt()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::stmt> _res = std::nullopt;
        { // var_def_stmt
            auto var_def_stmt_var = var_def_stmt_var = parse_var_def_stmt_rule();
            if (var_def_stmt_var) {
                _res = var_def_stmt_var;
                return _res;
            }
            seek(_state);
        }
        { // impl_stmt
            auto impl_stmt_var = impl_stmt_var = parse_impl_stmt_rule();
            if (impl_stmt_var) {
                _res = impl_stmt_var;
                return _res;
            }
            seek(_state);
        }
        { // assign_stmt
            auto assign_stmt_var = assign_stmt_var = parse_assign_stmt_rule();
            if (assign_stmt_var) {
                _res = assign_stmt_var;
                return _res;
            }
            seek(_state);
        }
        { // expr_stmt
            auto expr_stmt_var = expr_stmt_var = parse_expr_stmt_rule();
            if (expr_stmt_var) {
                _res = expr_stmt_var;
                return _res;
            }
            seek(_state);
        }
        { // ';'
            auto _literal = _literal = lexer.expect().punct(SEMI);
            if (_literal) {
                _res = ast::Pass ( );
                return _res;
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // assign_stmt: expr assign_op expr ';'
    std::optional<ast::stmt> parse_assign_stmt()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::stmt> _res = std::nullopt;
        { // expr assign_op expr ';'
            auto a = a = parse_expr_rule();
            if (a) {
            auto o = o = parse_assign_op_rule();
            if (o) {
            auto b = b = parse_expr_rule();
            if (b) {
            auto _literal = _literal = lexer.expect().punct(SEMI);
            if (_literal) {
                _res = ast::Assign ( std::move ( a ) , std::move ( b ) , std::move ( op ) );
                return _res;
            }
            }
            }
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // assign_op: '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '|=' | '^='
    std::optional<ast::assign_op> parse_assign_op()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::assign_op> _res = std::nullopt;
        { // '='
            auto _literal = _literal = lexer.expect().punct(EQUAL);
            if (_literal) {
                _res = ast::AsgnNone ( );
                return _res;
            }
            seek(_state);
        }
        { // '+='
            auto _literal = _literal = lexer.expect().punct(PLUSEQUAL);
            if (_literal) {
                _res = ast::AsgnAdd ( );
                return _res;
            }
            seek(_state);
        }
        { // '-='
            auto _literal = _literal = lexer.expect().punct(MINEQUAL);
            if (_literal) {
                _res = ast::AsgnSub ( );
                return _res;
            }
            seek(_state);
        }
        { // '*='
            auto _literal = _literal = lexer.expect().punct(STAREQUAL);
            if (_literal) {
                _res = ast::AsgnMul ( );
                return _res;
            }
            seek(_state);
        }
        { // '/='
            auto _literal = _literal = lexer.expect().punct(SLASHEQUAL);
            if (_literal) {
                _res = ast::AsgnDiv ( );
                return _res;
            }
            seek(_state);
        }
        { // '%='
            auto _literal = _literal = lexer.expect().punct(PERCENTEQUAL);
            if (_literal) {
                _res = ast::AsgnMod ( );
                return _res;
            }
            seek(_state);
        }
        { // '<<='
            auto _literal = _literal = lexer.expect().punct(LEFTSHIFTEQUAL);
            if (_literal) {
                _res = ast::AsgnLShift ( );
                return _res;
            }
            seek(_state);
        }
        { // '>>='
            auto _literal = _literal = lexer.expect().punct(RIGHTSHIFTEQUAL);
            if (_literal) {
                _res = ast::AsgnRShift ( );
                return _res;
            }
            seek(_state);
        }
        { // '&='
            auto _literal = _literal = lexer.expect().punct(AMPEREQUAL);
            if (_literal) {
                _res = ast::AsgnBitAnd ( );
                return _res;
            }
            seek(_state);
        }
        { // '|='
            auto _literal = _literal = lexer.expect().punct(VBAREQUAL);
            if (_literal) {
                _res = ast::AsgnBitOr ( );
                return _res;
            }
            seek(_state);
        }
        { // '^='
            auto _literal = _literal = lexer.expect().punct(CIRCUMFLEXEQUAL);
            if (_literal) {
                _res = ast::AsgnBitXor ( );
                return _res;
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // var_def_stmt: 'ctime'? 'var' name type_annotation? ['=' expr] ';'
    std::optional<ast::stmt> parse_var_def_stmt()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::stmt> _res = std::nullopt;
        { // 'ctime'? 'var' name type_annotation? ['=' expr] ';'
            auto c = c = lexer.expect().keyword(CTIME);
            if (true) {
            auto _keyword = _keyword = lexer.expect().keyword(VAR);
            if (_keyword) {
            auto n = n = parse_name_rule();
            if (n) {
            auto t = t = parse_type_annotation_rule();
            if (true) {
            auto v = v = parse__tmp_2_rule();
            if (true) {
            auto _literal = _literal = lexer.expect().punct(SEMI);
            if (_literal) {
                _res = ast::VarDef ( std::move ( n ) , std::move ( t ) , std::move ( v ) , true , bool ( c ) );
                return _res;
            }
            }
            }
            }
            }
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // impl_stmt: 
    std::optional<ast::stmt> parse_impl_stmt()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::stmt> _res = std::nullopt;
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // expr_stmt: expr ';'
    std::optional<ast::stmt> parse_expr_stmt()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::stmt> _res = std::nullopt;
        { // expr ';'
            auto a = a = parse_expr_rule();
            if (a) {
            auto _literal = _literal = lexer.expect().punct(SEMI);
            if (_literal) {
                _res = ast::Expr ( std::move ( a ) );
                return _res;
            }
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // expr:
    //     | func_def
    //     | class_def
    //     | block_expr
    //     | 'return' expr_or_unit
    //     | 'break' expr_or_unit
    //     | disjunction_expr
    std::optional<ast::expr> parse_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // func_def
            auto func_def_var = func_def_var = parse_func_def_rule();
            if (func_def_var) {
                _res = func_def_var;
                return _res;
            }
            seek(_state);
        }
        { // class_def
            auto class_def_var = class_def_var = parse_class_def_rule();
            if (class_def_var) {
                _res = class_def_var;
                return _res;
            }
            seek(_state);
        }
        { // block_expr
            auto block_expr_var = block_expr_var = parse_block_expr_rule();
            if (block_expr_var) {
                _res = block_expr_var;
                return _res;
            }
            seek(_state);
        }
        { // 'return' expr_or_unit
            auto _keyword = _keyword = lexer.expect().keyword(RETURN);
            if (_keyword) {
            auto a = a = parse_expr_or_unit_rule();
            if (a) {
                _res = ast::Return ( std::move ( a ) );
                return _res;
            }
            }
            seek(_state);
        }
        { // 'break' expr_or_unit
            auto _keyword = _keyword = lexer.expect().keyword(BREAK);
            if (_keyword) {
            auto a = a = parse_expr_or_unit_rule();
            if (a) {
                _res = ast::Break ( std::move ( a ) );
                return _res;
            }
            }
            seek(_state);
        }
        { // disjunction_expr
            auto disjunction_expr_var = disjunction_expr_var = parse_disjunction_expr_rule();
            if (disjunction_expr_var) {
                _res = disjunction_expr_var;
                return _res;
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // expr_or_unit: expr | 
    std::optional<ast::expr> parse_expr_or_unit()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // expr
            auto expr_var = expr_var = parse_expr_rule();
            if (expr_var) {
                _res = expr_var;
                return _res;
            }
            seek(_state);
        }
        { // 
                _res = ast::Constant ( std::monostate ( ) );
                return _res;
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // disjunction_expr: conjunction_expr (('or' conjunction_expr))+ | conjunction_expr
    std::optional<ast::expr> parse_disjunction_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // conjunction_expr (('or' conjunction_expr))+
            auto a = a = parse_conjunction_expr_rule();
            if (a) {
            auto b = b = parse__loop1_3_rule();
            if (b) {
                _res = ast::BoolOp ( ast::Or ( ) , ... );
                return _res;
            }
            }
            seek(_state);
        }
        { // conjunction_expr
            auto conjunction_expr_var = conjunction_expr_var = parse_conjunction_expr_rule();
            if (conjunction_expr_var) {
                _res = conjunction_expr_var;
                return _res;
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // conjunction_expr: inversion_expr (('and' inversion_expr))+ | inversion_expr
    std::optional<ast::expr> parse_conjunction_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // inversion_expr (('and' inversion_expr))+
            auto a = a = parse_inversion_expr_rule();
            if (a) {
            auto b = b = parse__loop1_4_rule();
            if (b) {
                _res = ast::BoolOp ( ast::And ( ) , ... );
                return _res;
            }
            }
            seek(_state);
        }
        { // inversion_expr
            auto inversion_expr_var = inversion_expr_var = parse_inversion_expr_rule();
            if (inversion_expr_var) {
                _res = inversion_expr_var;
                return _res;
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // inversion_expr: 'not' inversion_expr | comparison_expr
    std::optional<ast::expr> parse_inversion_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // 'not' inversion_expr
            auto _keyword = _keyword = lexer.expect().keyword(NOT);
            if (_keyword) {
            auto a = a = parse_inversion_expr_rule();
            if (a) {
                _res = ast::UnaryOp ( ast::Not ( ) , std::move ( a ) );
                return _res;
            }
            }
            seek(_state);
        }
        { // comparison_expr
            auto comparison_expr_var = comparison_expr_var = parse_comparison_expr_rule();
            if (comparison_expr_var) {
                _res = comparison_expr_var;
                return _res;
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // comparison_expr: bidir_cmp_expr comparison_followup_pair+ | bidir_cmp_expr
    std::optional<ast::expr> parse_comparison_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // bidir_cmp_expr comparison_followup_pair+
            auto a = a = parse_bidir_cmp_expr_rule();
            if (a) {
            auto b = b = parse__loop1_5_rule();
            if (b) {
                _res = ast::Compare ( std::move ( a ) , make_sequence ( ... ) , make_sequence ( ... ) );
                return _res;
            }
            }
            seek(_state);
        }
        { // bidir_cmp_expr
            auto bidir_cmp_expr_var = bidir_cmp_expr_var = parse_bidir_cmp_expr_rule();
            if (bidir_cmp_expr_var) {
                _res = bidir_cmp_expr_var;
                return _res;
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // comparison_followup_pair: comparison_op bidir_cmp_expr
    std::optional<std::pair < ast::cmp_op , ast::expr >> parse_comparison_followup_pair()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<std::pair < ast::cmp_op , ast::expr >> _res = std::nullopt;
        { // comparison_op bidir_cmp_expr
            auto o = o = parse_comparison_op_rule();
            if (o) {
            auto a = a = parse_bidir_cmp_expr_rule();
            if (a) {
                _res = std::make_pair ( std::move ( o ) , std::move ( a ) );
                return _res;
            }
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // comparison_op: '==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in'
    std::optional<ast::cmp_op> parse_comparison_op()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::cmp_op> _res = std::nullopt;
        { // '=='
            auto _literal = _literal = lexer.expect().punct(DOUBLEEQUAL);
            if (_literal) {
                _res = ast::Eq ( );
                return _res;
            }
            seek(_state);
        }
        { // '!='
            auto _literal = _literal = lexer.expect().punct(NOTEQUAL);
            if (_literal) {
                _res = ast::NotEq ( );
                return _res;
            }
            seek(_state);
        }
        { // '<'
            auto _literal = _literal = lexer.expect().punct(LESS);
            if (_literal) {
                _res = ast::Lt ( );
                return _res;
            }
            seek(_state);
        }
        { // '<='
            auto _literal = _literal = lexer.expect().punct(LESSEQUAL);
            if (_literal) {
                _res = ast::LtE ( );
                return _res;
            }
            seek(_state);
        }
        { // '>'
            auto _literal = _literal = lexer.expect().punct(GREATER);
            if (_literal) {
                _res = ast::Gt ( );
                return _res;
            }
            seek(_state);
        }
        { // '>='
            auto _literal = _literal = lexer.expect().punct(GREATEREQUAL);
            if (_literal) {
                _res = ast::GtE ( );
                return _res;
            }
            seek(_state);
        }
        { // 'in'
            auto _keyword = _keyword = lexer.expect().keyword(IN);
            if (_keyword) {
                _res = ast::In ( );
                return _res;
            }
            seek(_state);
        }
        { // 'not' 'in'
            auto _keyword = _keyword = lexer.expect().keyword(NOT);
            if (_keyword) {
            auto _keyword_1 = _keyword_1 = lexer.expect().keyword(IN);
            if (_keyword_1) {
                _res = ast::NotIn ( );
                return _res;
            }
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // bidir_cmp_expr: bitor_expr '<=>' bitor_expr | bitor_expr
    std::optional<ast::expr> parse_bidir_cmp_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // bitor_expr '<=>' bitor_expr
            auto a = a = parse_bitor_expr_rule();
            if (a) {
            auto _literal = _literal = lexer.expect().punct(BIDIRCMP);
            if (_literal) {
            auto b = b = parse_bitor_expr_rule();
            if (b) {
                _res = ast::Compare ( std::move ( a ) , std::move ( b ) );
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // bitor_expr
            auto bitor_expr_var = bitor_expr_var = parse_bitor_expr_rule();
            if (bitor_expr_var) {
                _res = bitor_expr_var;
                return _res;
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // Left-recursive
    // bitor_expr: bitor_expr '|' bitxor_expr | bitxor_expr
    std::optional<ast::expr> parse_raw_bitor_expr();
    std::optional<ast::expr> parse_bitor_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        if (_res = get_cached<RuleType::bitor_expr>(_state)) {
            return _res;
        }
        auto _state = tell();
        auto _res_state = tell();
        while (true) {
            store_cached<RuleType::bitor_expr>(_state, _res);
            seek(_state);
            auto _raw = parse_raw_bitor_expr();
            if (!_raw || tell() <= _res_state) {
                break;
            }
            _res = _raw;
            _res_state = tell();
        }
        seek(_res_state);
        return _res;
    }
    #else
    ;
    #endif
    std::optional<ast::expr> parse_raw_bitor_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // bitor_expr '|' bitxor_expr
            auto a = a = parse_bitor_expr_rule();
            if (a) {
            auto _literal = _literal = lexer.expect().punct(VBAR);
            if (_literal) {
            auto b = b = parse_bitxor_expr_rule();
            if (b) {
                _res = ast::BinOp ( ast::BitOr ( ) , std::move ( a ) , std::move ( b ) );
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // bitxor_expr
            auto bitxor_expr_var = bitxor_expr_var = parse_bitxor_expr_rule();
            if (bitxor_expr_var) {
                _res = bitxor_expr_var;
                return _res;
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // Left-recursive
    // bitxor_expr: bitxor_expr '^' bitand_expr | bitand_expr
    std::optional<ast::expr> parse_raw_bitxor_expr();
    std::optional<ast::expr> parse_bitxor_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        if (_res = get_cached<RuleType::bitxor_expr>(_state)) {
            return _res;
        }
        auto _state = tell();
        auto _res_state = tell();
        while (true) {
            store_cached<RuleType::bitxor_expr>(_state, _res);
            seek(_state);
            auto _raw = parse_raw_bitxor_expr();
            if (!_raw || tell() <= _res_state) {
                break;
            }
            _res = _raw;
            _res_state = tell();
        }
        seek(_res_state);
        return _res;
    }
    #else
    ;
    #endif
    std::optional<ast::expr> parse_raw_bitxor_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // bitxor_expr '^' bitand_expr
            auto a = a = parse_bitxor_expr_rule();
            if (a) {
            auto _literal = _literal = lexer.expect().punct(CIRCUMFLEX);
            if (_literal) {
            auto b = b = parse_bitand_expr_rule();
            if (b) {
                _res = ast::BinOp ( ast::BitXor ( ) , std::move ( a ) , std::move ( b ) );
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // bitand_expr
            auto bitand_expr_var = bitand_expr_var = parse_bitand_expr_rule();
            if (bitand_expr_var) {
                _res = bitand_expr_var;
                return _res;
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // Left-recursive
    // bitand_expr: bitand_expr '&' shift_expr | shift_expr
    std::optional<ast::expr> parse_raw_bitand_expr();
    std::optional<ast::expr> parse_bitand_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        if (_res = get_cached<RuleType::bitand_expr>(_state)) {
            return _res;
        }
        auto _state = tell();
        auto _res_state = tell();
        while (true) {
            store_cached<RuleType::bitand_expr>(_state, _res);
            seek(_state);
            auto _raw = parse_raw_bitand_expr();
            if (!_raw || tell() <= _res_state) {
                break;
            }
            _res = _raw;
            _res_state = tell();
        }
        seek(_res_state);
        return _res;
    }
    #else
    ;
    #endif
    std::optional<ast::expr> parse_raw_bitand_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // bitand_expr '&' shift_expr
            auto a = a = parse_bitand_expr_rule();
            if (a) {
            auto _literal = _literal = lexer.expect().punct(AMPER);
            if (_literal) {
            auto b = b = parse_shift_expr_rule();
            if (b) {
                _res = ast::BinOp ( ast::BitAnd ( ) , std::move ( a ) , std::move ( b ) );
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // shift_expr
            auto shift_expr_var = shift_expr_var = parse_shift_expr_rule();
            if (shift_expr_var) {
                _res = shift_expr_var;
                return _res;
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // Left-recursive
    // shift_expr: shift_expr '<<' sum_expr | shift_expr '>>' sum_expr | sum_expr
    std::optional<ast::expr> parse_raw_shift_expr();
    std::optional<ast::expr> parse_shift_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        if (_res = get_cached<RuleType::shift_expr>(_state)) {
            return _res;
        }
        auto _state = tell();
        auto _res_state = tell();
        while (true) {
            store_cached<RuleType::shift_expr>(_state, _res);
            seek(_state);
            auto _raw = parse_raw_shift_expr();
            if (!_raw || tell() <= _res_state) {
                break;
            }
            _res = _raw;
            _res_state = tell();
        }
        seek(_res_state);
        return _res;
    }
    #else
    ;
    #endif
    std::optional<ast::expr> parse_raw_shift_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // shift_expr '<<' sum_expr
            auto a = a = parse_shift_expr_rule();
            if (a) {
            auto _literal = _literal = lexer.expect().punct(LEFTSHIFT);
            if (_literal) {
            auto b = b = parse_sum_expr_rule();
            if (b) {
                _res = ast::BinOp ( ast::LShift ( ) , std::move ( a ) , std::move ( b ) );
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // shift_expr '>>' sum_expr
            auto a = a = parse_shift_expr_rule();
            if (a) {
            auto _literal = _literal = lexer.expect().punct(RIGHTSHIFT);
            if (_literal) {
            auto b = b = parse_sum_expr_rule();
            if (b) {
                _res = ast::BinOp ( ast::RShift ( ) , std::move ( a ) , std::move ( b ) );
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // sum_expr
            auto sum_expr_var = sum_expr_var = parse_sum_expr_rule();
            if (sum_expr_var) {
                _res = sum_expr_var;
                return _res;
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // Left-recursive
    // sum_expr: sum_expr '+' term_expr | sum_expr '-' term_expr | term_expr
    std::optional<ast::expr> parse_raw_sum_expr();
    std::optional<ast::expr> parse_sum_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        if (_res = get_cached<RuleType::sum_expr>(_state)) {
            return _res;
        }
        auto _state = tell();
        auto _res_state = tell();
        while (true) {
            store_cached<RuleType::sum_expr>(_state, _res);
            seek(_state);
            auto _raw = parse_raw_sum_expr();
            if (!_raw || tell() <= _res_state) {
                break;
            }
            _res = _raw;
            _res_state = tell();
        }
        seek(_res_state);
        return _res;
    }
    #else
    ;
    #endif
    std::optional<ast::expr> parse_raw_sum_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // sum_expr '+' term_expr
            auto a = a = parse_sum_expr_rule();
            if (a) {
            auto _literal = _literal = lexer.expect().punct(PLUS);
            if (_literal) {
            auto b = b = parse_term_expr_rule();
            if (b) {
                _res = ast::BinOp ( ast::Add ( ) , std::move ( a ) , std::move ( b ) );
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // sum_expr '-' term_expr
            auto a = a = parse_sum_expr_rule();
            if (a) {
            auto _literal = _literal = lexer.expect().punct(MINUS);
            if (_literal) {
            auto b = b = parse_term_expr_rule();
            if (b) {
                _res = ast::BinOp ( ast::Sub ( ) , std::move ( a ) , std::move ( b ) );
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // term_expr
            auto term_expr_var = term_expr_var = parse_term_expr_rule();
            if (term_expr_var) {
                _res = term_expr_var;
                return _res;
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // Left-recursive
    // term_expr:
    //     | term_expr '*' factor_expr
    //     | term_expr '/' factor_expr
    //     | term_expr '%' factor_expr
    //     | factor_expr
    std::optional<ast::expr> parse_raw_term_expr();
    std::optional<ast::expr> parse_term_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        if (_res = get_cached<RuleType::term_expr>(_state)) {
            return _res;
        }
        auto _state = tell();
        auto _res_state = tell();
        while (true) {
            store_cached<RuleType::term_expr>(_state, _res);
            seek(_state);
            auto _raw = parse_raw_term_expr();
            if (!_raw || tell() <= _res_state) {
                break;
            }
            _res = _raw;
            _res_state = tell();
        }
        seek(_res_state);
        return _res;
    }
    #else
    ;
    #endif
    std::optional<ast::expr> parse_raw_term_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // term_expr '*' factor_expr
            auto a = a = parse_term_expr_rule();
            if (a) {
            auto _literal = _literal = lexer.expect().punct(STAR);
            if (_literal) {
            auto b = b = parse_factor_expr_rule();
            if (b) {
                _res = ast::BinOp ( ast::Mul ( ) , std::move ( a ) , std::move ( b ) );
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // term_expr '/' factor_expr
            auto a = a = parse_term_expr_rule();
            if (a) {
            auto _literal = _literal = lexer.expect().punct(SLASH);
            if (_literal) {
            auto b = b = parse_factor_expr_rule();
            if (b) {
                _res = ast::BinOp ( ast::Div ( ) , std::move ( a ) , std::move ( b ) );
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // term_expr '%' factor_expr
            auto a = a = parse_term_expr_rule();
            if (a) {
            auto _literal = _literal = lexer.expect().punct(PERCENT);
            if (_literal) {
            auto b = b = parse_factor_expr_rule();
            if (b) {
                _res = ast::BinOp ( ast::Mod ( ) , std::move ( a ) , std::move ( b ) );
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // factor_expr
            auto factor_expr_var = factor_expr_var = parse_factor_expr_rule();
            if (factor_expr_var) {
                _res = factor_expr_var;
                return _res;
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // factor_expr: '+' factor_expr | '-' factor_expr | '~' factor_expr | power_expr
    std::optional<ast::expr> parse_factor_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // '+' factor_expr
            auto _literal = _literal = lexer.expect().punct(PLUS);
            if (_literal) {
            auto a = a = parse_factor_expr_rule();
            if (a) {
                _res = ast::UnaryOp ( ast::UAdd ( ) , std::move ( a ) );
                return _res;
            }
            }
            seek(_state);
        }
        { // '-' factor_expr
            auto _literal = _literal = lexer.expect().punct(MINUS);
            if (_literal) {
            auto a = a = parse_factor_expr_rule();
            if (a) {
                _res = ast::UnaryOp ( ast::USub ( ) , std::move ( a ) );
                return _res;
            }
            }
            seek(_state);
        }
        { // '~' factor_expr
            auto _literal = _literal = lexer.expect().punct(TILDE);
            if (_literal) {
            auto a = a = parse_factor_expr_rule();
            if (a) {
                _res = ast::UnaryOp ( ast::BitInv ( ) , std::move ( a ) );
                return _res;
            }
            }
            seek(_state);
        }
        { // power_expr
            auto power_expr_var = power_expr_var = parse_power_expr_rule();
            if (power_expr_var) {
                _res = power_expr_var;
                return _res;
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // power_expr: primary_expr '**' factor_expr | primary_expr
    std::optional<ast::expr> parse_power_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // primary_expr '**' factor_expr
            auto a = a = parse_primary_expr_rule();
            if (a) {
            auto _literal = _literal = lexer.expect().punct(POWER);
            if (_literal) {
            auto b = b = parse_factor_expr_rule();
            if (b) {
                _res = ast::BinOp ( ast::Pow ( ) , std::move ( a ) , std::move ( b ) );
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // primary_expr
            auto primary_expr_var = primary_expr_var = parse_primary_expr_rule();
            if (primary_expr_var) {
                _res = primary_expr_var;
                return _res;
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // Left-recursive
    // primary_expr:
    //     | primary_expr '.' name
    //     | primary_expr '::' name
    //     | primary_expr '[' call_args ']'
    //     | primary_expr '(' call_args ')'
    //     | atom_expr
    std::optional<ast::expr> parse_raw_primary_expr();
    std::optional<ast::expr> parse_primary_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        if (_res = get_cached<RuleType::primary_expr>(_state)) {
            return _res;
        }
        auto _state = tell();
        auto _res_state = tell();
        while (true) {
            store_cached<RuleType::primary_expr>(_state, _res);
            seek(_state);
            auto _raw = parse_raw_primary_expr();
            if (!_raw || tell() <= _res_state) {
                break;
            }
            _res = _raw;
            _res_state = tell();
        }
        seek(_res_state);
        return _res;
    }
    #else
    ;
    #endif
    std::optional<ast::expr> parse_raw_primary_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // primary_expr '.' name
            auto a = a = parse_primary_expr_rule();
            if (a) {
            auto _literal = _literal = lexer.expect().punct(DOT);
            if (_literal) {
            auto b = b = parse_name_rule();
            if (b) {
                _res = ast::Attribute ( std::move ( a ) , std::move ( b ) , ast::AttrInst ( ) );
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // primary_expr '::' name
            auto a = a = parse_primary_expr_rule();
            if (a) {
            auto _literal = _literal = lexer.expect().punct(DOUBLECOLON);
            if (_literal) {
            auto b = b = parse_name_rule();
            if (b) {
                _res = ast::Attribute ( std::move ( a ) , std::move ( b ) , ast::AttrStatic ( ) );
                return _res;
            }
            }
            }
            seek(_state);
        }
        { // primary_expr '[' call_args ']'
            auto a = a = parse_primary_expr_rule();
            if (a) {
            auto _literal = _literal = lexer.expect().punct(LSQB);
            if (_literal) {
            auto b = b = parse_call_args_rule();
            if (b) {
            auto _literal_1 = _literal_1 = lexer.expect().punct(RSQB);
            if (_literal_1) {
                _res = ast::Subscript ( std::move ( a ) , std::move ( b ) );
                return _res;
            }
            }
            }
            }
            seek(_state);
        }
        { // primary_expr '(' call_args ')'
            auto a = a = parse_primary_expr_rule();
            if (a) {
            auto _literal = _literal = lexer.expect().punct(LPAR);
            if (_literal) {
            auto b = b = parse_call_args_rule();
            if (b) {
            auto _literal_1 = _literal_1 = lexer.expect().punct(RPAR);
            if (_literal_1) {
                _res = ast::Call ( std::move ( a ) , std::move ( b ) );
                return _res;
            }
            }
            }
            }
            seek(_state);
        }
        { // atom_expr
            auto atom_expr_var = atom_expr_var = parse_atom_expr_rule();
            if (atom_expr_var) {
                _res = atom_expr_var;
                return _res;
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // atom_expr:
    //     | name
    //     | NUMBER
    //     | &STRING strings
    //     | group_expr
    //     | tuple_expr
    //     | array_expr
    //     | block_expr
    std::optional<ast::expr> parse_atom_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // name
            auto a = a = parse_name_rule();
            if (a) {
                _res = ast::Name ( std::move ( a ) );
                return _res;
            }
            seek(_state);
        }
        { // NUMBER
            auto a = a = lexer.expect().token(TokenType::NUMBER);
            if (a) {
                _res = ast::Constant ( a . get_number ( ) . value );
                return _res;
            }
            seek(_state);
        }
        { // &STRING strings
            auto _tmpvar = _tmpvar = lexer.lookahead(true).token(TokenType::STRING);
            if (_tmpvar) {
            auto a = a = parse_strings_rule();
            if (a) {
                _res = std::move ( a );
                return _res;
            }
            }
            seek(_state);
        }
        { // group_expr
            auto group_expr_var = group_expr_var = parse_group_expr_rule();
            if (group_expr_var) {
                _res = group_expr_var;
                return _res;
            }
            seek(_state);
        }
        { // tuple_expr
            auto tuple_expr_var = tuple_expr_var = parse_tuple_expr_rule();
            if (tuple_expr_var) {
                _res = tuple_expr_var;
                return _res;
            }
            seek(_state);
        }
        { // array_expr
            auto array_expr_var = array_expr_var = parse_array_expr_rule();
            if (array_expr_var) {
                _res = array_expr_var;
                return _res;
            }
            seek(_state);
        }
        { // block_expr
            auto block_expr_var = block_expr_var = parse_block_expr_rule();
            if (block_expr_var) {
                _res = block_expr_var;
                return _res;
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // call_args: 
    std::optional<ast::call_args> parse_call_args()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::call_args> _res = std::nullopt;
        { // 
                _res = ast::call_args ( make_sequence ( ) , nullptr , nullptr );
                return _res;
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // name: NAME
    std::optional<std::string> parse_name()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<std::string> _res = std::nullopt;
        { // NAME
            auto a = a = lexer.expect().token(TokenType::NAME);
            if (a) {
                _res = a . get_name ( ) . value;
                return _res;
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // strings: STRING+
    std::optional<std::string> parse_strings()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<std::string> _res = std::nullopt;
        { // STRING+
            auto a = a = parse__loop1_6_rule();
            if (a) {
                _res = _concat_strings ( a );
                return _res;
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // group_expr: '(' expr ')'
    std::optional<ast::expr> parse_group_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // '(' expr ')'
            auto _literal = _literal = lexer.expect().punct(LPAR);
            if (_literal) {
            auto a = a = parse_expr_rule();
            if (a) {
            auto _literal_1 = _literal_1 = lexer.expect().punct(RPAR);
            if (_literal_1) {
                _res = std::move ( a );
                return _res;
            }
            }
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // tuple_expr: '(' ')' | '(' ','.expr+ ','? ')'
    std::optional<ast::expr> parse_tuple_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // '(' ')'
            auto _literal = _literal = lexer.expect().punct(LPAR);
            if (_literal) {
            auto _literal_1 = _literal_1 = lexer.expect().punct(RPAR);
            if (_literal_1) {
                _res = ast::Tuple ( make_sequence ( ) );
                return _res;
            }
            }
            seek(_state);
        }
        { // '(' ','.expr+ ','? ')'
            auto _literal = _literal = lexer.expect().punct(LPAR);
            if (_literal) {
            auto a = a = parse__gather_7_rule();
            if (a) {
            auto _opt_var = _opt_var = lexer.expect().punct(COMMA);
            if (true) {
            auto _literal_1 = _literal_1 = lexer.expect().punct(RPAR);
            if (_literal_1) {
                _res = ast::Tuple ( std::move ( a ) );
                return _res;
            }
            }
            }
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // array_expr: '[' ']' | '[' ','.expr+ ','? ']'
    std::optional<ast::expr> parse_array_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // '[' ']'
            auto _literal = _literal = lexer.expect().punct(LSQB);
            if (_literal) {
            auto _literal_1 = _literal_1 = lexer.expect().punct(RSQB);
            if (_literal_1) {
                _res = ast::Array ( make_sequence ( ) );
                return _res;
            }
            }
            seek(_state);
        }
        { // '[' ','.expr+ ','? ']'
            auto _literal = _literal = lexer.expect().punct(LSQB);
            if (_literal) {
            auto a = a = parse__gather_9_rule();
            if (a) {
            auto _opt_var = _opt_var = lexer.expect().punct(COMMA);
            if (true) {
            auto _literal_1 = _literal_1 = lexer.expect().punct(RSQB);
            if (_literal_1) {
                _res = ast::Array ( std::move ( a ) );
                return _res;
            }
            }
            }
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // block_expr: 'ctime'? '{' stmt* expr_or_unit '}'
    std::optional<ast::expr> parse_block_expr()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // 'ctime'? '{' stmt* expr_or_unit '}'
            auto c = c = lexer.expect().keyword(CTIME);
            if (true) {
            auto _literal = _literal = lexer.expect().punct(LBRACE);
            if (_literal) {
            auto b = b = parse__loop0_11_rule();
            if (b) {
            auto v = v = parse_expr_or_unit_rule();
            if (v) {
            auto _literal_1 = _literal_1 = lexer.expect().punct(RBRACE);
            if (_literal_1) {
                _res = ast::Block ( std::move ( b ) , std::move ( v ) , bool ( c ) );
                return _res;
            }
            }
            }
            }
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // type_annotation: ':' expr
    std::optional<ast::expr> parse_type_annotation()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // ':' expr
            auto _literal = _literal = lexer.expect().punct(COLON);
            if (_literal) {
            auto a = a = parse_expr_rule();
            if (a) {
                _res = std::move ( a );
                return _res;
            }
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // func_def: 'func' name '(' func_args_def ')' type_annotation? '=>' expr ';'
    std::optional<ast::expr> parse_func_def()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // 'func' name '(' func_args_def ')' type_annotation? '=>' expr ';'
            auto _keyword = _keyword = lexer.expect().keyword(FUNC);
            if (_keyword) {
            auto n = n = parse_name_rule();
            if (n) {
            auto _literal = _literal = lexer.expect().punct(LPAR);
            if (_literal) {
            auto a = a = parse_func_args_def_rule();
            if (a) {
            auto _literal_1 = _literal_1 = lexer.expect().punct(RPAR);
            if (_literal_1) {
            auto t = t = parse_type_annotation_rule();
            if (true) {
            auto _literal_2 = _literal_2 = lexer.expect().punct(RARROW2);
            if (_literal_2) {
            auto b = b = parse_expr_rule();
            if (b) {
            auto _literal_3 = _literal_3 = lexer.expect().punct(SEMI);
            if (_literal_3) {
                _res = ast::FuncDef ( std::move ( n ) , std::move ( a ) , std::move ( t ) , std::move ( b ) );
                return _res;
            }
            }
            }
            }
            }
            }
            }
            }
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // func_args_def: 
    std::optional<ast::arg_defs> parse_func_args_def()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::arg_defs> _res = std::nullopt;
        { // 
                _res = ast::arg_defs ( make_sequence ( ) );
                return _res;
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // class_def: 'ctime'? 'class' name '(' func_args_def ')' ';'
    std::optional<ast::expr> parse_class_def()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // 'ctime'? 'class' name '(' func_args_def ')' ';'
            auto c = c = lexer.expect().keyword(CTIME);
            if (true) {
            auto _keyword = _keyword = lexer.expect().keyword(CLASS);
            if (_keyword) {
            auto n = n = parse_name_rule();
            if (n) {
            auto _literal = _literal = lexer.expect().punct(LPAR);
            if (_literal) {
            auto a = a = parse_func_args_def_rule();
            if (a) {
            auto _literal_1 = _literal_1 = lexer.expect().punct(RPAR);
            if (_literal_1) {
            auto _literal_2 = _literal_2 = lexer.expect().punct(SEMI);
            if (_literal_2) {
                _res = _dummy_whatever_(c, _keyword, n, _literal, a, _literal_1, _literal_2);
                return _res;
            }
            }
            }
            }
            }
            }
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // _loop0_1: stmt
    std::optional<std::vector<ast::stmt>> parse__loop0_1()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<std::vector<ast::stmt>> _res = std::nullopt;
        auto _state = tell();
        int _start_state = tell();
        std::vector<std::vector<ast::stmt>> _children{};
        size_t _n = 0;
        { // stmt
            while (true) {
                auto stmt_var = stmt_var = parse_stmt_rule();
                if (stmt_var) {
                    _res = stmt_var;
                    _children.push_back(_res);
                    _state = tell();
                    continue;
                }
                break;
            }
            seek(_state);
        }
        auto _seq = ast::make_sequence(std::move(_res));
        return _seq;
    }
    #else
    ;
    #endif

    // _tmp_2: '=' expr
    std::optional<ast::expr> parse__tmp_2()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // '=' expr
            auto _literal = _literal = lexer.expect().punct(EQUAL);
            if (_literal) {
            auto a = a = parse_expr_rule();
            if (a) {
                _res = a;
                return _res;
            }
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // _loop1_3: ('or' conjunction_expr)
    std::optional<std::vector<ast::expr>> parse__loop1_3()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<std::vector<ast::expr>> _res = std::nullopt;
        auto _state = tell();
        int _start_state = tell();
        std::vector<std::vector<ast::expr>> _children{};
        size_t _n = 0;
        { // ('or' conjunction_expr)
            while (true) {
                auto _tmp_12_var = _tmp_12_var = parse__tmp_12_rule();
                if (_tmp_12_var) {
                    _res = _tmp_12_var;
                    _children.push_back(_res);
                    _state = tell();
                    continue;
                }
                break;
            }
            seek(_state);
        }
        if (_n == 0) {
            return std::nullopt;
        }
        auto _seq = ast::make_sequence(std::move(_res));
        return _seq;
    }
    #else
    ;
    #endif

    // _loop1_4: ('and' inversion_expr)
    std::optional<std::vector<ast::expr>> parse__loop1_4()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<std::vector<ast::expr>> _res = std::nullopt;
        auto _state = tell();
        int _start_state = tell();
        std::vector<std::vector<ast::expr>> _children{};
        size_t _n = 0;
        { // ('and' inversion_expr)
            while (true) {
                auto _tmp_13_var = _tmp_13_var = parse__tmp_13_rule();
                if (_tmp_13_var) {
                    _res = _tmp_13_var;
                    _children.push_back(_res);
                    _state = tell();
                    continue;
                }
                break;
            }
            seek(_state);
        }
        if (_n == 0) {
            return std::nullopt;
        }
        auto _seq = ast::make_sequence(std::move(_res));
        return _seq;
    }
    #else
    ;
    #endif

    // _loop1_5: comparison_followup_pair
    std::optional<std::vector<std::pair < ast::cmp_op , ast::expr >>> parse__loop1_5()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<std::vector<std::pair < ast::cmp_op , ast::expr >>> _res = std::nullopt;
        auto _state = tell();
        int _start_state = tell();
        std::vector<std::vector<std::pair < ast::cmp_op , ast::expr >>> _children{};
        size_t _n = 0;
        { // comparison_followup_pair
            while (true) {
                auto comparison_followup_pair_var = comparison_followup_pair_var = parse_comparison_followup_pair_rule();
                if (comparison_followup_pair_var) {
                    _res = comparison_followup_pair_var;
                    _children.push_back(_res);
                    _state = tell();
                    continue;
                }
                break;
            }
            seek(_state);
        }
        if (_n == 0) {
            return std::nullopt;
        }
        auto _seq = ast::make_sequence(std::move(_res));
        return _seq;
    }
    #else
    ;
    #endif

    // _loop1_6: STRING
    std::optional<std::vector<lex::Token>> parse__loop1_6()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<std::vector<lex::Token>> _res = std::nullopt;
        auto _state = tell();
        int _start_state = tell();
        std::vector<std::vector<lex::Token>> _children{};
        size_t _n = 0;
        { // STRING
            while (true) {
                auto STRING_var = STRING_var = lexer.expect().token(TokenType::STRING);
                if (STRING_var) {
                    _res = STRING_var;
                    _children.push_back(_res);
                    _state = tell();
                    continue;
                }
                break;
            }
            seek(_state);
        }
        if (_n == 0) {
            return std::nullopt;
        }
        auto _seq = ast::make_sequence(std::move(_res));
        return _seq;
    }
    #else
    ;
    #endif

    // _loop0_8: ',' expr
    std::optional<std::vector<lex::Token>> parse__loop0_8()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<std::vector<lex::Token>> _res = std::nullopt;
        auto _state = tell();
        int _start_state = tell();
        std::vector<std::vector<lex::Token>> _children{};
        size_t _n = 0;
        { // ',' expr
            while (true) {
                auto _literal = _literal = lexer.expect().punct(COMMA);
                if (_literal) {
                auto elem = elem = parse_expr_rule();
                if (elem) {
                    _res = elem;
                    _children.push_back(_res);
                    _state = tell();
                    continue;
                }
                }
                break;
            }
            seek(_state);
        }
        auto _seq = ast::make_sequence(std::move(_res));
        return _seq;
    }
    #else
    ;
    #endif

    // _gather_7: expr _loop0_8
    std::optional<std::vector<lex::Token>> parse__gather_7()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<std::vector<lex::Token>> _res = std::nullopt;
        { // expr _loop0_8
            auto elem = elem = parse_expr_rule();
            if (elem) {
            auto seq = seq = parse__loop0_8_rule();
            if (seq) {
                // !!! DBG: emit_default_action(gather) locals: ['elem', 'seq']
                _res.push_back(std::move(seq));
                return _res;
            }
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // _loop0_10: ',' expr
    std::optional<std::vector<lex::Token>> parse__loop0_10()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<std::vector<lex::Token>> _res = std::nullopt;
        auto _state = tell();
        int _start_state = tell();
        std::vector<std::vector<lex::Token>> _children{};
        size_t _n = 0;
        { // ',' expr
            while (true) {
                auto _literal = _literal = lexer.expect().punct(COMMA);
                if (_literal) {
                auto elem = elem = parse_expr_rule();
                if (elem) {
                    _res = elem;
                    _children.push_back(_res);
                    _state = tell();
                    continue;
                }
                }
                break;
            }
            seek(_state);
        }
        auto _seq = ast::make_sequence(std::move(_res));
        return _seq;
    }
    #else
    ;
    #endif

    // _gather_9: expr _loop0_10
    std::optional<std::vector<lex::Token>> parse__gather_9()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<std::vector<lex::Token>> _res = std::nullopt;
        { // expr _loop0_10
            auto elem = elem = parse_expr_rule();
            if (elem) {
            auto seq = seq = parse__loop0_10_rule();
            if (seq) {
                // !!! DBG: emit_default_action(gather) locals: ['elem', 'seq']
                _res.push_back(std::move(seq));
                return _res;
            }
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // _loop0_11: stmt
    std::optional<std::vector<ast::stmt>> parse__loop0_11()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<std::vector<ast::stmt>> _res = std::nullopt;
        auto _state = tell();
        int _start_state = tell();
        std::vector<std::vector<ast::stmt>> _children{};
        size_t _n = 0;
        { // stmt
            while (true) {
                auto stmt_var = stmt_var = parse_stmt_rule();
                if (stmt_var) {
                    _res = stmt_var;
                    _children.push_back(_res);
                    _state = tell();
                    continue;
                }
                break;
            }
            seek(_state);
        }
        auto _seq = ast::make_sequence(std::move(_res));
        return _seq;
    }
    #else
    ;
    #endif

    // _tmp_12: 'or' conjunction_expr
    std::optional<ast::expr> parse__tmp_12()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // 'or' conjunction_expr
            auto _keyword = _keyword = lexer.expect().keyword(OR);
            if (_keyword) {
            auto c = c = parse_conjunction_expr_rule();
            if (c) {
                _res = c;
                return _res;
            }
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    // _tmp_13: 'and' inversion_expr
    std::optional<ast::expr> parse__tmp_13()
    #ifdef BONDREWD_PARSER_IMPL
    {
        std::optional<ast::expr> _res = std::nullopt;
        { // 'and' inversion_expr
            auto _keyword = _keyword = lexer.expect().keyword(AND);
            if (_keyword) {
            auto c = c = parse_inversion_expr_rule();
            if (c) {
                _res = c;
                return _res;
            }
            }
            seek(_state);
        }
        _res = std::nullopt;
        return _res;
    }
    #else
    ;
    #endif

    #pragma endregion Rule parsers

};
#pragma endregion Parser


}  // namespace bondrewd::parse
