# PEG grammar for the Bondrewd language

# TODO: add lookaheads and cuts where applicable; add `(memo)` to the most common rules
# TODO: Sequence helpers!
# TODO: Helpers to change expr_context. Then also add expr_context to the AST
# TODO: Empty rules cause issues with how left-recursion is handled. Fix it!
# TODO: Templates!

@subheader '''\
#include <string>
'''

@extras '''\
std::string _concat_strings(const std::vector<lex::Token> &strings) const {
    if (strings.empty()) {
        return "";
    }

    std::string result{};
    std::string_view quotes = "";
    bool first = true;

    for (auto &s: strings) {
        if (first) {
            quotes = s.get_string().quotes;
            first = false;
        }

        result += s.get_string().value;
        if (s.get_string().quotes != quotes) {
            // TODO: Custom error type!
            throw std::runtime_error("String literals must have the same quotes");
        }
    }

    return result;
}

template <typename T>
ast::maybe<T> _opt2maybe(std::optional<ast::field<T>> opt) {
    if (opt) {
        return std::move(*opt);
    } else {
        return nullptr;
    }
}
'''

# This means all ast::* types are automatically wrapped into ast::field<>
@wrap_ast_types

start: cartridge

#region cartridge
# TODO: Rework

cartridge[ast::cartridge]:
    | h=cartridge_header b=stmt* $  { ast::Cartridge(std::move(h), std::move(b)) }

cartridge_header[std::string]:
    | 'cartridge' n=name ';'  { std::move(n) }
#endregion cartridge

#region stmt
stmt[ast::stmt] (memo):
    | assign_stmt
    | expr_stmt
    | pass_stmt

assign_stmt[ast::stmt]:
    | a=expr op=assign_op b=expr ';'  { ast::Assign(std::move(a), std::move(b), std::move(op)) }

assign_op[ast::assign_op]:
    | '='    { ast::AsgnNone() }
    | '+='   { ast::AsgnAdd() }
    | '-='   { ast::AsgnSub() }
    | '*='   { ast::AsgnMul() }
    | '/='   { ast::AsgnDiv() }
    | '%='   { ast::AsgnMod() }
    | '<<='  { ast::AsgnLShift() }
    | '>>='  { ast::AsgnRShift() }
    | '&='   { ast::AsgnBitAnd() }
    | '|='   { ast::AsgnBitOr() }
    | '^='   { ast::AsgnBitXor() }

expr_stmt[ast::stmt]:
    | a=expr ';'  { ast::Expr(std::move(a)) }

pass_stmt[ast::stmt]:
    | ';'  { ast::Pass() }
#endregion stmt

#region defn
defn[ast::defn] (memo):
    | 'ctime' a=raw_defn  { ({ a->flag = ast::CTime(); a; }) }
    | 'rtime' a=raw_defn  { ({ a->flag = ast::RTime(); a; }) }
    | raw_defn

raw_defn[ast::defn]:
    | var_def
    | func_def
    | impl_def
    # | struct_def
    # | ns_def

type_annotation[ast::expr]:
    | ':' a=expr  { std::move(a) }

var_def[ast::defn]:
    | 'var' n=name t=type_annotation? v=['=' a=expr { a }] ';'  { ast::VarDef(std::move(n), _opt2maybe(std::move(t)), _opt2maybe(std::move(v)), true) }

func_def[ast::defn]:  # TODO: Allow only block_expr?
    | 'func' n=name? a=args_spec t=type_annotation? '=>' b=expr  { ast::FuncDef(_opt2maybe(std::move(n)), std::move(a), _opt2maybe(std::move(t)), std::move(b)) }

# TODO: *args, **kwargs - or templated that, perhaps?
# TODO: support for explicit argspec objects, if necessary
args_spec[ast::args_spec]:
    | '(' a=args_spec_nonempty ','? ')'  { std::move(a) }
    | '(' ')'  { ast::args_spec(ast::make_sequence<ast::arg_def>(), false) }

args_spec_nonempty[ast::args_spec]:
    | "self" ',' a=','.arg_spec+  { ast::args_spec(std::move(a), true) }
    | "self"  { ast::args_spec(ast::make_sequence<ast::arg_def>(), true) }
    | a=','.arg_spec+  { ast::args_spec(std::move(a), false) }

# TODO: unused and fixed args?
arg_spec[ast::arg_spec]:
    | n=name t=type_annotation d=('=' expr)?  { ast::arg_spec(std::move(n), std::move(t), _opt2maybe(std::move(d))) }

defn_block[ast::sequence<ast::stmt>]:
    | '{' b=stmt* '}'  { std::move(b) }

# TODO: Allow 'namespace' as an alternative to 'impl'?
impl_def[ast::defn]:
    | 'impl' c=expr b=defn_block  { ast::ImplDef(std::move(c), std::nullopt, std::move(b)) }
    | 'impl' t=expr 'for' c=expr b=defn_block  { ast::ImplDef(std::move(c), std::move(t), std::move(b)) }

# TODO: Forbid 'class' here?
struct_def[ast::defn]:
    | ('class' | 'struct') n=name? a=args_spec  { ast::StructDef(_opt2maybe(std::move(n)), std::move(a)) }

# TODO: ?
#     | 'namespace' n=name b=defn_block
#endregion defn

#region flow
flow[ast::flow] (memo):
    | 'ctime' a=raw_flow  { ({ a->flag = ast::CTime(); a; }) }
    | 'rtime' a=raw_flow  { ({ a->flag = ast::RTime(); a; }) }
    | raw_flow

raw_flow[ast::flow]:
    | if_flow
    | for_flow
    | while_flow
    | loop_flow

if_flow[ast::flow]:
    | 'if' c=expr t=flow_block e=('else' flow_block)?  { ast::If(std::move(c), std::move(t), _opt2maybe(std::move(e))) }

for_flow[ast::flow]:
    | 'for' v=name 'in' s=expr b=flow_block e=('else' flow_block)?  { ast::For(std::move(v), std::move(s), std::move(b), _opt2maybe(std::move(e))) }

while_flow[ast::flow]:
    | 'while' c=expr b=flow_block e=('else' flow_block)?  { ast::While(std::move(c), std::move(b), _opt2maybe(std::move(e))) }

loop_flow[ast::flow]:
    | 'loop' b=flow_block  { ast::Loop(std::move(b)) }

flow_block[ast::expr]:
    | block_expr
    | flow_expr
    | return_expr
    | break_expr
    | continue_expr
#endregion flow

#region expr
expr_or_unit[ast::expr]:
    | expr
    | { ast::Constant(std::monostate()) }  # TODO: Implement Unit!

# TODO: Support constants!
expr[ast::expr] (memo):
    | defn_expr
    | flow_expr
    | return_expr
    | break_expr
    | continue_expr
    | expr_0

#region wrapped
defn_expr[ast::expr]:
    | a=defn  { ast::Defn(std::move(a)) }

flow_expr[ast::expr]:
    | a=flow  { ast::Flow(std::move(a)) }
#endregion wrapped

#region flow_ops
return_expr[ast::expr]:
    | 'return' a=expr_or_unit  { ast::Return(std::move(a)) }

break_expr[ast::expr]:
    | 'break' a=expr_or_unit  { ast::Break(std::move(a)) }

continue_expr[ast::expr]:
    | 'continue'  { ast::Continue() }
#endregion flow_ops

#region operators
#region expr_0
expr_0[ast::expr] (memo):
    | and_expr
    | or_expr
    | expr_1

and_expr[ast::expr]:
    | a=expr_2 b=('and' expr_1)+  { ast::BoolOp(ast::And(), _prepend1(a, b)) }

or_expr[ast::expr]:
    | a=expr_2 b=('or' expr_1)+  { ast::BoolOp(ast::Or(), _prepend1(a, b)) }
#endregion expr_0

#region expr_1
expr_1[ast::expr]:
    | not_expr
    | expr_2

not_expr[ast::expr]:
    | 'not' a=expr_1  { ast::UnaryOp(ast::Not(), std::move(a)) }
#endregion expr_1

#region expr_2
expr_2[ast::expr]:
    | comparison_expr
    | bidir_cmp_expr
    | expr_3

comparison_expr[ast::expr]:  # TODO: Extract from sequence somehow (without a 1000-char rule, preferably)
    | f=expr_3 n=comparison_followup_pair+  { ast::Compare(
        std::move(f),
        ast::make_sequence<ast::cmp_op>(),
        ast::make_sequence<ast::expr>()) 
    }

comparison_followup_pair[std::pair<ast::field<ast::cmp_op>, ast::field<ast::expr>>]:
    | o=comparison_op a=expr_3  { std::make_pair(std::move(o), std::move(a)) }

comparison_op[ast::cmp_op]:
    | '=='  { ast::Eq() }
    | '!='  { ast::NotEq() }
    | '<'   { ast::Lt() }
    | '<='  { ast::LtE() }
    | '>'   { ast::Gt() }
    | '>='  { ast::GtE() }
    | 'in'  { ast::In() }
    | 'not' 'in'  { ast::NotIn() }

bidir_cmp_expr[ast::expr]:
    | a=expr_3 '<=>' b=expr_3  { ast::BinOp(ast::BidirCmp(), std::move(a), std::move(b)) }
#endregion expr_2

#region expr_3
expr_3[ast::expr]:
    | arithm_expr
    | bitwise_expr
    | expr_4

arithm_expr[ast::expr]:
    | sum_expr
    | product_expr

sum_expr[ast::expr]:
    | a=(sum_expr | product_expr) '+' b=product_expr  { ast::BinOp(ast::Add(), std::move(a), std::move(b)) }
    | a=(sum_expr | product_expr) '-' b=product_expr  { ast::BinOp(ast::Sub(), std::move(a), std::move(b)) }

product_expr[ast::expr]:
    | a=(product_expr | expr_4) '*' b=expr_4  { ast::BinOp(ast::Mul(), std::move(a), std::move(b)) }
    | a=(product_expr | expr_4) '/' b=expr_4  { ast::BinOp(ast::Div(), std::move(a), std::move(b)) }
    | a=(product_expr | expr_4) '%' b=expr_4  { ast::BinOp(ast::Mod(), std::move(a), std::move(b)) }

bitwise_expr[ast::expr]:
    | bitor_expr
    | bitand_expr
    | bitxor_expr
    | shift_expr

bitor_expr[ast::expr]:
    | a=(bitor_expr | expr_4) '|' b=expr_4  { ast::BinOp(ast::BitOr(), std::move(a), std::move(b)) }

bitand_expr[ast::expr]:
    | a=(bitand_expr | expr_4) '&' b=expr_4  { ast::BinOp(ast::BitAnd(), std::move(a), std::move(b)) }

bitxor_expr[ast::expr]:
    | a=(bitxor_expr | expr_4) '^' b=expr_4  { ast::BinOp(ast::BitXor(), std::move(a), std::move(b)) }

shift_expr[ast::expr]:
    | a=(shift_expr | expr_4) '<<' b=expr_4  { ast::BinOp(ast::LShift(), std::move(a), std::move(b)) }
    | a=(shift_expr | expr_4) '>>' b=expr_4  { ast::BinOp(ast::RShift(), std::move(a), std::move(b)) }
#endregion expr_3

#region expr_4
expr_4[ast::expr] (memo):
    | unary_expr
    | power_expr
    | expr_5

unary_expr[ast::expr]:
    | '+' a=(unary_expr | expr_5)  { ast::UnOp(ast::UAdd(), std::move(a)) }
    | '-' a=(unary_expr | expr_5)  { ast::UnOp(ast::USub(), std::move(a)) }
    | '~' a=(unary_expr | expr_5)  { ast::UnOp(ast::BitInv(), std::move(a)) }
    | '&' a=(unary_expr | expr_5)  { ast::UnOp(ast::URef(), std::move(a)) }
    | '*' a=(unary_expr | expr_5)  { ast::UnOp(ast::UStar(), std::move(a)) }

power_expr[ast::expr]:
    | a=expr_5 '**' b=expr_5  { ast::BinOp(ast::Pow(), std::move(a), std::move(b)) }
#endregion expr_4

#region expr_5
expr_5[ast::expr]:
    | attr_expr
    | call_expr
    | subscript_expr
    | expr_6

attr_expr[ast::expr]:
    | a=expr_5 '.' b=NAME  { ast::Attribute(std::move(a), std::move(b), ast::AttrInst()) }
    | a=expr_5 '::' b=NAME  { ast::Attribute(std::move(a), std::move(b), ast::AttrStatic()) }

call_expr[ast::expr]:
    | a=expr_5 '(' b=call_args ')'  { ast::Call(std::move(a), std::move(b)) }

subscript_expr[ast::expr]:
    | a=expr_5 '[' b=call_args ']'  { ast::Subscript(std::move(a), std::move(b)) }

# TODO: Actually implement
call_args[ast::call_args] (memo):
    | { ast::call_args(ast::make_sequence<ast::call_arg>(), nullptr, nullptr) }
#endregion expr_5

#region expr_6
expr_6[ast::expr]:
    | primary_expr
#endregion expr_6
#endregion operators

#region primary_expr
primary_expr[ast::expr]:
    | a=name  { ast::Name(std::move(a)) }
    | a=NUMBER  { ast::Constant(util::variant_cast(a.get_number().value)) }
    | &STRING a=strings  { ast::Constant(std::move(a)) }
    | '...'  { ast::Ellipsis() }
    | group_expr
    | tuple_expr
    | array_expr
    | ctime_block_expr
    | block_expr

name[std::string]:
    | a=NAME  { a.get_name().value }

# TODO: _concat_strings!
strings[std::string] (memo):
    | a=STRING+  { _concat_strings(a) }

group_expr[ast::expr]:
    | '(' expr ')'

tuple_expr[ast::expr]:
    | '(' ')'  { ast::Tuple(ast::make_sequence<ast::expr>()) }
    | '(' a=','.expr+ ','? ')'  { ast::Tuple(std::move(a)) }

array_expr[ast::expr]:
    | '[' ']'  { ast::Array(ast::make_sequence<ast::expr>()) }
    | '[' a=','.expr+ ','? ']'  { ast::Array(std::move(a)) }

ctime_block_expr[ast::expr]:
    | 'ctime' b=block_expr  { ast::CtimeBlock(std::move(b)) }

block_expr[ast::expr] (memo):
    | '{' b=stmt* v=expr_or_unit '}'  { ast::Block(std::move(b), std::move(v)) }
#endregion primary_expr
#endregion expr

# TODO: Finish!
