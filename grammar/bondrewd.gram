# PEG grammar for the Bondrewd language

# TODO: add lookaheads and cuts where applicable; add `(memo)` to the most common rules
# TODO: Fixup operator-related rules!
# TODO: Sequence helpers!
# TODO: Force parentheses around some operators (like bitwise)?
# TODO: Helpers to change expr_context. Then also add expr_context to the AST
# TODO: Automatically add { std::move(a) } to all rules with a single non-terminal

@subheader '''\
#include <algorithm>
'''

start['ast::cartridge']:
    | a=cartridge  { std::move(a) }

cartridge['ast::cartridge']:
    | h=cartridge_header b=(global_only_stmt | stmt)*  { ast::Cartridge(std::move(h), std::move(b)) }

cartridge_header['std::string']:
    | 'cartridge' n=name ';'  { std::move(n) }

global_only_stmt['ast::stmt']:
    | class_def
    | impl_def

stmt['ast::stmt']:
    | var_def_stmt
    | func_def_stmt
    | assign_stmt
    | expr_stmt
    | ';'  { ast::Pass() }

expr_stmt['ast::stmt']:
    | a=expr ';'  { ast::Expr(std::move(a)) }

# TODO: Support constants!
expr['ast::expr']:
    | a=NAME  { ast::Name(a.get_name().value) }
    | a=NUMBER  { ast::Constant(a.get_number().value) }
    | a=STRING  { ast::Constant(a.get_string().value) }  # TODO: Account for quote type!
    | block
    | if_expr
    | for_expr
    | while_expr
    | 'return' a=expr_or_unit  { ast::Return(std::move(a)) }
    | 'break' a=expr_or_unit  { ast::Break(std::move(a)) }
    | call
    | disjunction_expr

expr_or_unit['ast::expr']:
    | expr
    | { ast::Constant(std::monostate()) }  # TODO: Implement Unit!

disjunction_expr['ast::expr']:
    | a=conjunction_expr b=('or' c=conjunction_expr { c })+  { ast::BoolOp(ast::Or(), ...) }
    | conjunction_expr

conjunction_expr['ast::expr']:
    | a=inversion_expr b=('and' c=inversion_expr { c })+  { ast::BoolOp(ast::And(), ...) }
    | inversion_expr

inversion_expr['ast::expr']:
    | 'not' a=inversion_expr  { ast::UnaryOp(ast::Not(), std::move(a)) }
    | comparison_expr

comparison_expr['ast::expr']:  # TODO: Extract from sequence somehow (without a 1000-char rule, preferably)
    | a=bidir_cmp_expr b=comparison_followup_pair+  { ast::Compare(std::move(a), make_sequence(...), make_sequence(...)) }
    | bidir_cmp_expr

# TODO: comparison_followup_pair['?']:

# This one doesn't allow chaining, since it would've made no sense. Use parentheses if you really need it.
bidir_cmp_expr['ast::expr']:
    | a=bitor_expr '<=>' b=bitor_expr  { ast::Compare(std::move(a), std::move(b)) }
    | bitor_expr

bitor_expr['ast::expr']:
    | a=bitor_expr '|' b=bitxor_expr  { ast::BinOp(ast::BitOr(), std::move(a), std::move(b)) }
    | bitxor_expr

bitxor_expr['ast::expr']:
    | a=bitxor_expr '&' b=bitand_expr  { ast::BinOp(ast::BitXor(), std::move(a), std::move(b)) }
    | bitand_expr

bitand_expr['ast::expr']:
    | a=bitand_expr '&' b=shift_expr  { ast::BinOp(ast::BitAnd(), std::move(a), std::move(b)) }
    | shift_expr

shift_expr['ast::expr']:
    | a=shift_expr '<<' b=sum_expr  { ast::BinOp(ast::LShift(), std::move(a), std::move(b)) }
    | a=shift_expr '>>' b=sum_expr  { ast::BinOp(ast::RShift(), std::move(a), std::move(b)) }
    | sum_expr

sum_expr['ast::expr']:
    | a=sum_expr '+' b=term_expr  { ast::BinOp(ast::Add(), std::move(a), std::move(b)) }
    | a=sum_expr '-' b=term_expr  { ast::BinOp(ast::Sub(), std::move(a), std::move(b)) }
    | term_expr

term_expr['ast::expr']:
    | a=term_expr '*' b=factor_expr  { ast::BinOp(ast::Mul(), std::move(a), std::move(b)) }
    | a=term_expr '/' b=factor_expr  { ast::BinOp(ast::Div(), std::move(a), std::move(b)) }
    | a=term_expr '%' b=factor_expr  { ast::BinOp(ast::Mod(), std::move(a), std::move(b)) }
    | factor_expr

factor_expr['ast::expr']:
    | '+' a=factor_expr  { ast::UnaryOp(ast::UAdd(), std::move(a)) }
    | '-' a=factor_expr  { ast::UnaryOp(ast::USub(), std::move(a)) }
    | '~' a=factor_expr  { ast::UnaryOp(ast::BitInv(), std::move(a)) }
    | power_expr

power_expr['ast::expr']:
    | a=primary_expr '**' b=factor_expr  { ast::BinOp(ast::Pow(), std::move(a), std::move(b)) }
    | primary_expr

primary_expr['ast::expr']:
    | a=primary_expr '.' b=NAME  { ast::Attribute(std::move(a), b.get_name().value, ast::AttrInst()) }
    | a=primary_expr '::' b=NAME  { ast::Attribute(std::move(a), b.get_name().value, ast::AttrStatic()) }
    | a=primary_expr '[' b=expr ']'  { ast::Subscript(std::move(a), std::move(b)) }
    | a=primary_expr '(' b=call_args ')'  { ast::Call(std::move(a), std::move(b)) }
    | atom_expr

# TODO: call_args['ast::call_args']

atom_expr['ast::expr']:
    | a=NAME  { ast::Name(a.get_name().value) }
    | a=NUMBER  { ast::Constant(a.get_number().value) }
    | &STRING a=strings  { std::move(a) }
    | group_expr
    | tuple_expr
    | block_expr

group_expr['ast::expr']:
    | '(' a=expr ')'  { std::move(a) }

tuple_expr['ast::expr']:
    | '(' ')'  { ast::Tuple(make_sequence()) }
    | '(' a=','.expr+ ','? ')'  { ast::Tuple(std::move(a)) }

block_expr['ast::expr']:
    | c='ctime'? '{' b=stmt* v=expr_or_unit '}'  { ast::Block(std::move(b), std::move(v), bool(c)) }

type_annotation['ast::expr']:
    | ':' a=expr  { std::move(a) }

var_def_stmt['ast::stmt']:
    | c='ctime'? 'var' n=NAME t=type_annotation? v=['=' a=expr { a }] ';'  { ast::VarDef(n.get_name().value, std::move(t), std::move(v), true, bool(c)) }

func_def_stmt['ast::stmt']:
    | 'def' n=NAME '(' a=func_args_def ')' t=['->' a=expr { a }] '=>' b=expr ';'  { ast::FuncDef(n.get_name().value, std::move(a), std::move(t), std::move(b)) }

assign_stmt['ast::stmt']:
    | a=expr o=assign_op b=expr ';'  { ast::Assign(std::move(a), std::move(b), std::move(op)) }

assign_op['ast::assign_op']"
    | '='  { ast::AsgnNone() }
    | '+='  { ast::AsgnAdd() }
    | '-='  { ast::AsgnSub() }
    | '*='  { ast::AsgnMul() }
    | '/='  { ast::AsgnDiv() }
    | '%='  { ast::AsgnMod() }
    | '<<='  { ast::AsgnLShift() }
    | '>>='  { ast::AsgnRShift() }
    | '&='  { ast::AsgnBitAnd() }
    | '|='  { ast::AsgnBitOr() }
    | '^='  { ast::AsgnBitXor() }

# TODO: Finish!
