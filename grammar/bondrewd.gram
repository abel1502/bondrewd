# PEG grammar for the Bondrewd language

# TODO: add lookaheads and cuts where applicable; add `(memo)` to the most common rules
# TODO: Fixup operator-related rules!
# TODO: Sequence helpers!
# TODO: Force parentheses around some operators (like bitwise)?
# TODO: Helpers to change expr_context. Then also add expr_context to the AST
# TODO: Automatically add { std::move(a) } to all rules with a single non-terminal
# TODO: Explicitly specify ast::nodes::?

@subheader '''\
#include <string>
'''

# This means all ast::* types are automatically wrapped into ast::field<>
@wrap_ast_types

# This means that actions prefixed with _field_, _sequence_ and _maybe_ are wrapped in their corresponding ast::make_*<>() functions
@wrap_make_field

start[ast::cartridge]:  cartridge

#region cartridge
cartridge[ast::cartridge]:
    | h=cartridge_header b=stmt*  { _field_ ast::Cartridge(std::move(h), std::move(b)) }

cartridge_header[std::string]:
    | 'cartridge' n=name ';'  { std::move(n) }
#endregion cartridge

#region stmt
stmt[ast::stmt]:
    | var_def_stmt
    | impl_stmt
    | assign_stmt
    | expr_stmt
    | ';'  { _field_ ast::Pass() }

assign_stmt[ast::stmt]:
    | a=expr op=assign_op b=expr ';'  { _field_ ast::Assign(std::move(a), std::move(b), std::move(op)) }

assign_op[ast::assign_op]:
    | '='    { _field_ ast::AsgnNone() }
    | '+='   { _field_ ast::AsgnAdd() }
    | '-='   { _field_ ast::AsgnSub() }
    | '*='   { _field_ ast::AsgnMul() }
    | '/='   { _field_ ast::AsgnDiv() }
    | '%='   { _field_ ast::AsgnMod() }
    | '<<='  { _field_ ast::AsgnLShift() }
    | '>>='  { _field_ ast::AsgnRShift() }
    | '&='   { _field_ ast::AsgnBitAnd() }
    | '|='   { _field_ ast::AsgnBitOr() }
    | '^='   { _field_ ast::AsgnBitXor() }

var_def_stmt[ast::stmt]:
    | c='ctime'? 'var' n=name t=type_annotation? v=['=' a=expr { a }] ';'  { _field_ ast::VarDef(std::move(n), std::move(t), std::move(v), true, bool(c)) }

# TODO: Decide on the body contents
impl_stmt[ast::stmt]:
    # | c='ctime'? 'impl' c=name '{' d=tmp_definition* '}' ';'
#endregion stmt

#region expr
expr_stmt[ast::stmt]:
    | a=expr ';'  { _field_ ast::Expr(std::move(a)) }

# TODO: Support constants!
expr[ast::expr]:
    | func_def
    | class_def
    | block_expr
    # | if_expr
    # | for_expr
    # | while_expr
    | 'return' a=expr_or_unit  { _field_ ast::Return(std::move(a)) }
    | 'break' a=expr_or_unit  { _field_ ast::Break(std::move(a)) }
    | disjunction_expr

expr_or_unit[ast::expr]:
    | expr
    | { _field_ ast::Constant(std::monostate()) }  # TODO: Implement Unit!

#region operators
#region logical
disjunction_expr[ast::expr]:
    | a=conjunction_expr b=('or' c=conjunction_expr { c })+  { _field_ ast::BoolOp(ast::Or(), ...) }
    | conjunction_expr

conjunction_expr[ast::expr]:
    | a=inversion_expr b=('and' c=inversion_expr { c })+  { _field_ ast::BoolOp(ast::And(), ...) }
    | inversion_expr

inversion_expr[ast::expr]:
    | 'not' a=inversion_expr  { _field_ ast::UnOp(ast::Not(), std::move(a)) }
    | comparison_expr
#endregion logical

#region comparison
comparison_expr[ast::expr]:  # TODO: Extract from sequence somehow (without a 1000-char rule, preferably)
    | a=bidir_cmp_expr b=comparison_followup_pair+  { _field_ ast::Compare(std::move(a), ast::make_sequence(...), ast::make_sequence(...)) }
    | bidir_cmp_expr

comparison_followup_pair[std::pair<ast::cmp_op, ast::expr>]:
    | o=comparison_op a=bidir_cmp_expr  { std::make_pair(std::move(o), std::move(a)) }

comparison_op[ast::cmp_op]:
    | '=='  { _field_ ast::Eq() }
    | '!='  { _field_ ast::NotEq() }
    | '<'   { _field_ ast::Lt() }
    | '<='  { _field_ ast::LtE() }
    | '>'   { _field_ ast::Gt() }
    | '>='  { _field_ ast::GtE() }
    | 'in'  { _field_ ast::In() }
    | 'not' 'in'  { _field_ ast::NotIn() }

# This one doesn't allow chaining, since it would've made no sense. Use parentheses if you really need it.
bidir_cmp_expr[ast::expr]:
    | a=bitor_expr '<=>' b=bitor_expr  { _field_ ast::Compare(std::move(a), std::move(b)) }
    | bitor_expr
#endregion comparison

#region bitwise
bitor_expr[ast::expr]:
    | a=bitor_expr '|' b=bitxor_expr  { _field_ ast::BinOp(ast::BitOr(), std::move(a), std::move(b)) }
    | bitxor_expr

bitxor_expr[ast::expr]:
    | a=bitxor_expr '^' b=bitand_expr  { _field_ ast::BinOp(ast::BitXor(), std::move(a), std::move(b)) }
    | bitand_expr

bitand_expr[ast::expr]:
    | a=bitand_expr '&' b=shift_expr  { _field_ ast::BinOp(ast::BitAnd(), std::move(a), std::move(b)) }
    | shift_expr

shift_expr[ast::expr]:
    | a=shift_expr '<<' b=sum_expr  { _field_ ast::BinOp(ast::LShift(), std::move(a), std::move(b)) }
    | a=shift_expr '>>' b=sum_expr  { _field_ ast::BinOp(ast::RShift(), std::move(a), std::move(b)) }
    | sum_expr
#endregion bitwise

#region arithmetic
sum_expr[ast::expr]:
    | a=sum_expr '+' b=term_expr  { _field_ ast::BinOp(ast::Add(), std::move(a), std::move(b)) }
    | a=sum_expr '-' b=term_expr  { _field_ ast::BinOp(ast::Sub(), std::move(a), std::move(b)) }
    | term_expr

term_expr[ast::expr]:
    | a=term_expr '*' b=factor_expr  { _field_ ast::BinOp(ast::Mul(), std::move(a), std::move(b)) }
    | a=term_expr '/' b=factor_expr  { _field_ ast::BinOp(ast::Div(), std::move(a), std::move(b)) }
    | a=term_expr '%' b=factor_expr  { _field_ ast::BinOp(ast::Mod(), std::move(a), std::move(b)) }
    | factor_expr
#endregion arithmetic

#region unary
factor_expr[ast::expr]:
    | '+' a=factor_expr  { _field_ ast::UnOp(ast::UAdd(), std::move(a)) }
    | '-' a=factor_expr  { _field_ ast::UnOp(ast::USub(), std::move(a)) }
    | '~' a=factor_expr  { _field_ ast::UnOp(ast::BitInv(), std::move(a)) }
    | power_expr
#endregion unary

#region power
power_expr[ast::expr]:
    | a=primary_expr '**' b=factor_expr  { _field_ ast::BinOp(ast::Pow(), std::move(a), std::move(b)) }
    | primary_expr
#endregion power
#endregion operators

primary_expr[ast::expr]:
    | a=primary_expr '.' b=name  { _field_ ast::Attribute(std::move(a), std::move(b), ast::AttrInst()) }
    | a=primary_expr '::' b=name  { _field_ ast::Attribute(std::move(a), std::move(b), ast::AttrStatic()) }
    | a=primary_expr '[' b=call_args ']'  { _field_ ast::Subscript(std::move(a), std::move(b)) }
    | a=primary_expr '(' b=call_args ')'  { _field_ ast::Call(std::move(a), std::move(b)) }
    | atom_expr

atom_expr[ast::expr]:
    | a=name  { _field_ ast::Name(std::move(a)) }
    | a=NUMBER  { _field_ ast::Constant(a.get_number().value) }
    | &STRING a=strings  { _field_ std::move(a) }
    | group_expr
    | tuple_expr
    | array_expr
    | block_expr

# TODO: Actually implement
call_args[ast::call_args]:
    | { _field_ ast::call_args(ast::make_sequence(), nullptr, nullptr) }

name[std::string]:
    | a=NAME  { a.get_name().value }

# TODO: _concat_strings!
strings[std::string]:
    | a=STRING+  { _concat_strings(a) }

group_expr[ast::expr]:
    | '(' a=expr ')'  { std::move(a) }

tuple_expr[ast::expr]:
    | '(' ')'  { _field_ ast::Tuple(ast::make_sequence()) }
    | '(' a=','.expr+ ','? ')'  { _field_ ast::Tuple(std::move(a)) }

array_expr[ast::expr]:
    | '[' ']'  { _field_ ast::Array(ast::make_sequence()) }
    | '[' a=','.expr+ ','? ']'  { _field_ ast::Array(std::move(a)) }

block_expr[ast::expr]:
    | c='ctime'? '{' b=stmt* v=expr_or_unit '}'  { _field_ ast::Block(std::move(b), std::move(v), bool(c)) }

type_annotation[ast::expr]:
    | ':' a=expr  { std::move(a) }

func_def[ast::expr]:
    | 'func' n=name '(' a=func_args_def ')' t=type_annotation? '=>' b=expr ';'  { _field_ ast::FuncDef(std::move(n), std::move(a), std::move(t), std::move(b)) }

# TODO
func_args_def[ast::arg_defs]:
    | { _field_ ast::arg_defs(ast::make_sequence()) }

# TODO
class_def[ast::expr]:
    | c='ctime'? 'class' n=name '(' a=func_args_def ')' ';'
#endregion expr

# TODO: Finish!
