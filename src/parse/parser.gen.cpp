// AUTOGENERATED by bondrewd/tools/pegen++/pegenxx.py on 2023-04-06 22:36:06
// DO NOT EDIT

#include <bondrewd/parse/parser.gen.hpp>


#if 1
#define PARSER_DBG_(...)  fprintf(stderr, "[Parser] " __VA_ARGS__)
#else
#define PARSER_DBG_(...)
#endif


namespace bondrewd::parse {


#pragma region Rule parsers

// start: cartridge
std::optional<ast::field<ast::cartridge>> Parser::parse_start_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::cartridge>> _res = std::nullopt;
    { // cartridge
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "start", _state, tell(), "cartridge");
        auto _single_result = parse_cartridge_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "start", _state, tell(), "cartridge");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "cartridge");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "start", _state, tell(), "cartridge");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "start");
    --_level;
    return std::nullopt;
}

// cartridge: cartridge_header stmt* $
std::optional<ast::field<ast::cartridge>> Parser::parse_cartridge_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::cartridge>> _res = std::nullopt;
    { // cartridge_header stmt* $
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "cartridge", _state, tell(), "cartridge_header stmt* $");
        auto _user_opt_h = parse_cartridge_header_rule();
        if (_user_opt_h) { auto h = std::move(*_user_opt_h);
        auto _user_opt_b = parse__loop0_1_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _token = lexer.expect().token(lex::TokenType::endmarker);
        if (_token) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "cartridge", _state, tell(), "cartridge_header stmt* $");
            _res = ast::Cartridge ( std::move ( h ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "cartridge_header stmt* $");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "cartridge", _state, tell(), "cartridge_header stmt* $");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "cartridge");
    --_level;
    return std::nullopt;
}

// cartridge_header: 'cartridge' name ';'
std::optional<std::string> Parser::parse_cartridge_header_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<std::string> _res = std::nullopt;
    { // 'cartridge' name ';'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "cartridge_header", _state, tell(), "'cartridge' name ';'");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::CARTRIDGE);
        if (_keyword) {
        auto _user_opt_n = parse_name_rule();
        if (_user_opt_n) { auto n = std::move(*_user_opt_n);
        auto _literal = lexer.expect().punct(lex::Punct::SEMI);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "cartridge_header", _state, tell(), "'cartridge' name ';'");
            _res = std::move ( n );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'cartridge' name ';'");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "cartridge_header", _state, tell(), "'cartridge' name ';'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "cartridge_header");
    --_level;
    return std::nullopt;
}

// stmt: assign_stmt | expr_stmt | pass_stmt
std::optional<ast::field<ast::stmt>> Parser::parse_stmt_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::stmt>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    { // assign_stmt
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "stmt", _state, tell(), "assign_stmt");
        auto _single_result = parse_assign_stmt_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "stmt", _state, tell(), "assign_stmt");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "assign_stmt");
            --_level;
            store_cached<RuleType::stmt>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "stmt", _state, tell(), "assign_stmt");
    }
    { // expr_stmt
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "stmt", _state, tell(), "expr_stmt");
        auto _single_result = parse_expr_stmt_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "stmt", _state, tell(), "expr_stmt");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_stmt");
            --_level;
            store_cached<RuleType::stmt>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "stmt", _state, tell(), "expr_stmt");
    }
    { // pass_stmt
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "stmt", _state, tell(), "pass_stmt");
        auto _single_result = parse_pass_stmt_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "stmt", _state, tell(), "pass_stmt");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "pass_stmt");
            --_level;
            store_cached<RuleType::stmt>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "stmt", _state, tell(), "pass_stmt");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "stmt");
    --_level;
    store_cached<RuleType::stmt>(_state, std::nullopt);
    return std::nullopt;
}

// assign_stmt: expr assign_op expr ';'
std::optional<ast::field<ast::stmt>> Parser::parse_assign_stmt_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    { // expr assign_op expr ';'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_stmt", _state, tell(), "expr assign_op expr ';'");
        auto _user_opt_a = parse_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _user_opt_op = parse_assign_op_rule();
        if (_user_opt_op) { auto op = std::move(*_user_opt_op);
        auto _user_opt_b = parse_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _literal = lexer.expect().punct(lex::Punct::SEMI);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_stmt", _state, tell(), "expr assign_op expr ';'");
            _res = ast::Assign ( std::move ( a ) , std::move ( b ) , std::move ( op ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr assign_op expr ';'");
            --_level;
            return _res;
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_stmt", _state, tell(), "expr assign_op expr ';'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "assign_stmt");
    --_level;
    return std::nullopt;
}

// assign_op: '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '|=' | '^='
std::optional<ast::field<ast::assign_op>> Parser::parse_assign_op_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::assign_op>> _res = std::nullopt;
    { // '='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'='");
        auto _literal = lexer.expect().punct(lex::Punct::EQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'='");
            _res = ast::AsgnNone ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'='");
    }
    { // '+='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'+='");
        auto _literal = lexer.expect().punct(lex::Punct::PLUSEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'+='");
            _res = ast::AsgnAdd ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'+='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'+='");
    }
    { // '-='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'-='");
        auto _literal = lexer.expect().punct(lex::Punct::MINEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'-='");
            _res = ast::AsgnSub ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'-='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'-='");
    }
    { // '*='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'*='");
        auto _literal = lexer.expect().punct(lex::Punct::STAREQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'*='");
            _res = ast::AsgnMul ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'*='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'*='");
    }
    { // '/='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'/='");
        auto _literal = lexer.expect().punct(lex::Punct::SLASHEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'/='");
            _res = ast::AsgnDiv ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'/='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'/='");
    }
    { // '%='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'%='");
        auto _literal = lexer.expect().punct(lex::Punct::PERCENTEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'%='");
            _res = ast::AsgnMod ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'%='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'%='");
    }
    { // '<<='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'<<='");
        auto _literal = lexer.expect().punct(lex::Punct::LEFTSHIFTEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'<<='");
            _res = ast::AsgnLShift ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'<<='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'<<='");
    }
    { // '>>='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'>>='");
        auto _literal = lexer.expect().punct(lex::Punct::RIGHTSHIFTEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'>>='");
            _res = ast::AsgnRShift ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'>>='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'>>='");
    }
    { // '&='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'&='");
        auto _literal = lexer.expect().punct(lex::Punct::AMPEREQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'&='");
            _res = ast::AsgnBitAnd ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'&='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'&='");
    }
    { // '|='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'|='");
        auto _literal = lexer.expect().punct(lex::Punct::VBAREQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'|='");
            _res = ast::AsgnBitOr ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'|='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'|='");
    }
    { // '^='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'^='");
        auto _literal = lexer.expect().punct(lex::Punct::CIRCUMFLEXEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'^='");
            _res = ast::AsgnBitXor ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'^='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'^='");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "assign_op");
    --_level;
    return std::nullopt;
}

// expr_stmt: expr ';'
std::optional<ast::field<ast::stmt>> Parser::parse_expr_stmt_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    { // expr ';'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_stmt", _state, tell(), "expr ';'");
        auto _user_opt_a = parse_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::SEMI);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_stmt", _state, tell(), "expr ';'");
            _res = ast::Expr ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr ';'");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_stmt", _state, tell(), "expr ';'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expr_stmt");
    --_level;
    return std::nullopt;
}

// pass_stmt: ';'
std::optional<ast::field<ast::stmt>> Parser::parse_pass_stmt_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    { // ';'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "pass_stmt", _state, tell(), "';'");
        auto _literal = lexer.expect().punct(lex::Punct::SEMI);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "pass_stmt", _state, tell(), "';'");
            _res = ast::Pass ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "';'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "pass_stmt", _state, tell(), "';'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "pass_stmt");
    --_level;
    return std::nullopt;
}

// defn: 'ctime' raw_defn | 'rtime' raw_defn | raw_defn
std::optional<ast::field<ast::defn>> Parser::parse_defn_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::defn>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::defn>> _res = std::nullopt;
    { // 'ctime' raw_defn
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "defn", _state, tell(), "'ctime' raw_defn");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::CTIME);
        if (_keyword) {
        auto _user_opt_a = parse_raw_defn_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "defn", _state, tell(), "'ctime' raw_defn");
            _res = ( {a -> flag = ast::CTime ( ) ; a ;} );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'ctime' raw_defn");
            --_level;
            store_cached<RuleType::defn>(_state, _res);
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "defn", _state, tell(), "'ctime' raw_defn");
    }
    { // 'rtime' raw_defn
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "defn", _state, tell(), "'rtime' raw_defn");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::RTIME);
        if (_keyword) {
        auto _user_opt_a = parse_raw_defn_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "defn", _state, tell(), "'rtime' raw_defn");
            _res = ( {a -> flag = ast::RTime ( ) ; a ;} );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'rtime' raw_defn");
            --_level;
            store_cached<RuleType::defn>(_state, _res);
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "defn", _state, tell(), "'rtime' raw_defn");
    }
    { // raw_defn
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "defn", _state, tell(), "raw_defn");
        auto _single_result = parse_raw_defn_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "defn", _state, tell(), "raw_defn");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "raw_defn");
            --_level;
            store_cached<RuleType::defn>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "defn", _state, tell(), "raw_defn");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "defn");
    --_level;
    store_cached<RuleType::defn>(_state, std::nullopt);
    return std::nullopt;
}

// raw_defn: var_def | func_def | impl_def
std::optional<ast::field<ast::defn>> Parser::parse_raw_defn_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::defn>> _res = std::nullopt;
    { // var_def
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "raw_defn", _state, tell(), "var_def");
        auto _single_result = parse_var_def_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "raw_defn", _state, tell(), "var_def");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "var_def");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "raw_defn", _state, tell(), "var_def");
    }
    { // func_def
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "raw_defn", _state, tell(), "func_def");
        auto _single_result = parse_func_def_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "raw_defn", _state, tell(), "func_def");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "func_def");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "raw_defn", _state, tell(), "func_def");
    }
    { // impl_def
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "raw_defn", _state, tell(), "impl_def");
        auto _single_result = parse_impl_def_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "raw_defn", _state, tell(), "impl_def");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "impl_def");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "raw_defn", _state, tell(), "impl_def");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "raw_defn");
    --_level;
    return std::nullopt;
}

// type_annotation: ':' expr
std::optional<ast::field<ast::expr>> Parser::parse_type_annotation_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // ':' expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "type_annotation", _state, tell(), "':' expr");
        auto _literal = lexer.expect().punct(lex::Punct::COLON);
        if (_literal) {
        auto _user_opt_a = parse_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "type_annotation", _state, tell(), "':' expr");
            _res = std::move ( a );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "':' expr");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "type_annotation", _state, tell(), "':' expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "type_annotation");
    --_level;
    return std::nullopt;
}

// var_def: 'var' name type_annotation? ['=' expr] ';'
std::optional<ast::field<ast::defn>> Parser::parse_var_def_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::defn>> _res = std::nullopt;
    { // 'var' name type_annotation? ['=' expr] ';'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "var_def", _state, tell(), "'var' name type_annotation? ['=' expr] ';'");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::VAR);
        if (_keyword) {
        auto _user_opt_n = parse_name_rule();
        if (_user_opt_n) { auto n = std::move(*_user_opt_n);
        auto _user_opt_t = parse_type_annotation_rule();
        if (true) { auto t = _user_opt_t;
        auto _user_opt_v = parse__tmp_2_rule();
        if (true) { auto v = _user_opt_v;
        auto _literal = lexer.expect().punct(lex::Punct::SEMI);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "var_def", _state, tell(), "'var' name type_annotation? ['=' expr] ';'");
            _res = ast::VarDef ( std::move ( n ) , _opt2maybe ( std::move ( t ) ) , _opt2maybe ( std::move ( v ) ) , true );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'var' name type_annotation? ['=' expr] ';'");
            --_level;
            return _res;
        }
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "var_def", _state, tell(), "'var' name type_annotation? ['=' expr] ';'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "var_def");
    --_level;
    return std::nullopt;
}

// func_def: 'func' name? args_spec type_annotation? '=>' expr
std::optional<ast::field<ast::defn>> Parser::parse_func_def_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::defn>> _res = std::nullopt;
    { // 'func' name? args_spec type_annotation? '=>' expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "func_def", _state, tell(), "'func' name? args_spec type_annotation? '=>' expr");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::FUNC);
        if (_keyword) {
        auto _user_opt_n = parse_name_rule();
        if (true) { auto n = _user_opt_n;
        auto _user_opt_a = parse_args_spec_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _user_opt_t = parse_type_annotation_rule();
        if (true) { auto t = _user_opt_t;
        auto _literal = lexer.expect().punct(lex::Punct::RARROW2);
        if (_literal) {
        auto _user_opt_b = parse_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "func_def", _state, tell(), "'func' name? args_spec type_annotation? '=>' expr");
            _res = ast::FuncDef ( _opt2maybe ( std::move ( n ) ) , std::move ( a ) , _opt2maybe ( std::move ( t ) ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'func' name? args_spec type_annotation? '=>' expr");
            --_level;
            return _res;
        }
        }
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "func_def", _state, tell(), "'func' name? args_spec type_annotation? '=>' expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "func_def");
    --_level;
    return std::nullopt;
}

// args_spec: '(' args_spec_nonempty ','? ')' | '(' ')'
std::optional<ast::field<ast::args_spec>> Parser::parse_args_spec_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::args_spec>> _res = std::nullopt;
    { // '(' args_spec_nonempty ','? ')'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "args_spec", _state, tell(), "'(' args_spec_nonempty ','? ')'");
        auto _literal = lexer.expect().punct(lex::Punct::LPAR);
        if (_literal) {
        auto _user_opt_a = parse_args_spec_nonempty_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _opt_var = lexer.expect().punct(lex::Punct::COMMA);
        if (true) { (void)_opt_var;
        auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "args_spec", _state, tell(), "'(' args_spec_nonempty ','? ')'");
            _res = std::move ( a );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'(' args_spec_nonempty ','? ')'");
            --_level;
            return _res;
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "args_spec", _state, tell(), "'(' args_spec_nonempty ','? ')'");
    }
    { // '(' ')'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "args_spec", _state, tell(), "'(' ')'");
        auto _literal = lexer.expect().punct(lex::Punct::LPAR);
        if (_literal) {
        auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "args_spec", _state, tell(), "'(' ')'");
            _res = ast::args_spec ( ast::make_sequence < ast::arg_def > ( ) , false );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'(' ')'");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "args_spec", _state, tell(), "'(' ')'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "args_spec");
    --_level;
    return std::nullopt;
}

// args_spec_nonempty: "self" ',' ','.arg_spec+ | "self" | ','.arg_spec+
std::optional<ast::field<ast::args_spec>> Parser::parse_args_spec_nonempty_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::args_spec>> _res = std::nullopt;
    { // "self" ',' ','.arg_spec+
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "args_spec_nonempty", _state, tell(), "\"self\" ',' ','.arg_spec+");
        auto _keyword = lexer.expect().soft_keyword("self");
        if (_keyword) {
        auto _literal = lexer.expect().punct(lex::Punct::COMMA);
        if (_literal) {
        auto _user_opt_a = parse__gather_3_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "args_spec_nonempty", _state, tell(), "\"self\" ',' ','.arg_spec+");
            _res = ast::args_spec ( std::move ( a ) , true );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), ""self" ',' ','.arg_spec+");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "args_spec_nonempty", _state, tell(), "\"self\" ',' ','.arg_spec+");
    }
    { // "self"
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "args_spec_nonempty", _state, tell(), "\"self\"");
        auto _keyword = lexer.expect().soft_keyword("self");
        if (_keyword) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "args_spec_nonempty", _state, tell(), "\"self\"");
            _res = ast::args_spec ( ast::make_sequence < ast::arg_def > ( ) , true );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), ""self"");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "args_spec_nonempty", _state, tell(), "\"self\"");
    }
    { // ','.arg_spec+
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "args_spec_nonempty", _state, tell(), "','.arg_spec+");
        auto _user_opt_a = parse__gather_5_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "args_spec_nonempty", _state, tell(), "','.arg_spec+");
            _res = ast::args_spec ( std::move ( a ) , false );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "','.arg_spec+");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "args_spec_nonempty", _state, tell(), "','.arg_spec+");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "args_spec_nonempty");
    --_level;
    return std::nullopt;
}

// arg_spec: name type_annotation [('=' expr)]
std::optional<ast::field<ast::arg_spec>> Parser::parse_arg_spec_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::arg_spec>> _res = std::nullopt;
    { // name type_annotation [('=' expr)]
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "arg_spec", _state, tell(), "name type_annotation [('=' expr)]");
        auto _user_opt_n = parse_name_rule();
        if (_user_opt_n) { auto n = std::move(*_user_opt_n);
        auto _user_opt_t = parse_type_annotation_rule();
        if (_user_opt_t) { auto t = std::move(*_user_opt_t);
        auto _user_opt_d = parse__tmp_7_rule();
        if (true) { auto d = _user_opt_d;
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "arg_spec", _state, tell(), "name type_annotation [('=' expr)]");
            _res = ast::arg_spec ( std::move ( n ) , std::move ( t ) , _opt2maybe ( std::move ( d ) ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "name type_annotation [('=' expr)]");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "arg_spec", _state, tell(), "name type_annotation [('=' expr)]");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "arg_spec");
    --_level;
    return std::nullopt;
}

// defn_block: '{' stmt* '}'
std::optional<ast::sequence < ast::stmt >> Parser::parse_defn_block_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::sequence < ast::stmt >> _res = std::nullopt;
    { // '{' stmt* '}'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "defn_block", _state, tell(), "'{' stmt* '}'");
        auto _literal = lexer.expect().punct(lex::Punct::LBRACE);
        if (_literal) {
        auto _user_opt_b = parse__loop0_8_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _literal_1 = lexer.expect().punct(lex::Punct::RBRACE);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "defn_block", _state, tell(), "'{' stmt* '}'");
            _res = std::move ( b );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'{' stmt* '}'");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "defn_block", _state, tell(), "'{' stmt* '}'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "defn_block");
    --_level;
    return std::nullopt;
}

// impl_def: 'impl' expr defn_block | 'impl' expr 'for' expr defn_block
std::optional<ast::field<ast::defn>> Parser::parse_impl_def_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::defn>> _res = std::nullopt;
    { // 'impl' expr defn_block
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "impl_def", _state, tell(), "'impl' expr defn_block");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::IMPL);
        if (_keyword) {
        auto _user_opt_c = parse_expr_rule();
        if (_user_opt_c) { auto c = std::move(*_user_opt_c);
        auto _user_opt_b = parse_defn_block_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "impl_def", _state, tell(), "'impl' expr defn_block");
            _res = ast::ImplDef ( std::move ( c ) , std::nullopt , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'impl' expr defn_block");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "impl_def", _state, tell(), "'impl' expr defn_block");
    }
    { // 'impl' expr 'for' expr defn_block
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "impl_def", _state, tell(), "'impl' expr 'for' expr defn_block");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::IMPL);
        if (_keyword) {
        auto _user_opt_t = parse_expr_rule();
        if (_user_opt_t) { auto t = std::move(*_user_opt_t);
        auto _keyword_1 = lexer.expect().keyword(lex::HardKeyword::FOR);
        if (_keyword_1) {
        auto _user_opt_c = parse_expr_rule();
        if (_user_opt_c) { auto c = std::move(*_user_opt_c);
        auto _user_opt_b = parse_defn_block_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "impl_def", _state, tell(), "'impl' expr 'for' expr defn_block");
            _res = ast::ImplDef ( std::move ( c ) , std::move ( t ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'impl' expr 'for' expr defn_block");
            --_level;
            return _res;
        }
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "impl_def", _state, tell(), "'impl' expr 'for' expr defn_block");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "impl_def");
    --_level;
    return std::nullopt;
}

// struct_def: ('class' | 'struct') name? args_spec
std::optional<ast::field<ast::defn>> Parser::parse_struct_def_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::defn>> _res = std::nullopt;
    { // ('class' | 'struct') name? args_spec
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "struct_def", _state, tell(), "('class' | 'struct') name? args_spec");
        auto _tmp_9_var = parse__tmp_9_rule();
        if (_tmp_9_var) {
        auto _user_opt_n = parse_name_rule();
        if (true) { auto n = _user_opt_n;
        auto _user_opt_a = parse_args_spec_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "struct_def", _state, tell(), "('class' | 'struct') name? args_spec");
            _res = ast::StructDef ( _opt2maybe ( std::move ( n ) ) , std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "('class' | 'struct') name? args_spec");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "struct_def", _state, tell(), "('class' | 'struct') name? args_spec");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "struct_def");
    --_level;
    return std::nullopt;
}

// flow: 'ctime' raw_flow | 'rtime' raw_flow | raw_flow
std::optional<ast::field<ast::flow>> Parser::parse_flow_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::flow>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::flow>> _res = std::nullopt;
    { // 'ctime' raw_flow
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "flow", _state, tell(), "'ctime' raw_flow");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::CTIME);
        if (_keyword) {
        auto _user_opt_a = parse_raw_flow_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "flow", _state, tell(), "'ctime' raw_flow");
            _res = ( {a -> flag = ast::CTime ( ) ; a ;} );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'ctime' raw_flow");
            --_level;
            store_cached<RuleType::flow>(_state, _res);
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "flow", _state, tell(), "'ctime' raw_flow");
    }
    { // 'rtime' raw_flow
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "flow", _state, tell(), "'rtime' raw_flow");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::RTIME);
        if (_keyword) {
        auto _user_opt_a = parse_raw_flow_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "flow", _state, tell(), "'rtime' raw_flow");
            _res = ( {a -> flag = ast::RTime ( ) ; a ;} );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'rtime' raw_flow");
            --_level;
            store_cached<RuleType::flow>(_state, _res);
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "flow", _state, tell(), "'rtime' raw_flow");
    }
    { // raw_flow
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "flow", _state, tell(), "raw_flow");
        auto _single_result = parse_raw_flow_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "flow", _state, tell(), "raw_flow");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "raw_flow");
            --_level;
            store_cached<RuleType::flow>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "flow", _state, tell(), "raw_flow");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "flow");
    --_level;
    store_cached<RuleType::flow>(_state, std::nullopt);
    return std::nullopt;
}

// raw_flow: if_flow | for_flow | while_flow | loop_flow
std::optional<ast::field<ast::flow>> Parser::parse_raw_flow_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::flow>> _res = std::nullopt;
    { // if_flow
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "raw_flow", _state, tell(), "if_flow");
        auto _single_result = parse_if_flow_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "raw_flow", _state, tell(), "if_flow");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "if_flow");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "raw_flow", _state, tell(), "if_flow");
    }
    { // for_flow
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "raw_flow", _state, tell(), "for_flow");
        auto _single_result = parse_for_flow_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "raw_flow", _state, tell(), "for_flow");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "for_flow");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "raw_flow", _state, tell(), "for_flow");
    }
    { // while_flow
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "raw_flow", _state, tell(), "while_flow");
        auto _single_result = parse_while_flow_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "raw_flow", _state, tell(), "while_flow");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "while_flow");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "raw_flow", _state, tell(), "while_flow");
    }
    { // loop_flow
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "raw_flow", _state, tell(), "loop_flow");
        auto _single_result = parse_loop_flow_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "raw_flow", _state, tell(), "loop_flow");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "loop_flow");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "raw_flow", _state, tell(), "loop_flow");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "raw_flow");
    --_level;
    return std::nullopt;
}

// if_flow: 'if' expr flow_block [('else' flow_block)]
std::optional<ast::field<ast::flow>> Parser::parse_if_flow_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::flow>> _res = std::nullopt;
    { // 'if' expr flow_block [('else' flow_block)]
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "if_flow", _state, tell(), "'if' expr flow_block [('else' flow_block)]");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::IF);
        if (_keyword) {
        auto _user_opt_c = parse_expr_rule();
        if (_user_opt_c) { auto c = std::move(*_user_opt_c);
        auto _user_opt_t = parse_flow_block_rule();
        if (_user_opt_t) { auto t = std::move(*_user_opt_t);
        auto _user_opt_e = parse__tmp_10_rule();
        if (true) { auto e = _user_opt_e;
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "if_flow", _state, tell(), "'if' expr flow_block [('else' flow_block)]");
            _res = ast::If ( std::move ( c ) , std::move ( t ) , _opt2maybe ( std::move ( e ) ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'if' expr flow_block [('else' flow_block)]");
            --_level;
            return _res;
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "if_flow", _state, tell(), "'if' expr flow_block [('else' flow_block)]");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "if_flow");
    --_level;
    return std::nullopt;
}

// for_flow: 'for' name 'in' expr flow_block [('else' flow_block)]
std::optional<ast::field<ast::flow>> Parser::parse_for_flow_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::flow>> _res = std::nullopt;
    { // 'for' name 'in' expr flow_block [('else' flow_block)]
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "for_flow", _state, tell(), "'for' name 'in' expr flow_block [('else' flow_block)]");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::FOR);
        if (_keyword) {
        auto _user_opt_v = parse_name_rule();
        if (_user_opt_v) { auto v = std::move(*_user_opt_v);
        auto _keyword_1 = lexer.expect().keyword(lex::HardKeyword::IN);
        if (_keyword_1) {
        auto _user_opt_s = parse_expr_rule();
        if (_user_opt_s) { auto s = std::move(*_user_opt_s);
        auto _user_opt_b = parse_flow_block_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _user_opt_e = parse__tmp_11_rule();
        if (true) { auto e = _user_opt_e;
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "for_flow", _state, tell(), "'for' name 'in' expr flow_block [('else' flow_block)]");
            _res = ast::For ( std::move ( v ) , std::move ( s ) , std::move ( b ) , _opt2maybe ( std::move ( e ) ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'for' name 'in' expr flow_block [('else' flow_block)]");
            --_level;
            return _res;
        }
        }
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "for_flow", _state, tell(), "'for' name 'in' expr flow_block [('else' flow_block)]");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "for_flow");
    --_level;
    return std::nullopt;
}

// while_flow: 'while' expr flow_block [('else' flow_block)]
std::optional<ast::field<ast::flow>> Parser::parse_while_flow_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::flow>> _res = std::nullopt;
    { // 'while' expr flow_block [('else' flow_block)]
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "while_flow", _state, tell(), "'while' expr flow_block [('else' flow_block)]");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::WHILE);
        if (_keyword) {
        auto _user_opt_c = parse_expr_rule();
        if (_user_opt_c) { auto c = std::move(*_user_opt_c);
        auto _user_opt_b = parse_flow_block_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _user_opt_e = parse__tmp_12_rule();
        if (true) { auto e = _user_opt_e;
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "while_flow", _state, tell(), "'while' expr flow_block [('else' flow_block)]");
            _res = ast::While ( std::move ( c ) , std::move ( b ) , _opt2maybe ( std::move ( e ) ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'while' expr flow_block [('else' flow_block)]");
            --_level;
            return _res;
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "while_flow", _state, tell(), "'while' expr flow_block [('else' flow_block)]");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "while_flow");
    --_level;
    return std::nullopt;
}

// loop_flow: 'loop' flow_block
std::optional<ast::field<ast::flow>> Parser::parse_loop_flow_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::flow>> _res = std::nullopt;
    { // 'loop' flow_block
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "loop_flow", _state, tell(), "'loop' flow_block");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::LOOP);
        if (_keyword) {
        auto _user_opt_b = parse_flow_block_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "loop_flow", _state, tell(), "'loop' flow_block");
            _res = ast::Loop ( std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'loop' flow_block");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "loop_flow", _state, tell(), "'loop' flow_block");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "loop_flow");
    --_level;
    return std::nullopt;
}

// flow_block: block_expr | flow_expr | return_expr | break_expr | continue_expr
std::optional<ast::field<ast::expr>> Parser::parse_flow_block_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // block_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "flow_block", _state, tell(), "block_expr");
        auto _single_result = parse_block_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "flow_block", _state, tell(), "block_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "block_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "flow_block", _state, tell(), "block_expr");
    }
    { // flow_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "flow_block", _state, tell(), "flow_expr");
        auto _single_result = parse_flow_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "flow_block", _state, tell(), "flow_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "flow_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "flow_block", _state, tell(), "flow_expr");
    }
    { // return_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "flow_block", _state, tell(), "return_expr");
        auto _single_result = parse_return_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "flow_block", _state, tell(), "return_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "return_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "flow_block", _state, tell(), "return_expr");
    }
    { // break_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "flow_block", _state, tell(), "break_expr");
        auto _single_result = parse_break_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "flow_block", _state, tell(), "break_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "break_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "flow_block", _state, tell(), "break_expr");
    }
    { // continue_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "flow_block", _state, tell(), "continue_expr");
        auto _single_result = parse_continue_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "flow_block", _state, tell(), "continue_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "continue_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "flow_block", _state, tell(), "continue_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "flow_block");
    --_level;
    return std::nullopt;
}

// expr_or_unit: expr | 
std::optional<ast::field<ast::expr>> Parser::parse_expr_or_unit_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_or_unit", _state, tell(), "expr");
        auto _single_result = parse_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_or_unit", _state, tell(), "expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_or_unit", _state, tell(), "expr");
    }
    { // 
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_or_unit", _state, tell(), "");
        PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_or_unit", _state, tell(), "");
        _res = ast::Constant ( std::monostate ( ) );
        PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "");
        --_level;
        return _res;
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_or_unit", _state, tell(), "");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expr_or_unit");
    --_level;
    return std::nullopt;
}

// expr: defn_expr | flow_expr | return_expr | break_expr | continue_expr | expr_0
std::optional<ast::field<ast::expr>> Parser::parse_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // defn_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr", _state, tell(), "defn_expr");
        auto _single_result = parse_defn_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr", _state, tell(), "defn_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "defn_expr");
            --_level;
            store_cached<RuleType::expr>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr", _state, tell(), "defn_expr");
    }
    { // flow_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr", _state, tell(), "flow_expr");
        auto _single_result = parse_flow_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr", _state, tell(), "flow_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "flow_expr");
            --_level;
            store_cached<RuleType::expr>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr", _state, tell(), "flow_expr");
    }
    { // return_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr", _state, tell(), "return_expr");
        auto _single_result = parse_return_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr", _state, tell(), "return_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "return_expr");
            --_level;
            store_cached<RuleType::expr>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr", _state, tell(), "return_expr");
    }
    { // break_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr", _state, tell(), "break_expr");
        auto _single_result = parse_break_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr", _state, tell(), "break_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "break_expr");
            --_level;
            store_cached<RuleType::expr>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr", _state, tell(), "break_expr");
    }
    { // continue_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr", _state, tell(), "continue_expr");
        auto _single_result = parse_continue_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr", _state, tell(), "continue_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "continue_expr");
            --_level;
            store_cached<RuleType::expr>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr", _state, tell(), "continue_expr");
    }
    { // expr_0
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr", _state, tell(), "expr_0");
        auto _single_result = parse_expr_0_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr", _state, tell(), "expr_0");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_0");
            --_level;
            store_cached<RuleType::expr>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr", _state, tell(), "expr_0");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expr");
    --_level;
    store_cached<RuleType::expr>(_state, std::nullopt);
    return std::nullopt;
}

// defn_expr: defn
std::optional<ast::field<ast::expr>> Parser::parse_defn_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // defn
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "defn_expr", _state, tell(), "defn");
        auto _user_opt_a = parse_defn_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "defn_expr", _state, tell(), "defn");
            _res = ast::Defn ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "defn");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "defn_expr", _state, tell(), "defn");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "defn_expr");
    --_level;
    return std::nullopt;
}

// flow_expr: flow
std::optional<ast::field<ast::expr>> Parser::parse_flow_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // flow
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "flow_expr", _state, tell(), "flow");
        auto _user_opt_a = parse_flow_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "flow_expr", _state, tell(), "flow");
            _res = ast::Flow ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "flow");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "flow_expr", _state, tell(), "flow");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "flow_expr");
    --_level;
    return std::nullopt;
}

// return_expr: 'return' expr_or_unit
std::optional<ast::field<ast::expr>> Parser::parse_return_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'return' expr_or_unit
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "return_expr", _state, tell(), "'return' expr_or_unit");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::RETURN);
        if (_keyword) {
        auto _user_opt_a = parse_expr_or_unit_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "return_expr", _state, tell(), "'return' expr_or_unit");
            _res = ast::Return ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'return' expr_or_unit");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "return_expr", _state, tell(), "'return' expr_or_unit");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "return_expr");
    --_level;
    return std::nullopt;
}

// break_expr: 'break' expr_or_unit
std::optional<ast::field<ast::expr>> Parser::parse_break_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'break' expr_or_unit
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "break_expr", _state, tell(), "'break' expr_or_unit");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::BREAK);
        if (_keyword) {
        auto _user_opt_a = parse_expr_or_unit_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "break_expr", _state, tell(), "'break' expr_or_unit");
            _res = ast::Break ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'break' expr_or_unit");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "break_expr", _state, tell(), "'break' expr_or_unit");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "break_expr");
    --_level;
    return std::nullopt;
}

// continue_expr: 'continue'
std::optional<ast::field<ast::expr>> Parser::parse_continue_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'continue'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "continue_expr", _state, tell(), "'continue'");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::CONTINUE);
        if (_keyword) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "continue_expr", _state, tell(), "'continue'");
            _res = ast::Continue ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'continue'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "continue_expr", _state, tell(), "'continue'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "continue_expr");
    --_level;
    return std::nullopt;
}

// expr_0: and_expr | or_expr | expr_1
std::optional<ast::field<ast::expr>> Parser::parse_expr_0_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::expr_0>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // and_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_0", _state, tell(), "and_expr");
        auto _single_result = parse_and_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_0", _state, tell(), "and_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "and_expr");
            --_level;
            store_cached<RuleType::expr_0>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_0", _state, tell(), "and_expr");
    }
    { // or_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_0", _state, tell(), "or_expr");
        auto _single_result = parse_or_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_0", _state, tell(), "or_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "or_expr");
            --_level;
            store_cached<RuleType::expr_0>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_0", _state, tell(), "or_expr");
    }
    { // expr_1
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_0", _state, tell(), "expr_1");
        auto _single_result = parse_expr_1_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_0", _state, tell(), "expr_1");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_1");
            --_level;
            store_cached<RuleType::expr_0>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_0", _state, tell(), "expr_1");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expr_0");
    --_level;
    store_cached<RuleType::expr_0>(_state, std::nullopt);
    return std::nullopt;
}

// and_expr: expr_2 (('and' expr_1))+
std::optional<ast::field<ast::expr>> Parser::parse_and_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // expr_2 (('and' expr_1))+
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "and_expr", _state, tell(), "expr_2 (('and' expr_1))+");
        auto _user_opt_a = parse_expr_2_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _user_opt_b = parse__loop1_13_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "and_expr", _state, tell(), "expr_2 (('and' expr_1))+");
            _res = ast::BoolOp ( ast::And ( ) , _prepend1 ( a , b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_2 (('and' expr_1))+");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "and_expr", _state, tell(), "expr_2 (('and' expr_1))+");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "and_expr");
    --_level;
    return std::nullopt;
}

// or_expr: expr_2 (('or' expr_1))+
std::optional<ast::field<ast::expr>> Parser::parse_or_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // expr_2 (('or' expr_1))+
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "or_expr", _state, tell(), "expr_2 (('or' expr_1))+");
        auto _user_opt_a = parse_expr_2_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _user_opt_b = parse__loop1_14_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "or_expr", _state, tell(), "expr_2 (('or' expr_1))+");
            _res = ast::BoolOp ( ast::Or ( ) , _prepend1 ( a , b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_2 (('or' expr_1))+");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "or_expr", _state, tell(), "expr_2 (('or' expr_1))+");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "or_expr");
    --_level;
    return std::nullopt;
}

// expr_1: not_expr | expr_2
std::optional<ast::field<ast::expr>> Parser::parse_expr_1_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // not_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_1", _state, tell(), "not_expr");
        auto _single_result = parse_not_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_1", _state, tell(), "not_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "not_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_1", _state, tell(), "not_expr");
    }
    { // expr_2
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_1", _state, tell(), "expr_2");
        auto _single_result = parse_expr_2_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_1", _state, tell(), "expr_2");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_2");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_1", _state, tell(), "expr_2");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expr_1");
    --_level;
    return std::nullopt;
}

// not_expr: 'not' expr_1
std::optional<ast::field<ast::expr>> Parser::parse_not_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'not' expr_1
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "not_expr", _state, tell(), "'not' expr_1");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::NOT);
        if (_keyword) {
        auto _user_opt_a = parse_expr_1_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "not_expr", _state, tell(), "'not' expr_1");
            _res = ast::UnaryOp ( ast::Not ( ) , std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'not' expr_1");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "not_expr", _state, tell(), "'not' expr_1");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "not_expr");
    --_level;
    return std::nullopt;
}

// expr_2: comparison_expr | bidir_cmp_expr | expr_3
std::optional<ast::field<ast::expr>> Parser::parse_expr_2_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // comparison_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_2", _state, tell(), "comparison_expr");
        auto _single_result = parse_comparison_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_2", _state, tell(), "comparison_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "comparison_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_2", _state, tell(), "comparison_expr");
    }
    { // bidir_cmp_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_2", _state, tell(), "bidir_cmp_expr");
        auto _single_result = parse_bidir_cmp_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_2", _state, tell(), "bidir_cmp_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bidir_cmp_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_2", _state, tell(), "bidir_cmp_expr");
    }
    { // expr_3
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_2", _state, tell(), "expr_3");
        auto _single_result = parse_expr_3_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_2", _state, tell(), "expr_3");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_3");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_2", _state, tell(), "expr_3");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expr_2");
    --_level;
    return std::nullopt;
}

// comparison_expr: expr_3 comparison_followup_pair+
std::optional<ast::field<ast::expr>> Parser::parse_comparison_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // expr_3 comparison_followup_pair+
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_expr", _state, tell(), "expr_3 comparison_followup_pair+");
        auto _user_opt_f = parse_expr_3_rule();
        if (_user_opt_f) { auto f = std::move(*_user_opt_f);
        auto _user_opt_n = parse__loop1_15_rule();
        if (_user_opt_n) { auto n = std::move(*_user_opt_n);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_expr", _state, tell(), "expr_3 comparison_followup_pair+");
            _res = ast::Compare ( std::move ( f ) , ast::make_sequence < ast::cmp_op > ( ) , ast::make_sequence < ast::expr > ( ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_3 comparison_followup_pair+");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_expr", _state, tell(), "expr_3 comparison_followup_pair+");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "comparison_expr");
    --_level;
    return std::nullopt;
}

// comparison_followup_pair: comparison_op expr_3
std::optional<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>> Parser::parse_comparison_followup_pair_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>> _res = std::nullopt;
    { // comparison_op expr_3
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_followup_pair", _state, tell(), "comparison_op expr_3");
        auto _user_opt_o = parse_comparison_op_rule();
        if (_user_opt_o) { auto o = std::move(*_user_opt_o);
        auto _user_opt_a = parse_expr_3_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_followup_pair", _state, tell(), "comparison_op expr_3");
            _res = std::make_pair ( std::move ( o ) , std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "comparison_op expr_3");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_followup_pair", _state, tell(), "comparison_op expr_3");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "comparison_followup_pair");
    --_level;
    return std::nullopt;
}

// comparison_op: '==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in'
std::optional<ast::field<ast::cmp_op>> Parser::parse_comparison_op_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::cmp_op>> _res = std::nullopt;
    { // '=='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'=='");
        auto _literal = lexer.expect().punct(lex::Punct::DOUBLEEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'=='");
            _res = ast::Eq ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'=='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'=='");
    }
    { // '!='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'!='");
        auto _literal = lexer.expect().punct(lex::Punct::NOTEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'!='");
            _res = ast::NotEq ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'!='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'!='");
    }
    { // '<'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'<'");
        auto _literal = lexer.expect().punct(lex::Punct::LESS);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'<'");
            _res = ast::Lt ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'<'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'<'");
    }
    { // '<='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'<='");
        auto _literal = lexer.expect().punct(lex::Punct::LESSEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'<='");
            _res = ast::LtE ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'<='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'<='");
    }
    { // '>'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'>'");
        auto _literal = lexer.expect().punct(lex::Punct::GREATER);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'>'");
            _res = ast::Gt ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'>'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'>'");
    }
    { // '>='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'>='");
        auto _literal = lexer.expect().punct(lex::Punct::GREATEREQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'>='");
            _res = ast::GtE ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'>='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'>='");
    }
    { // 'in'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'in'");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::IN);
        if (_keyword) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'in'");
            _res = ast::In ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'in'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'in'");
    }
    { // 'not' 'in'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'not' 'in'");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::NOT);
        if (_keyword) {
        auto _keyword_1 = lexer.expect().keyword(lex::HardKeyword::IN);
        if (_keyword_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'not' 'in'");
            _res = ast::NotIn ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'not' 'in'");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'not' 'in'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "comparison_op");
    --_level;
    return std::nullopt;
}

// bidir_cmp_expr: expr_3 '<=>' expr_3
std::optional<ast::field<ast::expr>> Parser::parse_bidir_cmp_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // expr_3 '<=>' expr_3
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bidir_cmp_expr", _state, tell(), "expr_3 '<=>' expr_3");
        auto _user_opt_a = parse_expr_3_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::BIDIRCMP);
        if (_literal) {
        auto _user_opt_b = parse_expr_3_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bidir_cmp_expr", _state, tell(), "expr_3 '<=>' expr_3");
            _res = ast::BinOp ( ast::BidirCmp ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_3 '<=>' expr_3");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bidir_cmp_expr", _state, tell(), "expr_3 '<=>' expr_3");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "bidir_cmp_expr");
    --_level;
    return std::nullopt;
}

// expr_3: arithm_expr | bitwise_expr | expr_4
std::optional<ast::field<ast::expr>> Parser::parse_expr_3_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // arithm_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_3", _state, tell(), "arithm_expr");
        auto _single_result = parse_arithm_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_3", _state, tell(), "arithm_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "arithm_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_3", _state, tell(), "arithm_expr");
    }
    { // bitwise_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_3", _state, tell(), "bitwise_expr");
        auto _single_result = parse_bitwise_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_3", _state, tell(), "bitwise_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bitwise_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_3", _state, tell(), "bitwise_expr");
    }
    { // expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_3", _state, tell(), "expr_4");
        auto _single_result = parse_expr_4_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_3", _state, tell(), "expr_4");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_4");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_3", _state, tell(), "expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expr_3");
    --_level;
    return std::nullopt;
}

// arithm_expr: sum_expr | product_expr
std::optional<ast::field<ast::expr>> Parser::parse_arithm_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // sum_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "arithm_expr", _state, tell(), "sum_expr");
        auto _single_result = parse_sum_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "arithm_expr", _state, tell(), "sum_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "sum_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "arithm_expr", _state, tell(), "sum_expr");
    }
    { // product_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "arithm_expr", _state, tell(), "product_expr");
        auto _single_result = parse_product_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "arithm_expr", _state, tell(), "product_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "product_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "arithm_expr", _state, tell(), "product_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "arithm_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// sum_expr:
//     | (sum_expr | product_expr) '+' product_expr
//     | (sum_expr | product_expr) '-' product_expr
std::optional<ast::field<ast::expr>> Parser::parse_sum_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::sum_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    bool _first = true;
    while (true) {
        store_cached<RuleType::sum_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_sum_expr();
        if (!_raw || (tell() <= _res_state && !_first)) {
            break;
        }
        _first = false;
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    --_level;
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_sum_expr()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // (sum_expr | product_expr) '+' product_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "sum_expr", _state, tell(), "(sum_expr | product_expr) '+' product_expr");
        auto _user_opt_a = parse__tmp_16_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::PLUS);
        if (_literal) {
        auto _user_opt_b = parse_product_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "sum_expr", _state, tell(), "(sum_expr | product_expr) '+' product_expr");
            _res = ast::BinOp ( ast::Add ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "(sum_expr | product_expr) '+' product_expr");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "sum_expr", _state, tell(), "(sum_expr | product_expr) '+' product_expr");
    }
    { // (sum_expr | product_expr) '-' product_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "sum_expr", _state, tell(), "(sum_expr | product_expr) '-' product_expr");
        auto _user_opt_a = parse__tmp_17_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::MINUS);
        if (_literal) {
        auto _user_opt_b = parse_product_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "sum_expr", _state, tell(), "(sum_expr | product_expr) '-' product_expr");
            _res = ast::BinOp ( ast::Sub ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "(sum_expr | product_expr) '-' product_expr");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "sum_expr", _state, tell(), "(sum_expr | product_expr) '-' product_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "sum_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// product_expr:
//     | (product_expr | expr_4) '*' expr_4
//     | (product_expr | expr_4) '/' expr_4
//     | (product_expr | expr_4) '%' expr_4
std::optional<ast::field<ast::expr>> Parser::parse_product_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::product_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    bool _first = true;
    while (true) {
        store_cached<RuleType::product_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_product_expr();
        if (!_raw || (tell() <= _res_state && !_first)) {
            break;
        }
        _first = false;
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    --_level;
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_product_expr()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // (product_expr | expr_4) '*' expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "product_expr", _state, tell(), "(product_expr | expr_4) '*' expr_4");
        auto _user_opt_a = parse__tmp_18_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::STAR);
        if (_literal) {
        auto _user_opt_b = parse_expr_4_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "product_expr", _state, tell(), "(product_expr | expr_4) '*' expr_4");
            _res = ast::BinOp ( ast::Mul ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "(product_expr | expr_4) '*' expr_4");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "product_expr", _state, tell(), "(product_expr | expr_4) '*' expr_4");
    }
    { // (product_expr | expr_4) '/' expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "product_expr", _state, tell(), "(product_expr | expr_4) '/' expr_4");
        auto _user_opt_a = parse__tmp_19_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::SLASH);
        if (_literal) {
        auto _user_opt_b = parse_expr_4_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "product_expr", _state, tell(), "(product_expr | expr_4) '/' expr_4");
            _res = ast::BinOp ( ast::Div ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "(product_expr | expr_4) '/' expr_4");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "product_expr", _state, tell(), "(product_expr | expr_4) '/' expr_4");
    }
    { // (product_expr | expr_4) '%' expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "product_expr", _state, tell(), "(product_expr | expr_4) '%' expr_4");
        auto _user_opt_a = parse__tmp_20_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::PERCENT);
        if (_literal) {
        auto _user_opt_b = parse_expr_4_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "product_expr", _state, tell(), "(product_expr | expr_4) '%' expr_4");
            _res = ast::BinOp ( ast::Mod ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "(product_expr | expr_4) '%' expr_4");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "product_expr", _state, tell(), "(product_expr | expr_4) '%' expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "product_expr");
    --_level;
    return std::nullopt;
}

// bitwise_expr: bitor_expr | bitand_expr | bitxor_expr | shift_expr
std::optional<ast::field<ast::expr>> Parser::parse_bitwise_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // bitor_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bitwise_expr", _state, tell(), "bitor_expr");
        auto _single_result = parse_bitor_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bitwise_expr", _state, tell(), "bitor_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bitor_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bitwise_expr", _state, tell(), "bitor_expr");
    }
    { // bitand_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bitwise_expr", _state, tell(), "bitand_expr");
        auto _single_result = parse_bitand_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bitwise_expr", _state, tell(), "bitand_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bitand_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bitwise_expr", _state, tell(), "bitand_expr");
    }
    { // bitxor_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bitwise_expr", _state, tell(), "bitxor_expr");
        auto _single_result = parse_bitxor_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bitwise_expr", _state, tell(), "bitxor_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bitxor_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bitwise_expr", _state, tell(), "bitxor_expr");
    }
    { // shift_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bitwise_expr", _state, tell(), "shift_expr");
        auto _single_result = parse_shift_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bitwise_expr", _state, tell(), "shift_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "shift_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bitwise_expr", _state, tell(), "shift_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "bitwise_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// bitor_expr: (bitor_expr | expr_4) '|' expr_4
std::optional<ast::field<ast::expr>> Parser::parse_bitor_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::bitor_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    bool _first = true;
    while (true) {
        store_cached<RuleType::bitor_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_bitor_expr();
        if (!_raw || (tell() <= _res_state && !_first)) {
            break;
        }
        _first = false;
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    --_level;
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_bitor_expr()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // (bitor_expr | expr_4) '|' expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bitor_expr", _state, tell(), "(bitor_expr | expr_4) '|' expr_4");
        auto _user_opt_a = parse__tmp_21_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::VBAR);
        if (_literal) {
        auto _user_opt_b = parse_expr_4_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bitor_expr", _state, tell(), "(bitor_expr | expr_4) '|' expr_4");
            _res = ast::BinOp ( ast::BitOr ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "(bitor_expr | expr_4) '|' expr_4");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bitor_expr", _state, tell(), "(bitor_expr | expr_4) '|' expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "bitor_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// bitand_expr: (bitand_expr | expr_4) '&' expr_4
std::optional<ast::field<ast::expr>> Parser::parse_bitand_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::bitand_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    bool _first = true;
    while (true) {
        store_cached<RuleType::bitand_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_bitand_expr();
        if (!_raw || (tell() <= _res_state && !_first)) {
            break;
        }
        _first = false;
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    --_level;
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_bitand_expr()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // (bitand_expr | expr_4) '&' expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bitand_expr", _state, tell(), "(bitand_expr | expr_4) '&' expr_4");
        auto _user_opt_a = parse__tmp_22_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::AMPER);
        if (_literal) {
        auto _user_opt_b = parse_expr_4_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bitand_expr", _state, tell(), "(bitand_expr | expr_4) '&' expr_4");
            _res = ast::BinOp ( ast::BitAnd ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "(bitand_expr | expr_4) '&' expr_4");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bitand_expr", _state, tell(), "(bitand_expr | expr_4) '&' expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "bitand_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// bitxor_expr: (bitxor_expr | expr_4) '^' expr_4
std::optional<ast::field<ast::expr>> Parser::parse_bitxor_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::bitxor_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    bool _first = true;
    while (true) {
        store_cached<RuleType::bitxor_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_bitxor_expr();
        if (!_raw || (tell() <= _res_state && !_first)) {
            break;
        }
        _first = false;
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    --_level;
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_bitxor_expr()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // (bitxor_expr | expr_4) '^' expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bitxor_expr", _state, tell(), "(bitxor_expr | expr_4) '^' expr_4");
        auto _user_opt_a = parse__tmp_23_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::CIRCUMFLEX);
        if (_literal) {
        auto _user_opt_b = parse_expr_4_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bitxor_expr", _state, tell(), "(bitxor_expr | expr_4) '^' expr_4");
            _res = ast::BinOp ( ast::BitXor ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "(bitxor_expr | expr_4) '^' expr_4");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bitxor_expr", _state, tell(), "(bitxor_expr | expr_4) '^' expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "bitxor_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// shift_expr: (shift_expr | expr_4) '<<' expr_4 | (shift_expr | expr_4) '>>' expr_4
std::optional<ast::field<ast::expr>> Parser::parse_shift_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::shift_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    bool _first = true;
    while (true) {
        store_cached<RuleType::shift_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_shift_expr();
        if (!_raw || (tell() <= _res_state && !_first)) {
            break;
        }
        _first = false;
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    --_level;
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_shift_expr()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // (shift_expr | expr_4) '<<' expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "shift_expr", _state, tell(), "(shift_expr | expr_4) '<<' expr_4");
        auto _user_opt_a = parse__tmp_24_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::LEFTSHIFT);
        if (_literal) {
        auto _user_opt_b = parse_expr_4_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "shift_expr", _state, tell(), "(shift_expr | expr_4) '<<' expr_4");
            _res = ast::BinOp ( ast::LShift ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "(shift_expr | expr_4) '<<' expr_4");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "shift_expr", _state, tell(), "(shift_expr | expr_4) '<<' expr_4");
    }
    { // (shift_expr | expr_4) '>>' expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "shift_expr", _state, tell(), "(shift_expr | expr_4) '>>' expr_4");
        auto _user_opt_a = parse__tmp_25_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::RIGHTSHIFT);
        if (_literal) {
        auto _user_opt_b = parse_expr_4_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "shift_expr", _state, tell(), "(shift_expr | expr_4) '>>' expr_4");
            _res = ast::BinOp ( ast::RShift ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "(shift_expr | expr_4) '>>' expr_4");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "shift_expr", _state, tell(), "(shift_expr | expr_4) '>>' expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "shift_expr");
    --_level;
    return std::nullopt;
}

// expr_4: unary_expr | power_expr | expr_5
std::optional<ast::field<ast::expr>> Parser::parse_expr_4_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::expr_4>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // unary_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_4", _state, tell(), "unary_expr");
        auto _single_result = parse_unary_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_4", _state, tell(), "unary_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "unary_expr");
            --_level;
            store_cached<RuleType::expr_4>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_4", _state, tell(), "unary_expr");
    }
    { // power_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_4", _state, tell(), "power_expr");
        auto _single_result = parse_power_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_4", _state, tell(), "power_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "power_expr");
            --_level;
            store_cached<RuleType::expr_4>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_4", _state, tell(), "power_expr");
    }
    { // expr_5
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_4", _state, tell(), "expr_5");
        auto _single_result = parse_expr_5_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_4", _state, tell(), "expr_5");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_5");
            --_level;
            store_cached<RuleType::expr_4>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_4", _state, tell(), "expr_5");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expr_4");
    --_level;
    store_cached<RuleType::expr_4>(_state, std::nullopt);
    return std::nullopt;
}

// unary_expr:
//     | '+' (unary_expr | expr_5)
//     | '-' (unary_expr | expr_5)
//     | '~' (unary_expr | expr_5)
//     | '&' (unary_expr | expr_5)
//     | '*' (unary_expr | expr_5)
std::optional<ast::field<ast::expr>> Parser::parse_unary_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '+' (unary_expr | expr_5)
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "unary_expr", _state, tell(), "'+' (unary_expr | expr_5)");
        auto _literal = lexer.expect().punct(lex::Punct::PLUS);
        if (_literal) {
        auto _user_opt_a = parse__tmp_26_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "unary_expr", _state, tell(), "'+' (unary_expr | expr_5)");
            _res = ast::UnOp ( ast::UAdd ( ) , std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'+' (unary_expr | expr_5)");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "unary_expr", _state, tell(), "'+' (unary_expr | expr_5)");
    }
    { // '-' (unary_expr | expr_5)
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "unary_expr", _state, tell(), "'-' (unary_expr | expr_5)");
        auto _literal = lexer.expect().punct(lex::Punct::MINUS);
        if (_literal) {
        auto _user_opt_a = parse__tmp_27_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "unary_expr", _state, tell(), "'-' (unary_expr | expr_5)");
            _res = ast::UnOp ( ast::USub ( ) , std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'-' (unary_expr | expr_5)");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "unary_expr", _state, tell(), "'-' (unary_expr | expr_5)");
    }
    { // '~' (unary_expr | expr_5)
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "unary_expr", _state, tell(), "'~' (unary_expr | expr_5)");
        auto _literal = lexer.expect().punct(lex::Punct::TILDE);
        if (_literal) {
        auto _user_opt_a = parse__tmp_28_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "unary_expr", _state, tell(), "'~' (unary_expr | expr_5)");
            _res = ast::UnOp ( ast::BitInv ( ) , std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'~' (unary_expr | expr_5)");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "unary_expr", _state, tell(), "'~' (unary_expr | expr_5)");
    }
    { // '&' (unary_expr | expr_5)
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "unary_expr", _state, tell(), "'&' (unary_expr | expr_5)");
        auto _literal = lexer.expect().punct(lex::Punct::AMPER);
        if (_literal) {
        auto _user_opt_a = parse__tmp_29_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "unary_expr", _state, tell(), "'&' (unary_expr | expr_5)");
            _res = ast::UnOp ( ast::URef ( ) , std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'&' (unary_expr | expr_5)");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "unary_expr", _state, tell(), "'&' (unary_expr | expr_5)");
    }
    { // '*' (unary_expr | expr_5)
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "unary_expr", _state, tell(), "'*' (unary_expr | expr_5)");
        auto _literal = lexer.expect().punct(lex::Punct::STAR);
        if (_literal) {
        auto _user_opt_a = parse__tmp_30_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "unary_expr", _state, tell(), "'*' (unary_expr | expr_5)");
            _res = ast::UnOp ( ast::UStar ( ) , std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'*' (unary_expr | expr_5)");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "unary_expr", _state, tell(), "'*' (unary_expr | expr_5)");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "unary_expr");
    --_level;
    return std::nullopt;
}

// power_expr: expr_5 '**' expr_5
std::optional<ast::field<ast::expr>> Parser::parse_power_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // expr_5 '**' expr_5
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "power_expr", _state, tell(), "expr_5 '**' expr_5");
        auto _user_opt_a = parse_expr_5_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::POWER);
        if (_literal) {
        auto _user_opt_b = parse_expr_5_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "power_expr", _state, tell(), "expr_5 '**' expr_5");
            _res = ast::BinOp ( ast::Pow ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_5 '**' expr_5");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "power_expr", _state, tell(), "expr_5 '**' expr_5");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "power_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// expr_5: attr_expr | call_expr | subscript_expr | expr_6
std::optional<ast::field<ast::expr>> Parser::parse_expr_5_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::expr_5>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    bool _first = true;
    while (true) {
        store_cached<RuleType::expr_5>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_expr_5();
        if (!_raw || (tell() <= _res_state && !_first)) {
            break;
        }
        _first = false;
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    --_level;
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_expr_5()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // attr_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_5", _state, tell(), "attr_expr");
        auto _single_result = parse_attr_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_5", _state, tell(), "attr_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "attr_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_5", _state, tell(), "attr_expr");
    }
    { // call_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_5", _state, tell(), "call_expr");
        auto _single_result = parse_call_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_5", _state, tell(), "call_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "call_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_5", _state, tell(), "call_expr");
    }
    { // subscript_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_5", _state, tell(), "subscript_expr");
        auto _single_result = parse_subscript_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_5", _state, tell(), "subscript_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "subscript_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_5", _state, tell(), "subscript_expr");
    }
    { // expr_6
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_5", _state, tell(), "expr_6");
        auto _single_result = parse_expr_6_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_5", _state, tell(), "expr_6");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_6");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_5", _state, tell(), "expr_6");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expr_5");
    --_level;
    return std::nullopt;
}

// Left-recursive
// attr_expr: expr_5 '.' NAME | expr_5 '::' NAME
std::optional<ast::field<ast::expr>> Parser::parse_attr_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // expr_5 '.' NAME
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "attr_expr", _state, tell(), "expr_5 '.' NAME");
        auto _user_opt_a = parse_expr_5_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::DOT);
        if (_literal) {
        auto _user_opt_b = lexer.expect().token(lex::TokenType::name);
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "attr_expr", _state, tell(), "expr_5 '.' NAME");
            _res = ast::Attribute ( std::move ( a ) , std::move ( b ) , ast::AttrInst ( ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_5 '.' NAME");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "attr_expr", _state, tell(), "expr_5 '.' NAME");
    }
    { // expr_5 '::' NAME
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "attr_expr", _state, tell(), "expr_5 '::' NAME");
        auto _user_opt_a = parse_expr_5_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::DOUBLECOLON);
        if (_literal) {
        auto _user_opt_b = lexer.expect().token(lex::TokenType::name);
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "attr_expr", _state, tell(), "expr_5 '::' NAME");
            _res = ast::Attribute ( std::move ( a ) , std::move ( b ) , ast::AttrStatic ( ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_5 '::' NAME");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "attr_expr", _state, tell(), "expr_5 '::' NAME");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "attr_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// call_expr: expr_5 '(' call_args ')'
std::optional<ast::field<ast::expr>> Parser::parse_call_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // expr_5 '(' call_args ')'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "call_expr", _state, tell(), "expr_5 '(' call_args ')'");
        auto _user_opt_a = parse_expr_5_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::LPAR);
        if (_literal) {
        auto _user_opt_b = parse_call_args_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "call_expr", _state, tell(), "expr_5 '(' call_args ')'");
            _res = ast::Call ( std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_5 '(' call_args ')'");
            --_level;
            return _res;
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "call_expr", _state, tell(), "expr_5 '(' call_args ')'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "call_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// subscript_expr: expr_5 '[' call_args ']'
std::optional<ast::field<ast::expr>> Parser::parse_subscript_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // expr_5 '[' call_args ']'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "subscript_expr", _state, tell(), "expr_5 '[' call_args ']'");
        auto _user_opt_a = parse_expr_5_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::LSQB);
        if (_literal) {
        auto _user_opt_b = parse_call_args_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _literal_1 = lexer.expect().punct(lex::Punct::RSQB);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "subscript_expr", _state, tell(), "expr_5 '[' call_args ']'");
            _res = ast::Subscript ( std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_5 '[' call_args ']'");
            --_level;
            return _res;
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "subscript_expr", _state, tell(), "expr_5 '[' call_args ']'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "subscript_expr");
    --_level;
    return std::nullopt;
}

// call_args: 
std::optional<ast::field<ast::call_args>> Parser::parse_call_args_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::call_args>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::call_args>> _res = std::nullopt;
    { // 
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "call_args", _state, tell(), "");
        PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "call_args", _state, tell(), "");
        _res = ast::call_args ( ast::make_sequence < ast::call_arg > ( ) , nullptr , nullptr );
        PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "");
        --_level;
        store_cached<RuleType::call_args>(_state, _res);
        return _res;
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "call_args", _state, tell(), "");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "call_args");
    --_level;
    store_cached<RuleType::call_args>(_state, std::nullopt);
    return std::nullopt;
}

// expr_6: primary_expr
std::optional<ast::field<ast::expr>> Parser::parse_expr_6_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // primary_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_6", _state, tell(), "primary_expr");
        auto _single_result = parse_primary_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_6", _state, tell(), "primary_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "primary_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_6", _state, tell(), "primary_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expr_6");
    --_level;
    return std::nullopt;
}

// primary_expr:
//     | name
//     | NUMBER
//     | &STRING strings
//     | '...'
//     | group_expr
//     | tuple_expr
//     | array_expr
//     | ctime_block_expr
//     | block_expr
std::optional<ast::field<ast::expr>> Parser::parse_primary_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // name
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "primary_expr", _state, tell(), "name");
        auto _user_opt_a = parse_name_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "primary_expr", _state, tell(), "name");
            _res = ast::Name ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "name");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "primary_expr", _state, tell(), "name");
    }
    { // NUMBER
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "primary_expr", _state, tell(), "NUMBER");
        auto _user_opt_a = lexer.expect().token(lex::TokenType::number);
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "primary_expr", _state, tell(), "NUMBER");
            _res = ast::Constant ( util::variant_cast ( a . get_number ( ) . value ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "NUMBER");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "primary_expr", _state, tell(), "NUMBER");
    }
    { // &STRING strings
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "primary_expr", _state, tell(), "&STRING strings");
        auto _tmpvar = lexer.lookahead(true).token(lex::TokenType::string);
        if (_tmpvar) {
        auto _user_opt_a = parse_strings_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "primary_expr", _state, tell(), "&STRING strings");
            _res = ast::Constant ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "&STRING strings");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "primary_expr", _state, tell(), "&STRING strings");
    }
    { // '...'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "primary_expr", _state, tell(), "'...'");
        auto _literal = lexer.expect().punct(lex::Punct::ELLIPSIS);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "primary_expr", _state, tell(), "'...'");
            _res = ast::Ellipsis ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'...'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "primary_expr", _state, tell(), "'...'");
    }
    { // group_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "primary_expr", _state, tell(), "group_expr");
        auto _single_result = parse_group_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "primary_expr", _state, tell(), "group_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "group_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "primary_expr", _state, tell(), "group_expr");
    }
    { // tuple_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "primary_expr", _state, tell(), "tuple_expr");
        auto _single_result = parse_tuple_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "primary_expr", _state, tell(), "tuple_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "tuple_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "primary_expr", _state, tell(), "tuple_expr");
    }
    { // array_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "primary_expr", _state, tell(), "array_expr");
        auto _single_result = parse_array_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "primary_expr", _state, tell(), "array_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "array_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "primary_expr", _state, tell(), "array_expr");
    }
    { // ctime_block_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "primary_expr", _state, tell(), "ctime_block_expr");
        auto _single_result = parse_ctime_block_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "primary_expr", _state, tell(), "ctime_block_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "ctime_block_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "primary_expr", _state, tell(), "ctime_block_expr");
    }
    { // block_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "primary_expr", _state, tell(), "block_expr");
        auto _single_result = parse_block_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "primary_expr", _state, tell(), "block_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "block_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "primary_expr", _state, tell(), "block_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "primary_expr");
    --_level;
    return std::nullopt;
}

// name: NAME
std::optional<std::string> Parser::parse_name_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<std::string> _res = std::nullopt;
    { // NAME
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "name", _state, tell(), "NAME");
        auto _user_opt_a = lexer.expect().token(lex::TokenType::name);
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "name", _state, tell(), "NAME");
            _res = a . get_name ( ) . value;
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "NAME");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "name", _state, tell(), "NAME");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "name");
    --_level;
    return std::nullopt;
}

// strings: STRING+
std::optional<std::string> Parser::parse_strings_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::strings>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<std::string> _res = std::nullopt;
    { // STRING+
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "strings", _state, tell(), "STRING+");
        auto _user_opt_a = parse__loop1_31_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "strings", _state, tell(), "STRING+");
            _res = _concat_strings ( a );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "STRING+");
            --_level;
            store_cached<RuleType::strings>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "strings", _state, tell(), "STRING+");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "strings");
    --_level;
    store_cached<RuleType::strings>(_state, std::nullopt);
    return std::nullopt;
}

// group_expr: '(' expr ')'
std::optional<ast::field<ast::expr>> Parser::parse_group_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '(' expr ')'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "group_expr", _state, tell(), "'(' expr ')'");
        auto _literal = lexer.expect().punct(lex::Punct::LPAR);
        if (_literal) {
        auto _single_result = parse_expr_rule();
        if (_single_result) {
        auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "group_expr", _state, tell(), "'(' expr ')'");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'(' expr ')'");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "group_expr", _state, tell(), "'(' expr ')'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "group_expr");
    --_level;
    return std::nullopt;
}

// tuple_expr: '(' ')' | '(' ','.expr+ ','? ')'
std::optional<ast::field<ast::expr>> Parser::parse_tuple_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '(' ')'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "tuple_expr", _state, tell(), "'(' ')'");
        auto _literal = lexer.expect().punct(lex::Punct::LPAR);
        if (_literal) {
        auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "tuple_expr", _state, tell(), "'(' ')'");
            _res = ast::Tuple ( ast::make_sequence < ast::expr > ( ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'(' ')'");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "tuple_expr", _state, tell(), "'(' ')'");
    }
    { // '(' ','.expr+ ','? ')'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "tuple_expr", _state, tell(), "'(' ','.expr+ ','? ')'");
        auto _literal = lexer.expect().punct(lex::Punct::LPAR);
        if (_literal) {
        auto _user_opt_a = parse__gather_32_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _opt_var = lexer.expect().punct(lex::Punct::COMMA);
        if (true) { (void)_opt_var;
        auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "tuple_expr", _state, tell(), "'(' ','.expr+ ','? ')'");
            _res = ast::Tuple ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'(' ','.expr+ ','? ')'");
            --_level;
            return _res;
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "tuple_expr", _state, tell(), "'(' ','.expr+ ','? ')'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "tuple_expr");
    --_level;
    return std::nullopt;
}

// array_expr: '[' ']' | '[' ','.expr+ ','? ']'
std::optional<ast::field<ast::expr>> Parser::parse_array_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '[' ']'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "array_expr", _state, tell(), "'[' ']'");
        auto _literal = lexer.expect().punct(lex::Punct::LSQB);
        if (_literal) {
        auto _literal_1 = lexer.expect().punct(lex::Punct::RSQB);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "array_expr", _state, tell(), "'[' ']'");
            _res = ast::Array ( ast::make_sequence < ast::expr > ( ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'[' ']'");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "array_expr", _state, tell(), "'[' ']'");
    }
    { // '[' ','.expr+ ','? ']'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "array_expr", _state, tell(), "'[' ','.expr+ ','? ']'");
        auto _literal = lexer.expect().punct(lex::Punct::LSQB);
        if (_literal) {
        auto _user_opt_a = parse__gather_34_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _opt_var = lexer.expect().punct(lex::Punct::COMMA);
        if (true) { (void)_opt_var;
        auto _literal_1 = lexer.expect().punct(lex::Punct::RSQB);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "array_expr", _state, tell(), "'[' ','.expr+ ','? ']'");
            _res = ast::Array ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'[' ','.expr+ ','? ']'");
            --_level;
            return _res;
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "array_expr", _state, tell(), "'[' ','.expr+ ','? ']'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "array_expr");
    --_level;
    return std::nullopt;
}

// ctime_block_expr: 'ctime' block_expr
std::optional<ast::field<ast::expr>> Parser::parse_ctime_block_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'ctime' block_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "ctime_block_expr", _state, tell(), "'ctime' block_expr");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::CTIME);
        if (_keyword) {
        auto _user_opt_b = parse_block_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "ctime_block_expr", _state, tell(), "'ctime' block_expr");
            _res = ast::CtimeBlock ( std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'ctime' block_expr");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "ctime_block_expr", _state, tell(), "'ctime' block_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "ctime_block_expr");
    --_level;
    return std::nullopt;
}

// block_expr: '{' stmt* expr_or_unit '}'
std::optional<ast::field<ast::expr>> Parser::parse_block_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::block_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '{' stmt* expr_or_unit '}'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "block_expr", _state, tell(), "'{' stmt* expr_or_unit '}'");
        auto _literal = lexer.expect().punct(lex::Punct::LBRACE);
        if (_literal) {
        auto _user_opt_b = parse__loop0_36_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _user_opt_v = parse_expr_or_unit_rule();
        if (_user_opt_v) { auto v = std::move(*_user_opt_v);
        auto _literal_1 = lexer.expect().punct(lex::Punct::RBRACE);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "block_expr", _state, tell(), "'{' stmt* expr_or_unit '}'");
            _res = ast::Block ( std::move ( b ) , std::move ( v ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'{' stmt* expr_or_unit '}'");
            --_level;
            store_cached<RuleType::block_expr>(_state, _res);
            return _res;
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "block_expr", _state, tell(), "'{' stmt* expr_or_unit '}'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "block_expr");
    --_level;
    store_cached<RuleType::block_expr>(_state, std::nullopt);
    return std::nullopt;
}

// _loop0_1: stmt
std::optional<ast::sequence<ast::stmt>> Parser::parse__loop0_1_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    std::vector<ast::field<ast::stmt>> _children{};
    { // stmt
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop0_1", _state, tell(), "stmt");
        while (true) {
            auto _single_result = parse_stmt_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "stmt");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop0_1", _state, tell(), "stmt");
    }
    auto _seq = ast::make_sequence<ast::stmt>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _tmp_2: '=' expr
std::optional<ast::field<ast::expr>> Parser::parse__tmp_2_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '=' expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_2", _state, tell(), "'=' expr");
        auto _literal = lexer.expect().punct(lex::Punct::EQUAL);
        if (_literal) {
        auto _user_opt_a = parse_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_2", _state, tell(), "'=' expr");
            _res = a;
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'=' expr");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_2", _state, tell(), "'=' expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_2");
    --_level;
    return std::nullopt;
}

// _loop0_4: ',' arg_spec
std::optional<ast::sequence<ast::arg_spec>> Parser::parse__loop0_4_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::arg_spec>> _res = std::nullopt;
    std::vector<ast::field<ast::arg_spec>> _children{};
    { // ',' arg_spec
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop0_4", _state, tell(), "',' arg_spec");
        while (true) {
            auto _literal = lexer.expect().punct(lex::Punct::COMMA);
            if (_literal) {
            auto _user_opt_elem = parse_arg_spec_rule();
            if (_user_opt_elem) { auto elem = std::move(*_user_opt_elem);
                _res = elem;
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "',' arg_spec");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop0_4", _state, tell(), "',' arg_spec");
    }
    auto _seq = ast::make_sequence<ast::arg_spec>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _gather_3: arg_spec _loop0_4
std::optional<ast::sequence<ast::arg_spec>> Parser::parse__gather_3_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::sequence<ast::arg_spec>> _res = std::nullopt;
    { // arg_spec _loop0_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_gather_3", _state, tell(), "arg_spec _loop0_4");
        auto _user_opt_arg_spec_var = parse_arg_spec_rule();
        if (_user_opt_arg_spec_var) { auto arg_spec_var = std::move(*_user_opt_arg_spec_var);
        auto _user_opt_seq = parse__loop0_4_rule();
        if (_user_opt_seq) { auto seq = std::move(*_user_opt_seq);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_gather_3", _state, tell(), "arg_spec _loop0_4");
            _res = std::move(seq);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "arg_spec _loop0_4");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_gather_3", _state, tell(), "arg_spec _loop0_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_gather_3");
    --_level;
    return std::nullopt;
}

// _loop0_6: ',' arg_spec
std::optional<ast::sequence<ast::arg_spec>> Parser::parse__loop0_6_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::arg_spec>> _res = std::nullopt;
    std::vector<ast::field<ast::arg_spec>> _children{};
    { // ',' arg_spec
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop0_6", _state, tell(), "',' arg_spec");
        while (true) {
            auto _literal = lexer.expect().punct(lex::Punct::COMMA);
            if (_literal) {
            auto _user_opt_elem = parse_arg_spec_rule();
            if (_user_opt_elem) { auto elem = std::move(*_user_opt_elem);
                _res = elem;
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "',' arg_spec");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop0_6", _state, tell(), "',' arg_spec");
    }
    auto _seq = ast::make_sequence<ast::arg_spec>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _gather_5: arg_spec _loop0_6
std::optional<ast::sequence<ast::arg_spec>> Parser::parse__gather_5_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::sequence<ast::arg_spec>> _res = std::nullopt;
    { // arg_spec _loop0_6
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_gather_5", _state, tell(), "arg_spec _loop0_6");
        auto _user_opt_arg_spec_var = parse_arg_spec_rule();
        if (_user_opt_arg_spec_var) { auto arg_spec_var = std::move(*_user_opt_arg_spec_var);
        auto _user_opt_seq = parse__loop0_6_rule();
        if (_user_opt_seq) { auto seq = std::move(*_user_opt_seq);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_gather_5", _state, tell(), "arg_spec _loop0_6");
            _res = std::move(seq);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "arg_spec _loop0_6");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_gather_5", _state, tell(), "arg_spec _loop0_6");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_gather_5");
    --_level;
    return std::nullopt;
}

// _tmp_7: '=' expr
std::optional<ast::field<ast::expr>> Parser::parse__tmp_7_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '=' expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_7", _state, tell(), "'=' expr");
        auto _literal = lexer.expect().punct(lex::Punct::EQUAL);
        if (_literal) {
        auto _single_result = parse_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_7", _state, tell(), "'=' expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'=' expr");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_7", _state, tell(), "'=' expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_7");
    --_level;
    return std::nullopt;
}

// _loop0_8: stmt
std::optional<ast::sequence<ast::stmt>> Parser::parse__loop0_8_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    std::vector<ast::field<ast::stmt>> _children{};
    { // stmt
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop0_8", _state, tell(), "stmt");
        while (true) {
            auto _single_result = parse_stmt_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "stmt");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop0_8", _state, tell(), "stmt");
    }
    auto _seq = ast::make_sequence<ast::stmt>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _tmp_9: 'class' | 'struct'
std::optional<std::monostate> Parser::parse__tmp_9_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<std::monostate> _res = std::nullopt;
    { // 'class'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_9", _state, tell(), "'class'");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::CLASS);
        if (_keyword) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_9", _state, tell(), "'class'");
            _res = std::monostate{};
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'class'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_9", _state, tell(), "'class'");
    }
    { // 'struct'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_9", _state, tell(), "'struct'");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::STRUCT);
        if (_keyword) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_9", _state, tell(), "'struct'");
            _res = std::monostate{};
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'struct'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_9", _state, tell(), "'struct'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_9");
    --_level;
    return std::nullopt;
}

// _tmp_10: 'else' flow_block
std::optional<ast::field<ast::expr>> Parser::parse__tmp_10_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'else' flow_block
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_10", _state, tell(), "'else' flow_block");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::ELSE);
        if (_keyword) {
        auto _single_result = parse_flow_block_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_10", _state, tell(), "'else' flow_block");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'else' flow_block");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_10", _state, tell(), "'else' flow_block");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_10");
    --_level;
    return std::nullopt;
}

// _tmp_11: 'else' flow_block
std::optional<ast::field<ast::expr>> Parser::parse__tmp_11_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'else' flow_block
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_11", _state, tell(), "'else' flow_block");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::ELSE);
        if (_keyword) {
        auto _single_result = parse_flow_block_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_11", _state, tell(), "'else' flow_block");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'else' flow_block");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_11", _state, tell(), "'else' flow_block");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_11");
    --_level;
    return std::nullopt;
}

// _tmp_12: 'else' flow_block
std::optional<ast::field<ast::expr>> Parser::parse__tmp_12_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'else' flow_block
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_12", _state, tell(), "'else' flow_block");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::ELSE);
        if (_keyword) {
        auto _single_result = parse_flow_block_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_12", _state, tell(), "'else' flow_block");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'else' flow_block");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_12", _state, tell(), "'else' flow_block");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_12");
    --_level;
    return std::nullopt;
}

// _loop1_13: ('and' expr_1)
std::optional<ast::sequence<ast::expr>> Parser::parse__loop1_13_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    std::vector<ast::field<ast::expr>> _children{};
    { // ('and' expr_1)
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop1_13", _state, tell(), "('and' expr_1)");
        while (true) {
            auto _single_result = parse__tmp_37_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "('and' expr_1)");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop1_13", _state, tell(), "('and' expr_1)");
    }
    if (_children.size() == 0) {
        --_level;
        return std::nullopt;
    }
    auto _seq = ast::make_sequence<ast::expr>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _loop1_14: ('or' expr_1)
std::optional<ast::sequence<ast::expr>> Parser::parse__loop1_14_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    std::vector<ast::field<ast::expr>> _children{};
    { // ('or' expr_1)
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop1_14", _state, tell(), "('or' expr_1)");
        while (true) {
            auto _single_result = parse__tmp_38_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "('or' expr_1)");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop1_14", _state, tell(), "('or' expr_1)");
    }
    if (_children.size() == 0) {
        --_level;
        return std::nullopt;
    }
    auto _seq = ast::make_sequence<ast::expr>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _loop1_15: comparison_followup_pair
std::optional<std::vector<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>>> Parser::parse__loop1_15_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>> _res = std::nullopt;
    std::vector<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>> _children{};
    { // comparison_followup_pair
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop1_15", _state, tell(), "comparison_followup_pair");
        while (true) {
            auto _single_result = parse_comparison_followup_pair_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "comparison_followup_pair");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop1_15", _state, tell(), "comparison_followup_pair");
    }
    if (_children.size() == 0) {
        --_level;
        return std::nullopt;
    }
    --_level;
    return _children;
}

// _tmp_16: sum_expr | product_expr
std::optional<ast::field<ast::expr>> Parser::parse__tmp_16_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // sum_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_16", _state, tell(), "sum_expr");
        auto _single_result = parse_sum_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_16", _state, tell(), "sum_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "sum_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_16", _state, tell(), "sum_expr");
    }
    { // product_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_16", _state, tell(), "product_expr");
        auto _single_result = parse_product_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_16", _state, tell(), "product_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "product_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_16", _state, tell(), "product_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_16");
    --_level;
    return std::nullopt;
}

// _tmp_17: sum_expr | product_expr
std::optional<ast::field<ast::expr>> Parser::parse__tmp_17_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // sum_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_17", _state, tell(), "sum_expr");
        auto _single_result = parse_sum_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_17", _state, tell(), "sum_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "sum_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_17", _state, tell(), "sum_expr");
    }
    { // product_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_17", _state, tell(), "product_expr");
        auto _single_result = parse_product_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_17", _state, tell(), "product_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "product_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_17", _state, tell(), "product_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_17");
    --_level;
    return std::nullopt;
}

// _tmp_18: product_expr | expr_4
std::optional<ast::field<ast::expr>> Parser::parse__tmp_18_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // product_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_18", _state, tell(), "product_expr");
        auto _single_result = parse_product_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_18", _state, tell(), "product_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "product_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_18", _state, tell(), "product_expr");
    }
    { // expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_18", _state, tell(), "expr_4");
        auto _single_result = parse_expr_4_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_18", _state, tell(), "expr_4");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_4");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_18", _state, tell(), "expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_18");
    --_level;
    return std::nullopt;
}

// _tmp_19: product_expr | expr_4
std::optional<ast::field<ast::expr>> Parser::parse__tmp_19_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // product_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_19", _state, tell(), "product_expr");
        auto _single_result = parse_product_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_19", _state, tell(), "product_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "product_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_19", _state, tell(), "product_expr");
    }
    { // expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_19", _state, tell(), "expr_4");
        auto _single_result = parse_expr_4_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_19", _state, tell(), "expr_4");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_4");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_19", _state, tell(), "expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_19");
    --_level;
    return std::nullopt;
}

// _tmp_20: product_expr | expr_4
std::optional<ast::field<ast::expr>> Parser::parse__tmp_20_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // product_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_20", _state, tell(), "product_expr");
        auto _single_result = parse_product_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_20", _state, tell(), "product_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "product_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_20", _state, tell(), "product_expr");
    }
    { // expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_20", _state, tell(), "expr_4");
        auto _single_result = parse_expr_4_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_20", _state, tell(), "expr_4");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_4");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_20", _state, tell(), "expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_20");
    --_level;
    return std::nullopt;
}

// _tmp_21: bitor_expr | expr_4
std::optional<ast::field<ast::expr>> Parser::parse__tmp_21_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // bitor_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_21", _state, tell(), "bitor_expr");
        auto _single_result = parse_bitor_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_21", _state, tell(), "bitor_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bitor_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_21", _state, tell(), "bitor_expr");
    }
    { // expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_21", _state, tell(), "expr_4");
        auto _single_result = parse_expr_4_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_21", _state, tell(), "expr_4");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_4");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_21", _state, tell(), "expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_21");
    --_level;
    return std::nullopt;
}

// _tmp_22: bitand_expr | expr_4
std::optional<ast::field<ast::expr>> Parser::parse__tmp_22_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // bitand_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_22", _state, tell(), "bitand_expr");
        auto _single_result = parse_bitand_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_22", _state, tell(), "bitand_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bitand_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_22", _state, tell(), "bitand_expr");
    }
    { // expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_22", _state, tell(), "expr_4");
        auto _single_result = parse_expr_4_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_22", _state, tell(), "expr_4");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_4");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_22", _state, tell(), "expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_22");
    --_level;
    return std::nullopt;
}

// _tmp_23: bitxor_expr | expr_4
std::optional<ast::field<ast::expr>> Parser::parse__tmp_23_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // bitxor_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_23", _state, tell(), "bitxor_expr");
        auto _single_result = parse_bitxor_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_23", _state, tell(), "bitxor_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bitxor_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_23", _state, tell(), "bitxor_expr");
    }
    { // expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_23", _state, tell(), "expr_4");
        auto _single_result = parse_expr_4_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_23", _state, tell(), "expr_4");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_4");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_23", _state, tell(), "expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_23");
    --_level;
    return std::nullopt;
}

// _tmp_24: shift_expr | expr_4
std::optional<ast::field<ast::expr>> Parser::parse__tmp_24_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // shift_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_24", _state, tell(), "shift_expr");
        auto _single_result = parse_shift_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_24", _state, tell(), "shift_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "shift_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_24", _state, tell(), "shift_expr");
    }
    { // expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_24", _state, tell(), "expr_4");
        auto _single_result = parse_expr_4_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_24", _state, tell(), "expr_4");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_4");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_24", _state, tell(), "expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_24");
    --_level;
    return std::nullopt;
}

// _tmp_25: shift_expr | expr_4
std::optional<ast::field<ast::expr>> Parser::parse__tmp_25_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // shift_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_25", _state, tell(), "shift_expr");
        auto _single_result = parse_shift_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_25", _state, tell(), "shift_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "shift_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_25", _state, tell(), "shift_expr");
    }
    { // expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_25", _state, tell(), "expr_4");
        auto _single_result = parse_expr_4_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_25", _state, tell(), "expr_4");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_4");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_25", _state, tell(), "expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_25");
    --_level;
    return std::nullopt;
}

// _tmp_26: unary_expr | expr_5
std::optional<ast::field<ast::expr>> Parser::parse__tmp_26_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // unary_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_26", _state, tell(), "unary_expr");
        auto _single_result = parse_unary_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_26", _state, tell(), "unary_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "unary_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_26", _state, tell(), "unary_expr");
    }
    { // expr_5
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_26", _state, tell(), "expr_5");
        auto _single_result = parse_expr_5_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_26", _state, tell(), "expr_5");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_5");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_26", _state, tell(), "expr_5");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_26");
    --_level;
    return std::nullopt;
}

// _tmp_27: unary_expr | expr_5
std::optional<ast::field<ast::expr>> Parser::parse__tmp_27_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // unary_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_27", _state, tell(), "unary_expr");
        auto _single_result = parse_unary_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_27", _state, tell(), "unary_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "unary_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_27", _state, tell(), "unary_expr");
    }
    { // expr_5
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_27", _state, tell(), "expr_5");
        auto _single_result = parse_expr_5_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_27", _state, tell(), "expr_5");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_5");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_27", _state, tell(), "expr_5");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_27");
    --_level;
    return std::nullopt;
}

// _tmp_28: unary_expr | expr_5
std::optional<ast::field<ast::expr>> Parser::parse__tmp_28_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // unary_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_28", _state, tell(), "unary_expr");
        auto _single_result = parse_unary_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_28", _state, tell(), "unary_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "unary_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_28", _state, tell(), "unary_expr");
    }
    { // expr_5
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_28", _state, tell(), "expr_5");
        auto _single_result = parse_expr_5_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_28", _state, tell(), "expr_5");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_5");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_28", _state, tell(), "expr_5");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_28");
    --_level;
    return std::nullopt;
}

// _tmp_29: unary_expr | expr_5
std::optional<ast::field<ast::expr>> Parser::parse__tmp_29_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // unary_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_29", _state, tell(), "unary_expr");
        auto _single_result = parse_unary_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_29", _state, tell(), "unary_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "unary_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_29", _state, tell(), "unary_expr");
    }
    { // expr_5
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_29", _state, tell(), "expr_5");
        auto _single_result = parse_expr_5_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_29", _state, tell(), "expr_5");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_5");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_29", _state, tell(), "expr_5");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_29");
    --_level;
    return std::nullopt;
}

// _tmp_30: unary_expr | expr_5
std::optional<ast::field<ast::expr>> Parser::parse__tmp_30_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // unary_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_30", _state, tell(), "unary_expr");
        auto _single_result = parse_unary_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_30", _state, tell(), "unary_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "unary_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_30", _state, tell(), "unary_expr");
    }
    { // expr_5
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_30", _state, tell(), "expr_5");
        auto _single_result = parse_expr_5_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_30", _state, tell(), "expr_5");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_5");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_30", _state, tell(), "expr_5");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_30");
    --_level;
    return std::nullopt;
}

// _loop1_31: STRING
std::optional<std::vector<lex::Token>> Parser::parse__loop1_31_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<lex::Token> _res = std::nullopt;
    std::vector<lex::Token> _children{};
    { // STRING
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop1_31", _state, tell(), "STRING");
        while (true) {
            auto _single_result = lexer.expect().token(lex::TokenType::string);
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "STRING");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop1_31", _state, tell(), "STRING");
    }
    if (_children.size() == 0) {
        --_level;
        return std::nullopt;
    }
    --_level;
    return _children;
}

// _loop0_33: ',' expr
std::optional<ast::sequence<ast::expr>> Parser::parse__loop0_33_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    std::vector<ast::field<ast::expr>> _children{};
    { // ',' expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop0_33", _state, tell(), "',' expr");
        while (true) {
            auto _literal = lexer.expect().punct(lex::Punct::COMMA);
            if (_literal) {
            auto _user_opt_elem = parse_expr_rule();
            if (_user_opt_elem) { auto elem = std::move(*_user_opt_elem);
                _res = elem;
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "',' expr");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop0_33", _state, tell(), "',' expr");
    }
    auto _seq = ast::make_sequence<ast::expr>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _gather_32: expr _loop0_33
std::optional<ast::sequence<ast::expr>> Parser::parse__gather_32_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::sequence<ast::expr>> _res = std::nullopt;
    { // expr _loop0_33
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_gather_32", _state, tell(), "expr _loop0_33");
        auto _user_opt_expr_var = parse_expr_rule();
        if (_user_opt_expr_var) { auto expr_var = std::move(*_user_opt_expr_var);
        auto _user_opt_seq = parse__loop0_33_rule();
        if (_user_opt_seq) { auto seq = std::move(*_user_opt_seq);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_gather_32", _state, tell(), "expr _loop0_33");
            _res = std::move(seq);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr _loop0_33");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_gather_32", _state, tell(), "expr _loop0_33");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_gather_32");
    --_level;
    return std::nullopt;
}

// _loop0_35: ',' expr
std::optional<ast::sequence<ast::expr>> Parser::parse__loop0_35_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    std::vector<ast::field<ast::expr>> _children{};
    { // ',' expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop0_35", _state, tell(), "',' expr");
        while (true) {
            auto _literal = lexer.expect().punct(lex::Punct::COMMA);
            if (_literal) {
            auto _user_opt_elem = parse_expr_rule();
            if (_user_opt_elem) { auto elem = std::move(*_user_opt_elem);
                _res = elem;
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "',' expr");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop0_35", _state, tell(), "',' expr");
    }
    auto _seq = ast::make_sequence<ast::expr>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _gather_34: expr _loop0_35
std::optional<ast::sequence<ast::expr>> Parser::parse__gather_34_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::sequence<ast::expr>> _res = std::nullopt;
    { // expr _loop0_35
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_gather_34", _state, tell(), "expr _loop0_35");
        auto _user_opt_expr_var = parse_expr_rule();
        if (_user_opt_expr_var) { auto expr_var = std::move(*_user_opt_expr_var);
        auto _user_opt_seq = parse__loop0_35_rule();
        if (_user_opt_seq) { auto seq = std::move(*_user_opt_seq);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_gather_34", _state, tell(), "expr _loop0_35");
            _res = std::move(seq);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr _loop0_35");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_gather_34", _state, tell(), "expr _loop0_35");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_gather_34");
    --_level;
    return std::nullopt;
}

// _loop0_36: stmt
std::optional<ast::sequence<ast::stmt>> Parser::parse__loop0_36_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    std::vector<ast::field<ast::stmt>> _children{};
    { // stmt
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop0_36", _state, tell(), "stmt");
        while (true) {
            auto _single_result = parse_stmt_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "stmt");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop0_36", _state, tell(), "stmt");
    }
    auto _seq = ast::make_sequence<ast::stmt>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _tmp_37: 'and' expr_1
std::optional<ast::field<ast::expr>> Parser::parse__tmp_37_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'and' expr_1
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_37", _state, tell(), "'and' expr_1");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::AND);
        if (_keyword) {
        auto _single_result = parse_expr_1_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_37", _state, tell(), "'and' expr_1");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'and' expr_1");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_37", _state, tell(), "'and' expr_1");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_37");
    --_level;
    return std::nullopt;
}

// _tmp_38: 'or' expr_1
std::optional<ast::field<ast::expr>> Parser::parse__tmp_38_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'or' expr_1
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_38", _state, tell(), "'or' expr_1");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::OR);
        if (_keyword) {
        auto _single_result = parse_expr_1_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_38", _state, tell(), "'or' expr_1");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'or' expr_1");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_38", _state, tell(), "'or' expr_1");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_38");
    --_level;
    return std::nullopt;
}

#pragma endregion Rule parsers


}  // namespace bondrewd::parse
