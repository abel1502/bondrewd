// AUTOGENERATED by bondrewd/tools/pegen++/pegenxx.py on 2023-03-15 07:47:38
// DO NOT EDIT

#include <bondrewd/parse/parser.gen.hpp>


namespace bondrewd::parse {


#pragma region Rule parsers

// start: cartridge
std::optional<ast::field<ast::cartridge>> Parser::parse_start_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::cartridge>> _res = std::nullopt;
    { // cartridge
        auto _single_result = parse_cartridge_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    return std::nullopt;
}

// cartridge: cartridge_header stmt*
std::optional<ast::field<ast::cartridge>> Parser::parse_cartridge_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::cartridge>> _res = std::nullopt;
    { // cartridge_header stmt*
        auto _user_opt_h = parse_cartridge_header_rule();
        if (_user_opt_h) { auto h = std::move(*_user_opt_h);
        auto _user_opt_b = parse__loop0_1_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            _res = ast::Cartridge ( std::move ( h ) , std::move ( b ) );
            return _res;
        }
        }
        seek(_state);
    }
    return std::nullopt;
}

// cartridge_header: 'cartridge' name ';'
std::optional<std::string> Parser::parse_cartridge_header_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<std::string> _res = std::nullopt;
    { // 'cartridge' name ';'
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::CARTRIDGE);
        if (_keyword) {
        auto _user_opt_n = parse_name_rule();
        if (_user_opt_n) { auto n = std::move(*_user_opt_n);
        auto _literal = lexer.expect().punct(lex::Punct::SEMI);
        if (_literal) {
            _res = std::move ( n );
            return _res;
        }
        }
        }
        seek(_state);
    }
    return std::nullopt;
}

// stmt: var_def_stmt | impl_stmt | assign_stmt | expr_stmt | ';'
std::optional<ast::field<ast::stmt>> Parser::parse_stmt_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    { // var_def_stmt
        auto _single_result = parse_var_def_stmt_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    { // impl_stmt
        auto _single_result = parse_impl_stmt_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    { // assign_stmt
        auto _single_result = parse_assign_stmt_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    { // expr_stmt
        auto _single_result = parse_expr_stmt_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    { // ';'
        auto _literal = lexer.expect().punct(lex::Punct::SEMI);
        if (_literal) {
            _res = ast::Pass ( );
            return _res;
        }
        seek(_state);
    }
    return std::nullopt;
}

// assign_stmt: expr assign_op expr ';'
std::optional<ast::field<ast::stmt>> Parser::parse_assign_stmt_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    { // expr assign_op expr ';'
        auto _user_opt_a = parse_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _user_opt_op = parse_assign_op_rule();
        if (_user_opt_op) { auto op = std::move(*_user_opt_op);
        auto _user_opt_b = parse_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _literal = lexer.expect().punct(lex::Punct::SEMI);
        if (_literal) {
            _res = ast::Assign ( std::move ( a ) , std::move ( b ) , std::move ( op ) );
            return _res;
        }
        }
        }
        }
        seek(_state);
    }
    return std::nullopt;
}

// assign_op: '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '|=' | '^='
std::optional<ast::field<ast::assign_op>> Parser::parse_assign_op_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::assign_op>> _res = std::nullopt;
    { // '='
        auto _literal = lexer.expect().punct(lex::Punct::EQUAL);
        if (_literal) {
            _res = ast::AsgnNone ( );
            return _res;
        }
        seek(_state);
    }
    { // '+='
        auto _literal = lexer.expect().punct(lex::Punct::PLUSEQUAL);
        if (_literal) {
            _res = ast::AsgnAdd ( );
            return _res;
        }
        seek(_state);
    }
    { // '-='
        auto _literal = lexer.expect().punct(lex::Punct::MINEQUAL);
        if (_literal) {
            _res = ast::AsgnSub ( );
            return _res;
        }
        seek(_state);
    }
    { // '*='
        auto _literal = lexer.expect().punct(lex::Punct::STAREQUAL);
        if (_literal) {
            _res = ast::AsgnMul ( );
            return _res;
        }
        seek(_state);
    }
    { // '/='
        auto _literal = lexer.expect().punct(lex::Punct::SLASHEQUAL);
        if (_literal) {
            _res = ast::AsgnDiv ( );
            return _res;
        }
        seek(_state);
    }
    { // '%='
        auto _literal = lexer.expect().punct(lex::Punct::PERCENTEQUAL);
        if (_literal) {
            _res = ast::AsgnMod ( );
            return _res;
        }
        seek(_state);
    }
    { // '<<='
        auto _literal = lexer.expect().punct(lex::Punct::LEFTSHIFTEQUAL);
        if (_literal) {
            _res = ast::AsgnLShift ( );
            return _res;
        }
        seek(_state);
    }
    { // '>>='
        auto _literal = lexer.expect().punct(lex::Punct::RIGHTSHIFTEQUAL);
        if (_literal) {
            _res = ast::AsgnRShift ( );
            return _res;
        }
        seek(_state);
    }
    { // '&='
        auto _literal = lexer.expect().punct(lex::Punct::AMPEREQUAL);
        if (_literal) {
            _res = ast::AsgnBitAnd ( );
            return _res;
        }
        seek(_state);
    }
    { // '|='
        auto _literal = lexer.expect().punct(lex::Punct::VBAREQUAL);
        if (_literal) {
            _res = ast::AsgnBitOr ( );
            return _res;
        }
        seek(_state);
    }
    { // '^='
        auto _literal = lexer.expect().punct(lex::Punct::CIRCUMFLEXEQUAL);
        if (_literal) {
            _res = ast::AsgnBitXor ( );
            return _res;
        }
        seek(_state);
    }
    return std::nullopt;
}

// var_def_stmt: 'ctime'? 'var' name type_annotation? ['=' expr] ';'
std::optional<ast::field<ast::stmt>> Parser::parse_var_def_stmt_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    { // 'ctime'? 'var' name type_annotation? ['=' expr] ';'
        auto _user_opt_c = lexer.expect().keyword(lex::HardKeyword::CTIME);
        if (true) { auto c = _user_opt_c;
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::VAR);
        if (_keyword) {
        auto _user_opt_n = parse_name_rule();
        if (_user_opt_n) { auto n = std::move(*_user_opt_n);
        auto _user_opt_t = parse_type_annotation_rule();
        if (true) { auto t = _user_opt_t;
        auto _user_opt_v = parse__tmp_2_rule();
        if (true) { auto v = _user_opt_v;
        auto _literal = lexer.expect().punct(lex::Punct::SEMI);
        if (_literal) {
            _res = ast::VarDef ( std::move ( n ) , _opt2maybe ( std::move ( t ) ) , _opt2maybe ( std::move ( v ) ) , true , bool ( c ) );
            return _res;
        }
        }
        }
        }
        }
        }
        seek(_state);
    }
    return std::nullopt;
}

// impl_stmt: 
std::optional<ast::field<ast::stmt>> Parser::parse_impl_stmt_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    return std::nullopt;
}

// expr_stmt: expr ';'
std::optional<ast::field<ast::stmt>> Parser::parse_expr_stmt_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    { // expr ';'
        auto _user_opt_a = parse_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::SEMI);
        if (_literal) {
            _res = ast::Expr ( std::move ( a ) );
            return _res;
        }
        }
        seek(_state);
    }
    return std::nullopt;
}

// expr:
//     | func_def
//     | block_expr
//     | 'return' expr_or_unit
//     | 'break' expr_or_unit
//     | disjunction_expr
std::optional<ast::field<ast::expr>> Parser::parse_expr_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // func_def
        auto _single_result = parse_func_def_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    { // block_expr
        auto _single_result = parse_block_expr_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    { // 'return' expr_or_unit
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::RETURN);
        if (_keyword) {
        auto _user_opt_a = parse_expr_or_unit_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            _res = ast::Return ( std::move ( a ) );
            return _res;
        }
        }
        seek(_state);
    }
    { // 'break' expr_or_unit
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::BREAK);
        if (_keyword) {
        auto _user_opt_a = parse_expr_or_unit_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            _res = ast::Break ( std::move ( a ) );
            return _res;
        }
        }
        seek(_state);
    }
    { // disjunction_expr
        auto _single_result = parse_disjunction_expr_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    return std::nullopt;
}

// expr_or_unit: expr | 
std::optional<ast::field<ast::expr>> Parser::parse_expr_or_unit_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // expr
        auto _single_result = parse_expr_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    { // 
            _res = ast::Constant ( std::monostate ( ) );
            return _res;
        seek(_state);
    }
    return std::nullopt;
}

// disjunction_expr: conjunction_expr (('or' conjunction_expr))+ | conjunction_expr
std::optional<ast::field<ast::expr>> Parser::parse_disjunction_expr_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // conjunction_expr (('or' conjunction_expr))+
        auto _user_opt_a = parse_conjunction_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _user_opt_b = parse__loop1_3_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            _res = ast::BoolOp ( ast::Or ( ) , ast::make_sequence < ast::expr > ( ) );
            return _res;
        }
        }
        seek(_state);
    }
    { // conjunction_expr
        auto _single_result = parse_conjunction_expr_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    return std::nullopt;
}

// conjunction_expr: inversion_expr (('and' inversion_expr))+ | inversion_expr
std::optional<ast::field<ast::expr>> Parser::parse_conjunction_expr_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // inversion_expr (('and' inversion_expr))+
        auto _user_opt_a = parse_inversion_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _user_opt_b = parse__loop1_4_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            _res = ast::BoolOp ( ast::And ( ) , ast::make_sequence < ast::expr > ( ) );
            return _res;
        }
        }
        seek(_state);
    }
    { // inversion_expr
        auto _single_result = parse_inversion_expr_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    return std::nullopt;
}

// inversion_expr: 'not' inversion_expr | comparison_expr
std::optional<ast::field<ast::expr>> Parser::parse_inversion_expr_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'not' inversion_expr
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::NOT);
        if (_keyword) {
        auto _user_opt_a = parse_inversion_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            _res = ast::UnOp ( ast::Not ( ) , std::move ( a ) );
            return _res;
        }
        }
        seek(_state);
    }
    { // comparison_expr
        auto _single_result = parse_comparison_expr_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    return std::nullopt;
}

// comparison_expr: bidir_cmp_expr comparison_followup_pair+ | bidir_cmp_expr
std::optional<ast::field<ast::expr>> Parser::parse_comparison_expr_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // bidir_cmp_expr comparison_followup_pair+
        auto _user_opt_a = parse_bidir_cmp_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _user_opt_b = parse__loop1_5_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            _res = ast::Compare ( std::move ( a ) , ast::make_sequence < ast::cmp_op > ( ) , ast::make_sequence < ast::expr > ( ) );
            return _res;
        }
        }
        seek(_state);
    }
    { // bidir_cmp_expr
        auto _single_result = parse_bidir_cmp_expr_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    return std::nullopt;
}

// comparison_followup_pair: comparison_op bidir_cmp_expr
std::optional<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>> Parser::parse_comparison_followup_pair_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>> _res = std::nullopt;
    { // comparison_op bidir_cmp_expr
        auto _user_opt_o = parse_comparison_op_rule();
        if (_user_opt_o) { auto o = std::move(*_user_opt_o);
        auto _user_opt_a = parse_bidir_cmp_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            _res = std::make_pair ( std::move ( o ) , std::move ( a ) );
            return _res;
        }
        }
        seek(_state);
    }
    return std::nullopt;
}

// comparison_op: '==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in'
std::optional<ast::field<ast::cmp_op>> Parser::parse_comparison_op_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::cmp_op>> _res = std::nullopt;
    { // '=='
        auto _literal = lexer.expect().punct(lex::Punct::DOUBLEEQUAL);
        if (_literal) {
            _res = ast::Eq ( );
            return _res;
        }
        seek(_state);
    }
    { // '!='
        auto _literal = lexer.expect().punct(lex::Punct::NOTEQUAL);
        if (_literal) {
            _res = ast::NotEq ( );
            return _res;
        }
        seek(_state);
    }
    { // '<'
        auto _literal = lexer.expect().punct(lex::Punct::LESS);
        if (_literal) {
            _res = ast::Lt ( );
            return _res;
        }
        seek(_state);
    }
    { // '<='
        auto _literal = lexer.expect().punct(lex::Punct::LESSEQUAL);
        if (_literal) {
            _res = ast::LtE ( );
            return _res;
        }
        seek(_state);
    }
    { // '>'
        auto _literal = lexer.expect().punct(lex::Punct::GREATER);
        if (_literal) {
            _res = ast::Gt ( );
            return _res;
        }
        seek(_state);
    }
    { // '>='
        auto _literal = lexer.expect().punct(lex::Punct::GREATEREQUAL);
        if (_literal) {
            _res = ast::GtE ( );
            return _res;
        }
        seek(_state);
    }
    { // 'in'
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::IN);
        if (_keyword) {
            _res = ast::In ( );
            return _res;
        }
        seek(_state);
    }
    { // 'not' 'in'
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::NOT);
        if (_keyword) {
        auto _keyword_1 = lexer.expect().keyword(lex::HardKeyword::IN);
        if (_keyword_1) {
            _res = ast::NotIn ( );
            return _res;
        }
        }
        seek(_state);
    }
    return std::nullopt;
}

// bidir_cmp_expr: bitor_expr '<=>' bitor_expr | bitor_expr
std::optional<ast::field<ast::expr>> Parser::parse_bidir_cmp_expr_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // bitor_expr '<=>' bitor_expr
        auto _user_opt_a = parse_bitor_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::BIDIRCMP);
        if (_literal) {
        auto _user_opt_b = parse_bitor_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            _res = ast::BinOp ( ast::BidirCmp ( ) , std::move ( a ) , std::move ( b ) );
            return _res;
        }
        }
        }
        seek(_state);
    }
    { // bitor_expr
        auto _single_result = parse_bitor_expr_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    return std::nullopt;
}

// Left-recursive
// bitor_expr: bitor_expr '|' bitxor_expr | bitxor_expr
std::optional<ast::field<ast::expr>> Parser::parse_bitor_expr_rule()
{
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::bitor_expr>(_state)) {
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    while (true) {
        store_cached<RuleType::bitor_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_bitor_expr();
        if (!_raw || tell() <= _res_state) {
            break;
        }
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_bitor_expr()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // bitor_expr '|' bitxor_expr
        auto _user_opt_a = parse_bitor_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::VBAR);
        if (_literal) {
        auto _user_opt_b = parse_bitxor_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            _res = ast::BinOp ( ast::BitOr ( ) , std::move ( a ) , std::move ( b ) );
            return _res;
        }
        }
        }
        seek(_state);
    }
    { // bitxor_expr
        auto _single_result = parse_bitxor_expr_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    return std::nullopt;
}

// Left-recursive
// bitxor_expr: bitxor_expr '^' bitand_expr | bitand_expr
std::optional<ast::field<ast::expr>> Parser::parse_bitxor_expr_rule()
{
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::bitxor_expr>(_state)) {
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    while (true) {
        store_cached<RuleType::bitxor_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_bitxor_expr();
        if (!_raw || tell() <= _res_state) {
            break;
        }
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_bitxor_expr()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // bitxor_expr '^' bitand_expr
        auto _user_opt_a = parse_bitxor_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::CIRCUMFLEX);
        if (_literal) {
        auto _user_opt_b = parse_bitand_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            _res = ast::BinOp ( ast::BitXor ( ) , std::move ( a ) , std::move ( b ) );
            return _res;
        }
        }
        }
        seek(_state);
    }
    { // bitand_expr
        auto _single_result = parse_bitand_expr_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    return std::nullopt;
}

// Left-recursive
// bitand_expr: bitand_expr '&' shift_expr | shift_expr
std::optional<ast::field<ast::expr>> Parser::parse_bitand_expr_rule()
{
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::bitand_expr>(_state)) {
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    while (true) {
        store_cached<RuleType::bitand_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_bitand_expr();
        if (!_raw || tell() <= _res_state) {
            break;
        }
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_bitand_expr()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // bitand_expr '&' shift_expr
        auto _user_opt_a = parse_bitand_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::AMPER);
        if (_literal) {
        auto _user_opt_b = parse_shift_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            _res = ast::BinOp ( ast::BitAnd ( ) , std::move ( a ) , std::move ( b ) );
            return _res;
        }
        }
        }
        seek(_state);
    }
    { // shift_expr
        auto _single_result = parse_shift_expr_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    return std::nullopt;
}

// Left-recursive
// shift_expr: shift_expr '<<' sum_expr | shift_expr '>>' sum_expr | sum_expr
std::optional<ast::field<ast::expr>> Parser::parse_shift_expr_rule()
{
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::shift_expr>(_state)) {
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    while (true) {
        store_cached<RuleType::shift_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_shift_expr();
        if (!_raw || tell() <= _res_state) {
            break;
        }
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_shift_expr()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // shift_expr '<<' sum_expr
        auto _user_opt_a = parse_shift_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::LEFTSHIFT);
        if (_literal) {
        auto _user_opt_b = parse_sum_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            _res = ast::BinOp ( ast::LShift ( ) , std::move ( a ) , std::move ( b ) );
            return _res;
        }
        }
        }
        seek(_state);
    }
    { // shift_expr '>>' sum_expr
        auto _user_opt_a = parse_shift_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::RIGHTSHIFT);
        if (_literal) {
        auto _user_opt_b = parse_sum_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            _res = ast::BinOp ( ast::RShift ( ) , std::move ( a ) , std::move ( b ) );
            return _res;
        }
        }
        }
        seek(_state);
    }
    { // sum_expr
        auto _single_result = parse_sum_expr_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    return std::nullopt;
}

// Left-recursive
// sum_expr: sum_expr '+' term_expr | sum_expr '-' term_expr | term_expr
std::optional<ast::field<ast::expr>> Parser::parse_sum_expr_rule()
{
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::sum_expr>(_state)) {
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    while (true) {
        store_cached<RuleType::sum_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_sum_expr();
        if (!_raw || tell() <= _res_state) {
            break;
        }
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_sum_expr()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // sum_expr '+' term_expr
        auto _user_opt_a = parse_sum_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::PLUS);
        if (_literal) {
        auto _user_opt_b = parse_term_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            _res = ast::BinOp ( ast::Add ( ) , std::move ( a ) , std::move ( b ) );
            return _res;
        }
        }
        }
        seek(_state);
    }
    { // sum_expr '-' term_expr
        auto _user_opt_a = parse_sum_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::MINUS);
        if (_literal) {
        auto _user_opt_b = parse_term_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            _res = ast::BinOp ( ast::Sub ( ) , std::move ( a ) , std::move ( b ) );
            return _res;
        }
        }
        }
        seek(_state);
    }
    { // term_expr
        auto _single_result = parse_term_expr_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    return std::nullopt;
}

// Left-recursive
// term_expr:
//     | term_expr '*' factor_expr
//     | term_expr '/' factor_expr
//     | term_expr '%' factor_expr
//     | factor_expr
std::optional<ast::field<ast::expr>> Parser::parse_term_expr_rule()
{
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::term_expr>(_state)) {
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    while (true) {
        store_cached<RuleType::term_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_term_expr();
        if (!_raw || tell() <= _res_state) {
            break;
        }
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_term_expr()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // term_expr '*' factor_expr
        auto _user_opt_a = parse_term_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::STAR);
        if (_literal) {
        auto _user_opt_b = parse_factor_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            _res = ast::BinOp ( ast::Mul ( ) , std::move ( a ) , std::move ( b ) );
            return _res;
        }
        }
        }
        seek(_state);
    }
    { // term_expr '/' factor_expr
        auto _user_opt_a = parse_term_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::SLASH);
        if (_literal) {
        auto _user_opt_b = parse_factor_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            _res = ast::BinOp ( ast::Div ( ) , std::move ( a ) , std::move ( b ) );
            return _res;
        }
        }
        }
        seek(_state);
    }
    { // term_expr '%' factor_expr
        auto _user_opt_a = parse_term_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::PERCENT);
        if (_literal) {
        auto _user_opt_b = parse_factor_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            _res = ast::BinOp ( ast::Mod ( ) , std::move ( a ) , std::move ( b ) );
            return _res;
        }
        }
        }
        seek(_state);
    }
    { // factor_expr
        auto _single_result = parse_factor_expr_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    return std::nullopt;
}

// factor_expr: '+' factor_expr | '-' factor_expr | '~' factor_expr | power_expr
std::optional<ast::field<ast::expr>> Parser::parse_factor_expr_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '+' factor_expr
        auto _literal = lexer.expect().punct(lex::Punct::PLUS);
        if (_literal) {
        auto _user_opt_a = parse_factor_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            _res = ast::UnOp ( ast::UAdd ( ) , std::move ( a ) );
            return _res;
        }
        }
        seek(_state);
    }
    { // '-' factor_expr
        auto _literal = lexer.expect().punct(lex::Punct::MINUS);
        if (_literal) {
        auto _user_opt_a = parse_factor_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            _res = ast::UnOp ( ast::USub ( ) , std::move ( a ) );
            return _res;
        }
        }
        seek(_state);
    }
    { // '~' factor_expr
        auto _literal = lexer.expect().punct(lex::Punct::TILDE);
        if (_literal) {
        auto _user_opt_a = parse_factor_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            _res = ast::UnOp ( ast::BitInv ( ) , std::move ( a ) );
            return _res;
        }
        }
        seek(_state);
    }
    { // power_expr
        auto _single_result = parse_power_expr_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    return std::nullopt;
}

// power_expr: primary_expr '**' factor_expr | primary_expr
std::optional<ast::field<ast::expr>> Parser::parse_power_expr_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // primary_expr '**' factor_expr
        auto _user_opt_a = parse_primary_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::POWER);
        if (_literal) {
        auto _user_opt_b = parse_factor_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            _res = ast::BinOp ( ast::Pow ( ) , std::move ( a ) , std::move ( b ) );
            return _res;
        }
        }
        }
        seek(_state);
    }
    { // primary_expr
        auto _single_result = parse_primary_expr_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    return std::nullopt;
}

// Left-recursive
// primary_expr:
//     | primary_expr '.' name
//     | primary_expr '::' name
//     | primary_expr '[' call_args ']'
//     | primary_expr '(' call_args ')'
//     | atom_expr
std::optional<ast::field<ast::expr>> Parser::parse_primary_expr_rule()
{
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::primary_expr>(_state)) {
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    while (true) {
        store_cached<RuleType::primary_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_primary_expr();
        if (!_raw || tell() <= _res_state) {
            break;
        }
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_primary_expr()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // primary_expr '.' name
        auto _user_opt_a = parse_primary_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::DOT);
        if (_literal) {
        auto _user_opt_b = parse_name_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            _res = ast::Attribute ( std::move ( a ) , std::move ( b ) , ast::AttrInst ( ) );
            return _res;
        }
        }
        }
        seek(_state);
    }
    { // primary_expr '::' name
        auto _user_opt_a = parse_primary_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::DOUBLECOLON);
        if (_literal) {
        auto _user_opt_b = parse_name_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            _res = ast::Attribute ( std::move ( a ) , std::move ( b ) , ast::AttrStatic ( ) );
            return _res;
        }
        }
        }
        seek(_state);
    }
    { // primary_expr '[' call_args ']'
        auto _user_opt_a = parse_primary_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::LSQB);
        if (_literal) {
        auto _user_opt_b = parse_call_args_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _literal_1 = lexer.expect().punct(lex::Punct::RSQB);
        if (_literal_1) {
            _res = ast::Subscript ( std::move ( a ) , std::move ( b ) );
            return _res;
        }
        }
        }
        }
        seek(_state);
    }
    { // primary_expr '(' call_args ')'
        auto _user_opt_a = parse_primary_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::LPAR);
        if (_literal) {
        auto _user_opt_b = parse_call_args_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
        if (_literal_1) {
            _res = ast::Call ( std::move ( a ) , std::move ( b ) );
            return _res;
        }
        }
        }
        }
        seek(_state);
    }
    { // atom_expr
        auto _single_result = parse_atom_expr_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    return std::nullopt;
}

// atom_expr:
//     | name
//     | NUMBER
//     | &STRING strings
//     | group_expr
//     | tuple_expr
//     | array_expr
//     | block_expr
std::optional<ast::field<ast::expr>> Parser::parse_atom_expr_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // name
        auto _user_opt_a = parse_name_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            _res = ast::Name ( std::move ( a ) );
            return _res;
        }
        seek(_state);
    }
    { // NUMBER
        auto _user_opt_a = lexer.expect().token(lex::TokenType::number);
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            _res = ast::Constant ( util::variant_cast ( a . get_number ( ) . value ) );
            return _res;
        }
        seek(_state);
    }
    { // &STRING strings
        auto _tmpvar = lexer.lookahead(true).token(lex::TokenType::string);
        if (_tmpvar) {
        auto _user_opt_a = parse_strings_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            _res = ast::Constant ( std::move ( a ) );
            return _res;
        }
        }
        seek(_state);
    }
    { // group_expr
        auto _single_result = parse_group_expr_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    { // tuple_expr
        auto _single_result = parse_tuple_expr_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    { // array_expr
        auto _single_result = parse_array_expr_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    { // block_expr
        auto _single_result = parse_block_expr_rule();
        if (_single_result) {
            _res = std::move(_single_result);
            return _res;
        }
        seek(_state);
    }
    return std::nullopt;
}

// call_args: 
std::optional<ast::field<ast::call_args>> Parser::parse_call_args_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::call_args>> _res = std::nullopt;
    { // 
            _res = ast::call_args ( ast::make_sequence < ast::call_arg > ( ) , nullptr , nullptr );
            return _res;
        seek(_state);
    }
    return std::nullopt;
}

// name: NAME
std::optional<std::string> Parser::parse_name_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<std::string> _res = std::nullopt;
    { // NAME
        auto _user_opt_a = lexer.expect().token(lex::TokenType::name);
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            _res = a . get_name ( ) . value;
            return _res;
        }
        seek(_state);
    }
    return std::nullopt;
}

// strings: STRING+
std::optional<std::string> Parser::parse_strings_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<std::string> _res = std::nullopt;
    { // STRING+
        auto _user_opt_a = parse__loop1_6_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            _res = _concat_strings ( a );
            return _res;
        }
        seek(_state);
    }
    return std::nullopt;
}

// group_expr: '(' expr ')'
std::optional<ast::field<ast::expr>> Parser::parse_group_expr_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '(' expr ')'
        auto _literal = lexer.expect().punct(lex::Punct::LPAR);
        if (_literal) {
        auto _user_opt_a = parse_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
        if (_literal_1) {
            _res = std::move ( a );
            return _res;
        }
        }
        }
        seek(_state);
    }
    return std::nullopt;
}

// tuple_expr: '(' ')' | '(' ','.expr+ ','? ')'
std::optional<ast::field<ast::expr>> Parser::parse_tuple_expr_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '(' ')'
        auto _literal = lexer.expect().punct(lex::Punct::LPAR);
        if (_literal) {
        auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
        if (_literal_1) {
            _res = ast::Tuple ( ast::make_sequence < ast::expr > ( ) );
            return _res;
        }
        }
        seek(_state);
    }
    { // '(' ','.expr+ ','? ')'
        auto _literal = lexer.expect().punct(lex::Punct::LPAR);
        if (_literal) {
        auto _user_opt_a = parse__gather_7_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _opt_var = lexer.expect().punct(lex::Punct::COMMA);
        if (true) { (void)_opt_var;
        auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
        if (_literal_1) {
            _res = ast::Tuple ( std::move ( a ) );
            return _res;
        }
        }
        }
        }
        seek(_state);
    }
    return std::nullopt;
}

// array_expr: '[' ']' | '[' ','.expr+ ','? ']'
std::optional<ast::field<ast::expr>> Parser::parse_array_expr_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '[' ']'
        auto _literal = lexer.expect().punct(lex::Punct::LSQB);
        if (_literal) {
        auto _literal_1 = lexer.expect().punct(lex::Punct::RSQB);
        if (_literal_1) {
            _res = ast::Array ( ast::make_sequence < ast::expr > ( ) );
            return _res;
        }
        }
        seek(_state);
    }
    { // '[' ','.expr+ ','? ']'
        auto _literal = lexer.expect().punct(lex::Punct::LSQB);
        if (_literal) {
        auto _user_opt_a = parse__gather_9_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _opt_var = lexer.expect().punct(lex::Punct::COMMA);
        if (true) { (void)_opt_var;
        auto _literal_1 = lexer.expect().punct(lex::Punct::RSQB);
        if (_literal_1) {
            _res = ast::Array ( std::move ( a ) );
            return _res;
        }
        }
        }
        }
        seek(_state);
    }
    return std::nullopt;
}

// block_expr: 'ctime'? '{' stmt* expr_or_unit '}'
std::optional<ast::field<ast::expr>> Parser::parse_block_expr_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'ctime'? '{' stmt* expr_or_unit '}'
        auto _user_opt_c = lexer.expect().keyword(lex::HardKeyword::CTIME);
        if (true) { auto c = _user_opt_c;
        auto _literal = lexer.expect().punct(lex::Punct::LBRACE);
        if (_literal) {
        auto _user_opt_b = parse__loop0_11_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _user_opt_v = parse_expr_or_unit_rule();
        if (_user_opt_v) { auto v = std::move(*_user_opt_v);
        auto _literal_1 = lexer.expect().punct(lex::Punct::RBRACE);
        if (_literal_1) {
            _res = ast::Block ( std::move ( b ) , std::move ( v ) , bool ( c ) );
            return _res;
        }
        }
        }
        }
        }
        seek(_state);
    }
    return std::nullopt;
}

// type_annotation: ':' expr
std::optional<ast::field<ast::expr>> Parser::parse_type_annotation_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // ':' expr
        auto _literal = lexer.expect().punct(lex::Punct::COLON);
        if (_literal) {
        auto _user_opt_a = parse_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            _res = std::move ( a );
            return _res;
        }
        }
        seek(_state);
    }
    return std::nullopt;
}

// func_def: 'func' name '(' func_args_def ')' type_annotation? '=>' expr ';'
std::optional<ast::field<ast::expr>> Parser::parse_func_def_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'func' name '(' func_args_def ')' type_annotation? '=>' expr ';'
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::FUNC);
        if (_keyword) {
        auto _user_opt_n = parse_name_rule();
        if (_user_opt_n) { auto n = std::move(*_user_opt_n);
        auto _literal = lexer.expect().punct(lex::Punct::LPAR);
        if (_literal) {
        auto _user_opt_a = parse_func_args_def_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
        if (_literal_1) {
        auto _user_opt_t = parse_type_annotation_rule();
        if (true) { auto t = _user_opt_t;
        auto _literal_2 = lexer.expect().punct(lex::Punct::RARROW2);
        if (_literal_2) {
        auto _user_opt_b = parse_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _literal_3 = lexer.expect().punct(lex::Punct::SEMI);
        if (_literal_3) {
            _res = ast::FuncDef ( std::move ( n ) , std::move ( a ) , _opt2maybe ( std::move ( t ) ) , std::move ( b ) );
            return _res;
        }
        }
        }
        }
        }
        }
        }
        }
        }
        seek(_state);
    }
    return std::nullopt;
}

// func_args_def: 
std::optional<ast::field<ast::arg_defs>> Parser::parse_func_args_def_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::arg_defs>> _res = std::nullopt;
    { // 
            _res = ast::arg_defs ( ast::make_sequence < ast::arg_def > ( ) );
            return _res;
        seek(_state);
    }
    return std::nullopt;
}

// _loop0_1: stmt
std::optional<ast::sequence<ast::stmt>> Parser::parse__loop0_1_rule()
{
    auto _state = tell();
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    std::vector<ast::field<ast::stmt>> _children{};
    { // stmt
        while (true) {
            auto _single_result = parse_stmt_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
    }
    auto _seq = ast::make_sequence<ast::stmt>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    return _seq;
}

// _tmp_2: '=' expr
std::optional<ast::field<ast::expr>> Parser::parse__tmp_2_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '=' expr
        auto _literal = lexer.expect().punct(lex::Punct::EQUAL);
        if (_literal) {
        auto _user_opt_a = parse_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            _res = a;
            return _res;
        }
        }
        seek(_state);
    }
    return std::nullopt;
}

// _loop1_3: ('or' conjunction_expr)
std::optional<ast::sequence<ast::expr>> Parser::parse__loop1_3_rule()
{
    auto _state = tell();
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    std::vector<ast::field<ast::expr>> _children{};
    { // ('or' conjunction_expr)
        while (true) {
            auto _single_result = parse__tmp_12_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
    }
    if (_children.size() == 0) {
        return std::nullopt;
    }
    auto _seq = ast::make_sequence<ast::expr>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    return _seq;
}

// _loop1_4: ('and' inversion_expr)
std::optional<ast::sequence<ast::expr>> Parser::parse__loop1_4_rule()
{
    auto _state = tell();
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    std::vector<ast::field<ast::expr>> _children{};
    { // ('and' inversion_expr)
        while (true) {
            auto _single_result = parse__tmp_13_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
    }
    if (_children.size() == 0) {
        return std::nullopt;
    }
    auto _seq = ast::make_sequence<ast::expr>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    return _seq;
}

// _loop1_5: comparison_followup_pair
std::optional<std::vector<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>>> Parser::parse__loop1_5_rule()
{
    auto _state = tell();
    std::optional<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>> _res = std::nullopt;
    std::vector<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>> _children{};
    { // comparison_followup_pair
        while (true) {
            auto _single_result = parse_comparison_followup_pair_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
    }
    if (_children.size() == 0) {
        return std::nullopt;
    }
    return _children;
}

// _loop1_6: STRING
std::optional<std::vector<lex::Token>> Parser::parse__loop1_6_rule()
{
    auto _state = tell();
    std::optional<lex::Token> _res = std::nullopt;
    std::vector<lex::Token> _children{};
    { // STRING
        while (true) {
            auto _single_result = lexer.expect().token(lex::TokenType::string);
            if (_single_result) {
                _res = std::move(_single_result);
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
    }
    if (_children.size() == 0) {
        return std::nullopt;
    }
    return _children;
}

// _loop0_8: ',' expr
std::optional<ast::sequence<ast::expr>> Parser::parse__loop0_8_rule()
{
    auto _state = tell();
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    std::vector<ast::field<ast::expr>> _children{};
    { // ',' expr
        while (true) {
            auto _literal = lexer.expect().punct(lex::Punct::COMMA);
            if (_literal) {
            auto _user_opt_elem = parse_expr_rule();
            if (_user_opt_elem) { auto elem = std::move(*_user_opt_elem);
                _res = elem;
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            }
            break;
        }
        seek(_state);
    }
    auto _seq = ast::make_sequence<ast::expr>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    return _seq;
}

// _gather_7: expr _loop0_8
std::optional<ast::sequence<ast::expr>> Parser::parse__gather_7_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::sequence<ast::expr>> _res = std::nullopt;
    { // expr _loop0_8
        auto _user_opt_expr_var = parse_expr_rule();
        if (_user_opt_expr_var) { auto expr_var = std::move(*_user_opt_expr_var);
        auto _user_opt_seq = parse__loop0_8_rule();
        if (_user_opt_seq) { auto seq = std::move(*_user_opt_seq);
            _res = std::move(seq);
            return _res;
        }
        }
        seek(_state);
    }
    return std::nullopt;
}

// _loop0_10: ',' expr
std::optional<ast::sequence<ast::expr>> Parser::parse__loop0_10_rule()
{
    auto _state = tell();
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    std::vector<ast::field<ast::expr>> _children{};
    { // ',' expr
        while (true) {
            auto _literal = lexer.expect().punct(lex::Punct::COMMA);
            if (_literal) {
            auto _user_opt_elem = parse_expr_rule();
            if (_user_opt_elem) { auto elem = std::move(*_user_opt_elem);
                _res = elem;
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            }
            break;
        }
        seek(_state);
    }
    auto _seq = ast::make_sequence<ast::expr>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    return _seq;
}

// _gather_9: expr _loop0_10
std::optional<ast::sequence<ast::expr>> Parser::parse__gather_9_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::sequence<ast::expr>> _res = std::nullopt;
    { // expr _loop0_10
        auto _user_opt_expr_var = parse_expr_rule();
        if (_user_opt_expr_var) { auto expr_var = std::move(*_user_opt_expr_var);
        auto _user_opt_seq = parse__loop0_10_rule();
        if (_user_opt_seq) { auto seq = std::move(*_user_opt_seq);
            _res = std::move(seq);
            return _res;
        }
        }
        seek(_state);
    }
    return std::nullopt;
}

// _loop0_11: stmt
std::optional<ast::sequence<ast::stmt>> Parser::parse__loop0_11_rule()
{
    auto _state = tell();
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    std::vector<ast::field<ast::stmt>> _children{};
    { // stmt
        while (true) {
            auto _single_result = parse_stmt_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
    }
    auto _seq = ast::make_sequence<ast::stmt>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    return _seq;
}

// _tmp_12: 'or' conjunction_expr
std::optional<ast::field<ast::expr>> Parser::parse__tmp_12_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'or' conjunction_expr
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::OR);
        if (_keyword) {
        auto _user_opt_c = parse_conjunction_expr_rule();
        if (_user_opt_c) { auto c = std::move(*_user_opt_c);
            _res = c;
            return _res;
        }
        }
        seek(_state);
    }
    return std::nullopt;
}

// _tmp_13: 'and' inversion_expr
std::optional<ast::field<ast::expr>> Parser::parse__tmp_13_rule()
{
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'and' inversion_expr
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::AND);
        if (_keyword) {
        auto _user_opt_c = parse_inversion_expr_rule();
        if (_user_opt_c) { auto c = std::move(*_user_opt_c);
            _res = c;
            return _res;
        }
        }
        seek(_state);
    }
    return std::nullopt;
}

#pragma endregion Rule parsers


}  // namespace bondrewd::parse
