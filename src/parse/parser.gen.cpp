// AUTOGENERATED by bondrewd/tools/pegen++/pegenxx.py on 2023-04-19 18:53:36
// DO NOT EDIT

#include <bondrewd/parse/parser.gen.hpp>


#if 1
#define PARSER_DBG_(...)  fprintf(stderr, "[Parser] " __VA_ARGS__)
#else
#define PARSER_DBG_(...)
#endif


namespace bondrewd::parse {


#pragma region Rule parsers

// start: file
std::optional<ast::field<ast::file>> Parser::parse_start_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::file>> _res = std::nullopt;
    { // file
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "start", _state, tell(), "file");
        auto _single_result = parse_file_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "start", _state, tell(), "file");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "file");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "start", _state, tell(), "file");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "start");
    --_level;
    return std::nullopt;
}

// file: stmt* $
std::optional<ast::field<ast::file>> Parser::parse_file_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::file>> _res = std::nullopt;
    { // stmt* $
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "file", _state, tell(), "stmt* $");
        auto _user_opt_b = parse__loop0_1_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _token = lexer.expect().token(lex::TokenType::endmarker);
        if (_token) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "file", _state, tell(), "stmt* $");
            _res = ast::File ( std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "stmt* $");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "file", _state, tell(), "stmt* $");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "file");
    --_level;
    return std::nullopt;
}

// stmt: cartridge_header_stmt | assign_stmt | expr_stmt | pass_stmt
std::optional<ast::field<ast::stmt>> Parser::parse_stmt_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::stmt>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    { // cartridge_header_stmt
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "stmt", _state, tell(), "cartridge_header_stmt");
        auto _single_result = parse_cartridge_header_stmt_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "stmt", _state, tell(), "cartridge_header_stmt");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "cartridge_header_stmt");
            --_level;
            store_cached<RuleType::stmt>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "stmt", _state, tell(), "cartridge_header_stmt");
    }
    { // assign_stmt
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "stmt", _state, tell(), "assign_stmt");
        auto _single_result = parse_assign_stmt_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "stmt", _state, tell(), "assign_stmt");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "assign_stmt");
            --_level;
            store_cached<RuleType::stmt>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "stmt", _state, tell(), "assign_stmt");
    }
    { // expr_stmt
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "stmt", _state, tell(), "expr_stmt");
        auto _single_result = parse_expr_stmt_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "stmt", _state, tell(), "expr_stmt");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_stmt");
            --_level;
            store_cached<RuleType::stmt>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "stmt", _state, tell(), "expr_stmt");
    }
    { // pass_stmt
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "stmt", _state, tell(), "pass_stmt");
        auto _single_result = parse_pass_stmt_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "stmt", _state, tell(), "pass_stmt");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "pass_stmt");
            --_level;
            store_cached<RuleType::stmt>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "stmt", _state, tell(), "pass_stmt");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "stmt");
    --_level;
    store_cached<RuleType::stmt>(_state, std::nullopt);
    return std::nullopt;
}

// cartridge_header_stmt: 'cartridge' name ';'
std::optional<ast::field<ast::stmt>> Parser::parse_cartridge_header_stmt_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    { // 'cartridge' name ';'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "cartridge_header_stmt", _state, tell(), "'cartridge' name ';'");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::CARTRIDGE);
        if (_keyword) {
        auto _user_opt_n = parse_name_rule();
        if (_user_opt_n) { auto n = std::move(*_user_opt_n);
        auto _literal = lexer.expect().punct(lex::Punct::SEMI);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "cartridge_header_stmt", _state, tell(), "'cartridge' name ';'");
            _res = ast::CartridgeHeader ( std::move ( n ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'cartridge' name ';'");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "cartridge_header_stmt", _state, tell(), "'cartridge' name ';'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "cartridge_header_stmt");
    --_level;
    return std::nullopt;
}

// assign_stmt: expr assign_op expr ';'
std::optional<ast::field<ast::stmt>> Parser::parse_assign_stmt_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    { // expr assign_op expr ';'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_stmt", _state, tell(), "expr assign_op expr ';'");
        auto _user_opt_a = parse_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _user_opt_op = parse_assign_op_rule();
        if (_user_opt_op) { auto op = std::move(*_user_opt_op);
        auto _user_opt_b = parse_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _literal = lexer.expect().punct(lex::Punct::SEMI);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_stmt", _state, tell(), "expr assign_op expr ';'");
            _res = ast::Assign ( std::move ( a ) , std::move ( b ) , std::move ( op ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr assign_op expr ';'");
            --_level;
            return _res;
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_stmt", _state, tell(), "expr assign_op expr ';'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "assign_stmt");
    --_level;
    return std::nullopt;
}

// assign_op: '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '|=' | '^='
std::optional<ast::field<ast::assign_op>> Parser::parse_assign_op_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::assign_op>> _res = std::nullopt;
    { // '='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'='");
        auto _literal = lexer.expect().punct(lex::Punct::EQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'='");
            _res = ast::AsgnNone ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'='");
    }
    { // '+='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'+='");
        auto _literal = lexer.expect().punct(lex::Punct::PLUSEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'+='");
            _res = ast::AsgnAdd ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'+='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'+='");
    }
    { // '-='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'-='");
        auto _literal = lexer.expect().punct(lex::Punct::MINEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'-='");
            _res = ast::AsgnSub ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'-='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'-='");
    }
    { // '*='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'*='");
        auto _literal = lexer.expect().punct(lex::Punct::STAREQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'*='");
            _res = ast::AsgnMul ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'*='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'*='");
    }
    { // '/='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'/='");
        auto _literal = lexer.expect().punct(lex::Punct::SLASHEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'/='");
            _res = ast::AsgnDiv ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'/='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'/='");
    }
    { // '%='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'%='");
        auto _literal = lexer.expect().punct(lex::Punct::PERCENTEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'%='");
            _res = ast::AsgnMod ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'%='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'%='");
    }
    { // '<<='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'<<='");
        auto _literal = lexer.expect().punct(lex::Punct::LEFTSHIFTEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'<<='");
            _res = ast::AsgnLShift ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'<<='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'<<='");
    }
    { // '>>='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'>>='");
        auto _literal = lexer.expect().punct(lex::Punct::RIGHTSHIFTEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'>>='");
            _res = ast::AsgnRShift ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'>>='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'>>='");
    }
    { // '&='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'&='");
        auto _literal = lexer.expect().punct(lex::Punct::AMPEREQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'&='");
            _res = ast::AsgnBitAnd ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'&='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'&='");
    }
    { // '|='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'|='");
        auto _literal = lexer.expect().punct(lex::Punct::VBAREQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'|='");
            _res = ast::AsgnBitOr ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'|='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'|='");
    }
    { // '^='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'^='");
        auto _literal = lexer.expect().punct(lex::Punct::CIRCUMFLEXEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'^='");
            _res = ast::AsgnBitXor ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'^='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'^='");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "assign_op");
    --_level;
    return std::nullopt;
}

// expr_stmt: expr ';'
std::optional<ast::field<ast::stmt>> Parser::parse_expr_stmt_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    { // expr ';'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_stmt", _state, tell(), "expr ';'");
        auto _user_opt_a = parse_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::SEMI);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_stmt", _state, tell(), "expr ';'");
            _res = ast::Expr ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr ';'");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_stmt", _state, tell(), "expr ';'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expr_stmt");
    --_level;
    return std::nullopt;
}

// pass_stmt: ';'
std::optional<ast::field<ast::stmt>> Parser::parse_pass_stmt_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    { // ';'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "pass_stmt", _state, tell(), "';'");
        auto _literal = lexer.expect().punct(lex::Punct::SEMI);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "pass_stmt", _state, tell(), "';'");
            _res = ast::Pass ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "';'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "pass_stmt", _state, tell(), "';'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "pass_stmt");
    --_level;
    return std::nullopt;
}

// defn: xtime_flag raw_defn
std::optional<ast::field<ast::defn>> Parser::parse_defn_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::defn>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::defn>> _res = std::nullopt;
    { // xtime_flag raw_defn
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "defn", _state, tell(), "xtime_flag raw_defn");
        auto _user_opt_f = parse_xtime_flag_rule();
        if (_user_opt_f) { auto f = std::move(*_user_opt_f);
        auto _user_opt_a = parse_raw_defn_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "defn", _state, tell(), "xtime_flag raw_defn");
            _res = ( {a -> flag = std::move ( f ) ; a ;} );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "xtime_flag raw_defn");
            --_level;
            store_cached<RuleType::defn>(_state, _res);
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "defn", _state, tell(), "xtime_flag raw_defn");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "defn");
    --_level;
    store_cached<RuleType::defn>(_state, std::nullopt);
    return std::nullopt;
}

// raw_defn: var_def | func_def | struct_def | impl_def | ns_def | template_def
std::optional<ast::field<ast::defn>> Parser::parse_raw_defn_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::defn>> _res = std::nullopt;
    { // var_def
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "raw_defn", _state, tell(), "var_def");
        auto _single_result = parse_var_def_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "raw_defn", _state, tell(), "var_def");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "var_def");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "raw_defn", _state, tell(), "var_def");
    }
    { // func_def
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "raw_defn", _state, tell(), "func_def");
        auto _single_result = parse_func_def_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "raw_defn", _state, tell(), "func_def");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "func_def");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "raw_defn", _state, tell(), "func_def");
    }
    { // struct_def
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "raw_defn", _state, tell(), "struct_def");
        auto _single_result = parse_struct_def_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "raw_defn", _state, tell(), "struct_def");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "struct_def");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "raw_defn", _state, tell(), "struct_def");
    }
    { // impl_def
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "raw_defn", _state, tell(), "impl_def");
        auto _single_result = parse_impl_def_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "raw_defn", _state, tell(), "impl_def");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "impl_def");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "raw_defn", _state, tell(), "impl_def");
    }
    { // ns_def
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "raw_defn", _state, tell(), "ns_def");
        auto _single_result = parse_ns_def_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "raw_defn", _state, tell(), "ns_def");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "ns_def");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "raw_defn", _state, tell(), "ns_def");
    }
    { // template_def
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "raw_defn", _state, tell(), "template_def");
        auto _single_result = parse_template_def_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "raw_defn", _state, tell(), "template_def");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "template_def");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "raw_defn", _state, tell(), "template_def");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "raw_defn");
    --_level;
    return std::nullopt;
}

// var_def: 'var' name type_annotation? ['=' expr] ';'
std::optional<ast::field<ast::defn>> Parser::parse_var_def_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::defn>> _res = std::nullopt;
    { // 'var' name type_annotation? ['=' expr] ';'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "var_def", _state, tell(), "'var' name type_annotation? ['=' expr] ';'");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::VAR);
        if (_keyword) {
        auto _user_opt_n = parse_name_rule();
        if (_user_opt_n) { auto n = std::move(*_user_opt_n);
        auto _user_opt_t = parse_type_annotation_rule();
        if (true) { auto t = _user_opt_t;
        auto _user_opt_v = parse__tmp_2_rule();
        if (true) { auto v = _user_opt_v;
        auto _literal = lexer.expect().punct(lex::Punct::SEMI);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "var_def", _state, tell(), "'var' name type_annotation? ['=' expr] ';'");
            _res = ast::VarDef ( std::move ( n ) , _opt2maybe ( std::move ( t ) ) , _opt2maybe ( std::move ( v ) ) , true );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'var' name type_annotation? ['=' expr] ';'");
            --_level;
            return _res;
        }
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "var_def", _state, tell(), "'var' name type_annotation? ['=' expr] ';'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "var_def");
    --_level;
    return std::nullopt;
}

// func_def: 'func' name? '(' args_spec ')' type_annotation? '=>' expr
std::optional<ast::field<ast::defn>> Parser::parse_func_def_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::defn>> _res = std::nullopt;
    { // 'func' name? '(' args_spec ')' type_annotation? '=>' expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "func_def", _state, tell(), "'func' name? '(' args_spec ')' type_annotation? '=>' expr");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::FUNC);
        if (_keyword) {
        auto _user_opt_n = parse_name_rule();
        if (true) { auto n = _user_opt_n;
        auto _literal = lexer.expect().punct(lex::Punct::LPAR);
        if (_literal) {
        auto _user_opt_a = parse_args_spec_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
        if (_literal_1) {
        auto _user_opt_t = parse_type_annotation_rule();
        if (true) { auto t = _user_opt_t;
        auto _literal_2 = lexer.expect().punct(lex::Punct::RARROW2);
        if (_literal_2) {
        auto _user_opt_b = parse_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "func_def", _state, tell(), "'func' name? '(' args_spec ')' type_annotation? '=>' expr");
            _res = ast::FuncDef ( std::move ( n ) , std::move ( a ) , _opt2maybe ( std::move ( t ) ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'func' name? '(' args_spec ')' type_annotation? '=>' expr");
            --_level;
            return _res;
        }
        }
        }
        }
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "func_def", _state, tell(), "'func' name? '(' args_spec ')' type_annotation? '=>' expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "func_def");
    --_level;
    return std::nullopt;
}

// impl_def: 'impl' expr defn_block | 'impl' expr 'for' expr defn_block
std::optional<ast::field<ast::defn>> Parser::parse_impl_def_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::defn>> _res = std::nullopt;
    { // 'impl' expr defn_block
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "impl_def", _state, tell(), "'impl' expr defn_block");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::IMPL);
        if (_keyword) {
        auto _user_opt_c = parse_expr_rule();
        if (_user_opt_c) { auto c = std::move(*_user_opt_c);
        auto _user_opt_b = parse_defn_block_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "impl_def", _state, tell(), "'impl' expr defn_block");
            _res = ast::ImplDef ( std::move ( c ) , std::nullopt , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'impl' expr defn_block");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "impl_def", _state, tell(), "'impl' expr defn_block");
    }
    { // 'impl' expr 'for' expr defn_block
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "impl_def", _state, tell(), "'impl' expr 'for' expr defn_block");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::IMPL);
        if (_keyword) {
        auto _user_opt_t = parse_expr_rule();
        if (_user_opt_t) { auto t = std::move(*_user_opt_t);
        auto _keyword_1 = lexer.expect().keyword(lex::HardKeyword::FOR);
        if (_keyword_1) {
        auto _user_opt_c = parse_expr_rule();
        if (_user_opt_c) { auto c = std::move(*_user_opt_c);
        auto _user_opt_b = parse_defn_block_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "impl_def", _state, tell(), "'impl' expr 'for' expr defn_block");
            _res = ast::ImplDef ( std::move ( c ) , std::move ( t ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'impl' expr 'for' expr defn_block");
            --_level;
            return _res;
        }
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "impl_def", _state, tell(), "'impl' expr 'for' expr defn_block");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "impl_def");
    --_level;
    return std::nullopt;
}

// defn_block: '{' stmt* '}'
std::optional<ast::sequence < ast::stmt >> Parser::parse_defn_block_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::sequence < ast::stmt >> _res = std::nullopt;
    { // '{' stmt* '}'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "defn_block", _state, tell(), "'{' stmt* '}'");
        auto _literal = lexer.expect().punct(lex::Punct::LBRACE);
        if (_literal) {
        auto _single_result = parse__loop0_3_rule();
        if (_single_result) {
        auto _literal_1 = lexer.expect().punct(lex::Punct::RBRACE);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "defn_block", _state, tell(), "'{' stmt* '}'");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'{' stmt* '}'");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "defn_block", _state, tell(), "'{' stmt* '}'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "defn_block");
    --_level;
    return std::nullopt;
}

// struct_def: ('class' | 'struct') name? args_spec
std::optional<ast::field<ast::defn>> Parser::parse_struct_def_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::defn>> _res = std::nullopt;
    { // ('class' | 'struct') name? args_spec
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "struct_def", _state, tell(), "('class' | 'struct') name? args_spec");
        auto _tmp_4_var = parse__tmp_4_rule();
        if (_tmp_4_var) {
        auto _user_opt_n = parse_name_rule();
        if (true) { auto n = _user_opt_n;
        auto _user_opt_a = parse_args_spec_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "struct_def", _state, tell(), "('class' | 'struct') name? args_spec");
            _res = ast::StructDef ( std::move ( n ) , std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "('class' | 'struct') name? args_spec");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "struct_def", _state, tell(), "('class' | 'struct') name? args_spec");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "struct_def");
    --_level;
    return std::nullopt;
}

// ns_def: 'ns' ns_spec
std::optional<ast::field<ast::defn>> Parser::parse_ns_def_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::defn>> _res = std::nullopt;
    { // 'ns' ns_spec
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "ns_def", _state, tell(), "'ns' ns_spec");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::NAMESPACE);
        if (_keyword) {
        auto _single_result = parse_ns_spec_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "ns_def", _state, tell(), "'ns' ns_spec");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'ns' ns_spec");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "ns_def", _state, tell(), "'ns' ns_spec");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "ns_def");
    --_level;
    return std::nullopt;
}

// ns_spec: 'cartridge' '::' ns_spec_raw | ns_spec_raw
std::optional<ast::field<ast::defn>> Parser::parse_ns_spec_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::defn>> _res = std::nullopt;
    { // 'cartridge' '::' ns_spec_raw
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "ns_spec", _state, tell(), "'cartridge' '::' ns_spec_raw");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::CARTRIDGE);
        if (_keyword) {
        auto _literal = lexer.expect().punct(lex::Punct::DOUBLECOLON);
        if (_literal) {
        auto _user_opt_a = parse_ns_spec_raw_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "ns_spec", _state, tell(), "'cartridge' '::' ns_spec_raw");
            _res = ast::NsDef ( _prepend1 ( std::move ( "cartridge" ) , std::move ( a ) ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'cartridge' '::' ns_spec_raw");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "ns_spec", _state, tell(), "'cartridge' '::' ns_spec_raw");
    }
    { // ns_spec_raw
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "ns_spec", _state, tell(), "ns_spec_raw");
        auto _user_opt_a = parse_ns_spec_raw_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "ns_spec", _state, tell(), "ns_spec_raw");
            _res = ast::NsDef ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "ns_spec_raw");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "ns_spec", _state, tell(), "ns_spec_raw");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "ns_spec");
    --_level;
    return std::nullopt;
}

// ns_spec_raw: '::'.name+
std::optional<ast::sequence < ast::identifier >> Parser::parse_ns_spec_raw_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::sequence < ast::identifier >> _res = std::nullopt;
    { // '::'.name+
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "ns_spec_raw", _state, tell(), "'::'.name+");
        auto _user_opt_a = parse__gather_5_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "ns_spec_raw", _state, tell(), "'::'.name+");
            _res = std::move ( a );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'::'.name+");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "ns_spec_raw", _state, tell(), "'::'.name+");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "ns_spec_raw");
    --_level;
    return std::nullopt;
}

// template_def: 'template' '[' args_spec ']' defn
std::optional<ast::field<ast::defn>> Parser::parse_template_def_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::defn>> _res = std::nullopt;
    { // 'template' '[' args_spec ']' defn
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "template_def", _state, tell(), "'template' '[' args_spec ']' defn");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::TEMPLATE);
        if (_keyword) {
        auto _literal = lexer.expect().punct(lex::Punct::LSQB);
        if (_literal) {
        auto _user_opt_a = parse_args_spec_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal_1 = lexer.expect().punct(lex::Punct::RSQB);
        if (_literal_1) {
        auto _user_opt_b = parse_defn_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "template_def", _state, tell(), "'template' '[' args_spec ']' defn");
            _res = ast::TemplateDef ( std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'template' '[' args_spec ']' defn");
            --_level;
            return _res;
        }
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "template_def", _state, tell(), "'template' '[' args_spec ']' defn");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "template_def");
    --_level;
    return std::nullopt;
}

// args_spec: args_spec_nonempty ','? | 
std::optional<ast::field<ast::args_spec>> Parser::parse_args_spec_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::args_spec>> _res = std::nullopt;
    { // args_spec_nonempty ','?
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "args_spec", _state, tell(), "args_spec_nonempty ','?");
        auto _user_opt_a = parse_args_spec_nonempty_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _opt_var = lexer.expect().punct(lex::Punct::COMMA);
        if (true) { (void)_opt_var;
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "args_spec", _state, tell(), "args_spec_nonempty ','?");
            _res = std::move ( a );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "args_spec_nonempty ','?");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "args_spec", _state, tell(), "args_spec_nonempty ','?");
    }
    { // 
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "args_spec", _state, tell(), "");
        PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "args_spec", _state, tell(), "");
        _res = ast::args_spec ( ast::make_sequence < ast::arg_def > ( ) , false );
        PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "");
        --_level;
        return _res;
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "args_spec", _state, tell(), "");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "args_spec");
    --_level;
    return std::nullopt;
}

// args_spec_nonempty: "self" ((',' arg_spec))* | ','.arg_spec+
std::optional<ast::field<ast::args_spec>> Parser::parse_args_spec_nonempty_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::args_spec>> _res = std::nullopt;
    { // "self" ((',' arg_spec))*
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "args_spec_nonempty", _state, tell(), "\"self\" ((',' arg_spec))*");
        auto _keyword = lexer.expect().soft_keyword("self");
        if (_keyword) {
        auto _user_opt_a = parse__loop0_7_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "args_spec_nonempty", _state, tell(), "\"self\" ((',' arg_spec))*");
            _res = ast::args_spec ( std::move ( a ) , true );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), ""self" ((',' arg_spec))*");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "args_spec_nonempty", _state, tell(), "\"self\" ((',' arg_spec))*");
    }
    { // ','.arg_spec+
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "args_spec_nonempty", _state, tell(), "','.arg_spec+");
        auto _user_opt_a = parse__gather_8_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "args_spec_nonempty", _state, tell(), "','.arg_spec+");
            _res = ast::args_spec ( std::move ( a ) , false );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "','.arg_spec+");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "args_spec_nonempty", _state, tell(), "','.arg_spec+");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "args_spec_nonempty");
    --_level;
    return std::nullopt;
}

// arg_spec: name type_annotation [('=' expr)]
std::optional<ast::field<ast::arg_spec>> Parser::parse_arg_spec_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::arg_spec>> _res = std::nullopt;
    { // name type_annotation [('=' expr)]
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "arg_spec", _state, tell(), "name type_annotation [('=' expr)]");
        auto _user_opt_n = parse_name_rule();
        if (_user_opt_n) { auto n = std::move(*_user_opt_n);
        auto _user_opt_t = parse_type_annotation_rule();
        if (_user_opt_t) { auto t = std::move(*_user_opt_t);
        auto _user_opt_d = parse__tmp_10_rule();
        if (true) { auto d = _user_opt_d;
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "arg_spec", _state, tell(), "name type_annotation [('=' expr)]");
            _res = ast::arg_spec ( std::move ( n ) , std::move ( t ) , _opt2maybe ( std::move ( d ) ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "name type_annotation [('=' expr)]");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "arg_spec", _state, tell(), "name type_annotation [('=' expr)]");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "arg_spec");
    --_level;
    return std::nullopt;
}

// flow: xtime_flag raw_flow
std::optional<ast::field<ast::flow>> Parser::parse_flow_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::flow>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::flow>> _res = std::nullopt;
    { // xtime_flag raw_flow
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "flow", _state, tell(), "xtime_flag raw_flow");
        auto _user_opt_f = parse_xtime_flag_rule();
        if (_user_opt_f) { auto f = std::move(*_user_opt_f);
        auto _user_opt_a = parse_raw_flow_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "flow", _state, tell(), "xtime_flag raw_flow");
            _res = ( {a -> flag = std::move ( f ) ; a ;} );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "xtime_flag raw_flow");
            --_level;
            store_cached<RuleType::flow>(_state, _res);
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "flow", _state, tell(), "xtime_flag raw_flow");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "flow");
    --_level;
    store_cached<RuleType::flow>(_state, std::nullopt);
    return std::nullopt;
}

// raw_flow: if_flow | for_flow | while_flow | loop_flow
std::optional<ast::field<ast::flow>> Parser::parse_raw_flow_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::flow>> _res = std::nullopt;
    { // if_flow
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "raw_flow", _state, tell(), "if_flow");
        auto _single_result = parse_if_flow_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "raw_flow", _state, tell(), "if_flow");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "if_flow");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "raw_flow", _state, tell(), "if_flow");
    }
    { // for_flow
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "raw_flow", _state, tell(), "for_flow");
        auto _single_result = parse_for_flow_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "raw_flow", _state, tell(), "for_flow");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "for_flow");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "raw_flow", _state, tell(), "for_flow");
    }
    { // while_flow
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "raw_flow", _state, tell(), "while_flow");
        auto _single_result = parse_while_flow_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "raw_flow", _state, tell(), "while_flow");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "while_flow");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "raw_flow", _state, tell(), "while_flow");
    }
    { // loop_flow
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "raw_flow", _state, tell(), "loop_flow");
        auto _single_result = parse_loop_flow_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "raw_flow", _state, tell(), "loop_flow");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "loop_flow");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "raw_flow", _state, tell(), "loop_flow");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "raw_flow");
    --_level;
    return std::nullopt;
}

// if_flow: 'if' expr flow_block [('else' flow_block)]
std::optional<ast::field<ast::flow>> Parser::parse_if_flow_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::flow>> _res = std::nullopt;
    { // 'if' expr flow_block [('else' flow_block)]
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "if_flow", _state, tell(), "'if' expr flow_block [('else' flow_block)]");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::IF);
        if (_keyword) {
        auto _user_opt_c = parse_expr_rule();
        if (_user_opt_c) { auto c = std::move(*_user_opt_c);
        auto _user_opt_t = parse_flow_block_rule();
        if (_user_opt_t) { auto t = std::move(*_user_opt_t);
        auto _user_opt_e = parse__tmp_11_rule();
        if (true) { auto e = _user_opt_e;
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "if_flow", _state, tell(), "'if' expr flow_block [('else' flow_block)]");
            _res = ast::If ( std::move ( c ) , std::move ( t ) , _opt2maybe ( std::move ( e ) ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'if' expr flow_block [('else' flow_block)]");
            --_level;
            return _res;
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "if_flow", _state, tell(), "'if' expr flow_block [('else' flow_block)]");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "if_flow");
    --_level;
    return std::nullopt;
}

// for_flow: 'for' name 'in' expr flow_block [('else' flow_block)]
std::optional<ast::field<ast::flow>> Parser::parse_for_flow_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::flow>> _res = std::nullopt;
    { // 'for' name 'in' expr flow_block [('else' flow_block)]
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "for_flow", _state, tell(), "'for' name 'in' expr flow_block [('else' flow_block)]");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::FOR);
        if (_keyword) {
        auto _user_opt_v = parse_name_rule();
        if (_user_opt_v) { auto v = std::move(*_user_opt_v);
        auto _keyword_1 = lexer.expect().keyword(lex::HardKeyword::IN);
        if (_keyword_1) {
        auto _user_opt_s = parse_expr_rule();
        if (_user_opt_s) { auto s = std::move(*_user_opt_s);
        auto _user_opt_b = parse_flow_block_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _user_opt_e = parse__tmp_12_rule();
        if (true) { auto e = _user_opt_e;
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "for_flow", _state, tell(), "'for' name 'in' expr flow_block [('else' flow_block)]");
            _res = ast::For ( std::move ( v ) , std::move ( s ) , std::move ( b ) , _opt2maybe ( std::move ( e ) ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'for' name 'in' expr flow_block [('else' flow_block)]");
            --_level;
            return _res;
        }
        }
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "for_flow", _state, tell(), "'for' name 'in' expr flow_block [('else' flow_block)]");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "for_flow");
    --_level;
    return std::nullopt;
}

// while_flow: 'while' expr flow_block [('else' flow_block)]
std::optional<ast::field<ast::flow>> Parser::parse_while_flow_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::flow>> _res = std::nullopt;
    { // 'while' expr flow_block [('else' flow_block)]
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "while_flow", _state, tell(), "'while' expr flow_block [('else' flow_block)]");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::WHILE);
        if (_keyword) {
        auto _user_opt_c = parse_expr_rule();
        if (_user_opt_c) { auto c = std::move(*_user_opt_c);
        auto _user_opt_b = parse_flow_block_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _user_opt_e = parse__tmp_13_rule();
        if (true) { auto e = _user_opt_e;
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "while_flow", _state, tell(), "'while' expr flow_block [('else' flow_block)]");
            _res = ast::While ( std::move ( c ) , std::move ( b ) , _opt2maybe ( std::move ( e ) ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'while' expr flow_block [('else' flow_block)]");
            --_level;
            return _res;
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "while_flow", _state, tell(), "'while' expr flow_block [('else' flow_block)]");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "while_flow");
    --_level;
    return std::nullopt;
}

// loop_flow: 'loop' flow_block
std::optional<ast::field<ast::flow>> Parser::parse_loop_flow_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::flow>> _res = std::nullopt;
    { // 'loop' flow_block
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "loop_flow", _state, tell(), "'loop' flow_block");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::LOOP);
        if (_keyword) {
        auto _user_opt_b = parse_flow_block_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "loop_flow", _state, tell(), "'loop' flow_block");
            _res = ast::Loop ( std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'loop' flow_block");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "loop_flow", _state, tell(), "'loop' flow_block");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "loop_flow");
    --_level;
    return std::nullopt;
}

// flow_block: block_expr | flow_expr | flow_control_expr
std::optional<ast::field<ast::expr>> Parser::parse_flow_block_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // block_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "flow_block", _state, tell(), "block_expr");
        auto _single_result = parse_block_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "flow_block", _state, tell(), "block_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "block_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "flow_block", _state, tell(), "block_expr");
    }
    { // flow_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "flow_block", _state, tell(), "flow_expr");
        auto _single_result = parse_flow_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "flow_block", _state, tell(), "flow_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "flow_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "flow_block", _state, tell(), "flow_expr");
    }
    { // flow_control_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "flow_block", _state, tell(), "flow_control_expr");
        auto _single_result = parse_flow_control_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "flow_block", _state, tell(), "flow_control_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "flow_control_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "flow_block", _state, tell(), "flow_control_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "flow_block");
    --_level;
    return std::nullopt;
}

// expr_or_unit: expr | 
std::optional<ast::field<ast::expr>> Parser::parse_expr_or_unit_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_or_unit", _state, tell(), "expr");
        auto _single_result = parse_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_or_unit", _state, tell(), "expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_or_unit", _state, tell(), "expr");
    }
    { // 
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_or_unit", _state, tell(), "");
        PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_or_unit", _state, tell(), "");
        _res = ast::Constant ( std::monostate ( ) );
        PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "");
        --_level;
        return _res;
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_or_unit", _state, tell(), "");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expr_or_unit");
    --_level;
    return std::nullopt;
}

// expr: defn_expr | flow_expr | expr_0
std::optional<ast::field<ast::expr>> Parser::parse_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // defn_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr", _state, tell(), "defn_expr");
        auto _single_result = parse_defn_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr", _state, tell(), "defn_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "defn_expr");
            --_level;
            store_cached<RuleType::expr>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr", _state, tell(), "defn_expr");
    }
    { // flow_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr", _state, tell(), "flow_expr");
        auto _single_result = parse_flow_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr", _state, tell(), "flow_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "flow_expr");
            --_level;
            store_cached<RuleType::expr>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr", _state, tell(), "flow_expr");
    }
    { // expr_0
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr", _state, tell(), "expr_0");
        auto _single_result = parse_expr_0_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr", _state, tell(), "expr_0");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_0");
            --_level;
            store_cached<RuleType::expr>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr", _state, tell(), "expr_0");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expr");
    --_level;
    store_cached<RuleType::expr>(_state, std::nullopt);
    return std::nullopt;
}

// defn_expr: defn
std::optional<ast::field<ast::expr>> Parser::parse_defn_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // defn
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "defn_expr", _state, tell(), "defn");
        auto _user_opt_a = parse_defn_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "defn_expr", _state, tell(), "defn");
            _res = ast::Defn ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "defn");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "defn_expr", _state, tell(), "defn");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "defn_expr");
    --_level;
    return std::nullopt;
}

// flow_expr: flow
std::optional<ast::field<ast::expr>> Parser::parse_flow_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // flow
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "flow_expr", _state, tell(), "flow");
        auto _user_opt_a = parse_flow_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "flow_expr", _state, tell(), "flow");
            _res = ast::Flow ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "flow");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "flow_expr", _state, tell(), "flow");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "flow_expr");
    --_level;
    return std::nullopt;
}

// expr_0: and_expr | or_expr | expr_1
std::optional<ast::field<ast::expr>> Parser::parse_expr_0_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::expr_0>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // and_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_0", _state, tell(), "and_expr");
        auto _single_result = parse_and_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_0", _state, tell(), "and_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "and_expr");
            --_level;
            store_cached<RuleType::expr_0>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_0", _state, tell(), "and_expr");
    }
    { // or_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_0", _state, tell(), "or_expr");
        auto _single_result = parse_or_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_0", _state, tell(), "or_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "or_expr");
            --_level;
            store_cached<RuleType::expr_0>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_0", _state, tell(), "or_expr");
    }
    { // expr_1
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_0", _state, tell(), "expr_1");
        auto _single_result = parse_expr_1_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_0", _state, tell(), "expr_1");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_1");
            --_level;
            store_cached<RuleType::expr_0>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_0", _state, tell(), "expr_1");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expr_0");
    --_level;
    store_cached<RuleType::expr_0>(_state, std::nullopt);
    return std::nullopt;
}

// and_expr: expr_2 (('and' expr_1))+
std::optional<ast::field<ast::expr>> Parser::parse_and_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // expr_2 (('and' expr_1))+
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "and_expr", _state, tell(), "expr_2 (('and' expr_1))+");
        auto _user_opt_a = parse_expr_2_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _user_opt_b = parse__loop1_14_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "and_expr", _state, tell(), "expr_2 (('and' expr_1))+");
            _res = ast::BoolOp ( ast::And ( ) , _prepend1 ( a , b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_2 (('and' expr_1))+");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "and_expr", _state, tell(), "expr_2 (('and' expr_1))+");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "and_expr");
    --_level;
    return std::nullopt;
}

// or_expr: expr_2 (('or' expr_1))+
std::optional<ast::field<ast::expr>> Parser::parse_or_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // expr_2 (('or' expr_1))+
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "or_expr", _state, tell(), "expr_2 (('or' expr_1))+");
        auto _user_opt_a = parse_expr_2_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _user_opt_b = parse__loop1_15_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "or_expr", _state, tell(), "expr_2 (('or' expr_1))+");
            _res = ast::BoolOp ( ast::Or ( ) , _prepend1 ( a , b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_2 (('or' expr_1))+");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "or_expr", _state, tell(), "expr_2 (('or' expr_1))+");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "or_expr");
    --_level;
    return std::nullopt;
}

// expr_1: not_expr | expand_expr | flow_control_expr | expr_2
std::optional<ast::field<ast::expr>> Parser::parse_expr_1_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // not_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_1", _state, tell(), "not_expr");
        auto _single_result = parse_not_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_1", _state, tell(), "not_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "not_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_1", _state, tell(), "not_expr");
    }
    { // expand_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_1", _state, tell(), "expand_expr");
        auto _single_result = parse_expand_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_1", _state, tell(), "expand_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expand_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_1", _state, tell(), "expand_expr");
    }
    { // flow_control_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_1", _state, tell(), "flow_control_expr");
        auto _single_result = parse_flow_control_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_1", _state, tell(), "flow_control_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "flow_control_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_1", _state, tell(), "flow_control_expr");
    }
    { // expr_2
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_1", _state, tell(), "expr_2");
        auto _single_result = parse_expr_2_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_1", _state, tell(), "expr_2");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_2");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_1", _state, tell(), "expr_2");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expr_1");
    --_level;
    return std::nullopt;
}

// not_expr: 'not' expr_1
std::optional<ast::field<ast::expr>> Parser::parse_not_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'not' expr_1
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "not_expr", _state, tell(), "'not' expr_1");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::NOT);
        if (_keyword) {
        auto _user_opt_a = parse_expr_1_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "not_expr", _state, tell(), "'not' expr_1");
            _res = ast::UnOp ( ast::Not ( ) , std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'not' expr_1");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "not_expr", _state, tell(), "'not' expr_1");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "not_expr");
    --_level;
    return std::nullopt;
}

// expand_expr: 'expand' expr_1
std::optional<ast::field<ast::expr>> Parser::parse_expand_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'expand' expr_1
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expand_expr", _state, tell(), "'expand' expr_1");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::EXPAND);
        if (_keyword) {
        auto _user_opt_a = parse_expr_1_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expand_expr", _state, tell(), "'expand' expr_1");
            _res = ast::Expand ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'expand' expr_1");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expand_expr", _state, tell(), "'expand' expr_1");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expand_expr");
    --_level;
    return std::nullopt;
}

// flow_control_expr: return_expr | break_expr | continue_expr
std::optional<ast::field<ast::expr>> Parser::parse_flow_control_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // return_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "flow_control_expr", _state, tell(), "return_expr");
        auto _single_result = parse_return_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "flow_control_expr", _state, tell(), "return_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "return_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "flow_control_expr", _state, tell(), "return_expr");
    }
    { // break_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "flow_control_expr", _state, tell(), "break_expr");
        auto _single_result = parse_break_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "flow_control_expr", _state, tell(), "break_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "break_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "flow_control_expr", _state, tell(), "break_expr");
    }
    { // continue_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "flow_control_expr", _state, tell(), "continue_expr");
        auto _single_result = parse_continue_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "flow_control_expr", _state, tell(), "continue_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "continue_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "flow_control_expr", _state, tell(), "continue_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "flow_control_expr");
    --_level;
    return std::nullopt;
}

// return_expr: 'return' expr_or_unit
std::optional<ast::field<ast::expr>> Parser::parse_return_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'return' expr_or_unit
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "return_expr", _state, tell(), "'return' expr_or_unit");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::RETURN);
        if (_keyword) {
        auto _user_opt_a = parse_expr_or_unit_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "return_expr", _state, tell(), "'return' expr_or_unit");
            _res = ast::Return ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'return' expr_or_unit");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "return_expr", _state, tell(), "'return' expr_or_unit");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "return_expr");
    --_level;
    return std::nullopt;
}

// break_expr: 'break' expr_or_unit
std::optional<ast::field<ast::expr>> Parser::parse_break_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'break' expr_or_unit
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "break_expr", _state, tell(), "'break' expr_or_unit");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::BREAK);
        if (_keyword) {
        auto _user_opt_a = parse_expr_or_unit_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "break_expr", _state, tell(), "'break' expr_or_unit");
            _res = ast::Break ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'break' expr_or_unit");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "break_expr", _state, tell(), "'break' expr_or_unit");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "break_expr");
    --_level;
    return std::nullopt;
}

// continue_expr: 'continue'
std::optional<ast::field<ast::expr>> Parser::parse_continue_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'continue'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "continue_expr", _state, tell(), "'continue'");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::CONTINUE);
        if (_keyword) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "continue_expr", _state, tell(), "'continue'");
            _res = ast::Continue ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'continue'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "continue_expr", _state, tell(), "'continue'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "continue_expr");
    --_level;
    return std::nullopt;
}

// expr_2: comparison_expr | bidir_cmp_expr | expr_3
std::optional<ast::field<ast::expr>> Parser::parse_expr_2_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // comparison_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_2", _state, tell(), "comparison_expr");
        auto _single_result = parse_comparison_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_2", _state, tell(), "comparison_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "comparison_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_2", _state, tell(), "comparison_expr");
    }
    { // bidir_cmp_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_2", _state, tell(), "bidir_cmp_expr");
        auto _single_result = parse_bidir_cmp_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_2", _state, tell(), "bidir_cmp_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bidir_cmp_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_2", _state, tell(), "bidir_cmp_expr");
    }
    { // expr_3
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_2", _state, tell(), "expr_3");
        auto _single_result = parse_expr_3_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_2", _state, tell(), "expr_3");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_3");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_2", _state, tell(), "expr_3");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expr_2");
    --_level;
    return std::nullopt;
}

// comparison_expr: expr_3 comparison_followup_pair+
std::optional<ast::field<ast::expr>> Parser::parse_comparison_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // expr_3 comparison_followup_pair+
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_expr", _state, tell(), "expr_3 comparison_followup_pair+");
        auto _user_opt_f = parse_expr_3_rule();
        if (_user_opt_f) { auto f = std::move(*_user_opt_f);
        auto _user_opt_n = parse__loop1_16_rule();
        if (_user_opt_n) { auto n = std::move(*_user_opt_n);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_expr", _state, tell(), "expr_3 comparison_followup_pair+");
            _res = ast::Compare ( std::move ( f ) , ast::make_sequence < ast::cmp_op > ( ) , ast::make_sequence < ast::expr > ( ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_3 comparison_followup_pair+");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_expr", _state, tell(), "expr_3 comparison_followup_pair+");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "comparison_expr");
    --_level;
    return std::nullopt;
}

// comparison_followup_pair: comparison_op expr_3
std::optional<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>> Parser::parse_comparison_followup_pair_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>> _res = std::nullopt;
    { // comparison_op expr_3
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_followup_pair", _state, tell(), "comparison_op expr_3");
        auto _user_opt_o = parse_comparison_op_rule();
        if (_user_opt_o) { auto o = std::move(*_user_opt_o);
        auto _user_opt_a = parse_expr_3_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_followup_pair", _state, tell(), "comparison_op expr_3");
            _res = std::make_pair ( std::move ( o ) , std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "comparison_op expr_3");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_followup_pair", _state, tell(), "comparison_op expr_3");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "comparison_followup_pair");
    --_level;
    return std::nullopt;
}

// comparison_op: '==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in'
std::optional<ast::field<ast::cmp_op>> Parser::parse_comparison_op_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::cmp_op>> _res = std::nullopt;
    { // '=='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'=='");
        auto _literal = lexer.expect().punct(lex::Punct::DOUBLEEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'=='");
            _res = ast::Eq ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'=='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'=='");
    }
    { // '!='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'!='");
        auto _literal = lexer.expect().punct(lex::Punct::NOTEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'!='");
            _res = ast::NotEq ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'!='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'!='");
    }
    { // '<'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'<'");
        auto _literal = lexer.expect().punct(lex::Punct::LESS);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'<'");
            _res = ast::Lt ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'<'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'<'");
    }
    { // '<='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'<='");
        auto _literal = lexer.expect().punct(lex::Punct::LESSEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'<='");
            _res = ast::LtE ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'<='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'<='");
    }
    { // '>'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'>'");
        auto _literal = lexer.expect().punct(lex::Punct::GREATER);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'>'");
            _res = ast::Gt ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'>'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'>'");
    }
    { // '>='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'>='");
        auto _literal = lexer.expect().punct(lex::Punct::GREATEREQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'>='");
            _res = ast::GtE ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'>='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'>='");
    }
    { // 'in'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'in'");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::IN);
        if (_keyword) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'in'");
            _res = ast::In ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'in'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'in'");
    }
    { // 'not' 'in'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'not' 'in'");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::NOT);
        if (_keyword) {
        auto _keyword_1 = lexer.expect().keyword(lex::HardKeyword::IN);
        if (_keyword_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'not' 'in'");
            _res = ast::NotIn ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'not' 'in'");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'not' 'in'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "comparison_op");
    --_level;
    return std::nullopt;
}

// bidir_cmp_expr: expr_3 '<=>' expr_3
std::optional<ast::field<ast::expr>> Parser::parse_bidir_cmp_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // expr_3 '<=>' expr_3
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bidir_cmp_expr", _state, tell(), "expr_3 '<=>' expr_3");
        auto _user_opt_a = parse_expr_3_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::BIDIRCMP);
        if (_literal) {
        auto _user_opt_b = parse_expr_3_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bidir_cmp_expr", _state, tell(), "expr_3 '<=>' expr_3");
            _res = ast::BinOp ( ast::BidirCmp ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_3 '<=>' expr_3");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bidir_cmp_expr", _state, tell(), "expr_3 '<=>' expr_3");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "bidir_cmp_expr");
    --_level;
    return std::nullopt;
}

// expr_3: arithm_expr | bitwise_expr | expr_4
std::optional<ast::field<ast::expr>> Parser::parse_expr_3_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // arithm_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_3", _state, tell(), "arithm_expr");
        auto _single_result = parse_arithm_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_3", _state, tell(), "arithm_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "arithm_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_3", _state, tell(), "arithm_expr");
    }
    { // bitwise_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_3", _state, tell(), "bitwise_expr");
        auto _single_result = parse_bitwise_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_3", _state, tell(), "bitwise_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bitwise_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_3", _state, tell(), "bitwise_expr");
    }
    { // expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_3", _state, tell(), "expr_4");
        auto _single_result = parse_expr_4_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_3", _state, tell(), "expr_4");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_4");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_3", _state, tell(), "expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expr_3");
    --_level;
    return std::nullopt;
}

// arithm_expr: sum_expr | product_expr
std::optional<ast::field<ast::expr>> Parser::parse_arithm_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // sum_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "arithm_expr", _state, tell(), "sum_expr");
        auto _single_result = parse_sum_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "arithm_expr", _state, tell(), "sum_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "sum_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "arithm_expr", _state, tell(), "sum_expr");
    }
    { // product_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "arithm_expr", _state, tell(), "product_expr");
        auto _single_result = parse_product_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "arithm_expr", _state, tell(), "product_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "product_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "arithm_expr", _state, tell(), "product_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "arithm_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// sum_expr: (sum_expr | product_expr) sum_bin_op product_expr
std::optional<ast::field<ast::expr>> Parser::parse_sum_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::sum_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    bool _first = true;
    while (true) {
        store_cached<RuleType::sum_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_sum_expr();
        if (!_raw || (tell() <= _res_state && !_first)) {
            break;
        }
        _first = false;
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    --_level;
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_sum_expr()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // (sum_expr | product_expr) sum_bin_op product_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "sum_expr", _state, tell(), "(sum_expr | product_expr) sum_bin_op product_expr");
        auto _user_opt_a = parse__tmp_17_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _user_opt_o = parse_sum_bin_op_rule();
        if (_user_opt_o) { auto o = std::move(*_user_opt_o);
        auto _user_opt_b = parse_product_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "sum_expr", _state, tell(), "(sum_expr | product_expr) sum_bin_op product_expr");
            _res = ast::BinOp ( std::move ( o ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "(sum_expr | product_expr) sum_bin_op product_expr");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "sum_expr", _state, tell(), "(sum_expr | product_expr) sum_bin_op product_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "sum_expr");
    --_level;
    return std::nullopt;
}

// sum_bin_op: '+' | '-'
std::optional<ast::field<ast::binary_op>> Parser::parse_sum_bin_op_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::binary_op>> _res = std::nullopt;
    { // '+'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "sum_bin_op", _state, tell(), "'+'");
        auto _literal = lexer.expect().punct(lex::Punct::PLUS);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "sum_bin_op", _state, tell(), "'+'");
            _res = ast::Add ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'+'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "sum_bin_op", _state, tell(), "'+'");
    }
    { // '-'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "sum_bin_op", _state, tell(), "'-'");
        auto _literal = lexer.expect().punct(lex::Punct::MINUS);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "sum_bin_op", _state, tell(), "'-'");
            _res = ast::Sub ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'-'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "sum_bin_op", _state, tell(), "'-'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "sum_bin_op");
    --_level;
    return std::nullopt;
}

// Left-recursive
// product_expr: (product_expr | expr_4) product_bin_op expr_4
std::optional<ast::field<ast::expr>> Parser::parse_product_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::product_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    bool _first = true;
    while (true) {
        store_cached<RuleType::product_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_product_expr();
        if (!_raw || (tell() <= _res_state && !_first)) {
            break;
        }
        _first = false;
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    --_level;
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_product_expr()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // (product_expr | expr_4) product_bin_op expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "product_expr", _state, tell(), "(product_expr | expr_4) product_bin_op expr_4");
        auto _user_opt_a = parse__tmp_18_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _user_opt_o = parse_product_bin_op_rule();
        if (_user_opt_o) { auto o = std::move(*_user_opt_o);
        auto _user_opt_b = parse_expr_4_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "product_expr", _state, tell(), "(product_expr | expr_4) product_bin_op expr_4");
            _res = ast::BinOp ( std::move ( o ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "(product_expr | expr_4) product_bin_op expr_4");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "product_expr", _state, tell(), "(product_expr | expr_4) product_bin_op expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "product_expr");
    --_level;
    return std::nullopt;
}

// product_bin_op: '*' | '/' | '%'
std::optional<ast::field<ast::binary_op>> Parser::parse_product_bin_op_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::binary_op>> _res = std::nullopt;
    { // '*'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "product_bin_op", _state, tell(), "'*'");
        auto _literal = lexer.expect().punct(lex::Punct::STAR);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "product_bin_op", _state, tell(), "'*'");
            _res = ast::Mul ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'*'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "product_bin_op", _state, tell(), "'*'");
    }
    { // '/'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "product_bin_op", _state, tell(), "'/'");
        auto _literal = lexer.expect().punct(lex::Punct::SLASH);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "product_bin_op", _state, tell(), "'/'");
            _res = ast::Div ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'/'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "product_bin_op", _state, tell(), "'/'");
    }
    { // '%'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "product_bin_op", _state, tell(), "'%'");
        auto _literal = lexer.expect().punct(lex::Punct::PERCENT);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "product_bin_op", _state, tell(), "'%'");
            _res = ast::Mod ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'%'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "product_bin_op", _state, tell(), "'%'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "product_bin_op");
    --_level;
    return std::nullopt;
}

// bitwise_expr: bitor_expr | bitand_expr | bitxor_expr | shift_expr
std::optional<ast::field<ast::expr>> Parser::parse_bitwise_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // bitor_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bitwise_expr", _state, tell(), "bitor_expr");
        auto _single_result = parse_bitor_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bitwise_expr", _state, tell(), "bitor_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bitor_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bitwise_expr", _state, tell(), "bitor_expr");
    }
    { // bitand_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bitwise_expr", _state, tell(), "bitand_expr");
        auto _single_result = parse_bitand_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bitwise_expr", _state, tell(), "bitand_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bitand_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bitwise_expr", _state, tell(), "bitand_expr");
    }
    { // bitxor_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bitwise_expr", _state, tell(), "bitxor_expr");
        auto _single_result = parse_bitxor_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bitwise_expr", _state, tell(), "bitxor_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bitxor_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bitwise_expr", _state, tell(), "bitxor_expr");
    }
    { // shift_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bitwise_expr", _state, tell(), "shift_expr");
        auto _single_result = parse_shift_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bitwise_expr", _state, tell(), "shift_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "shift_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bitwise_expr", _state, tell(), "shift_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "bitwise_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// bitor_expr: (bitor_expr | expr_4) '|' expr_4
std::optional<ast::field<ast::expr>> Parser::parse_bitor_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::bitor_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    bool _first = true;
    while (true) {
        store_cached<RuleType::bitor_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_bitor_expr();
        if (!_raw || (tell() <= _res_state && !_first)) {
            break;
        }
        _first = false;
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    --_level;
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_bitor_expr()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // (bitor_expr | expr_4) '|' expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bitor_expr", _state, tell(), "(bitor_expr | expr_4) '|' expr_4");
        auto _user_opt_a = parse__tmp_19_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::VBAR);
        if (_literal) {
        auto _user_opt_b = parse_expr_4_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bitor_expr", _state, tell(), "(bitor_expr | expr_4) '|' expr_4");
            _res = ast::BinOp ( ast::BitOr ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "(bitor_expr | expr_4) '|' expr_4");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bitor_expr", _state, tell(), "(bitor_expr | expr_4) '|' expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "bitor_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// bitand_expr: (bitand_expr | expr_4) '&' expr_4
std::optional<ast::field<ast::expr>> Parser::parse_bitand_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::bitand_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    bool _first = true;
    while (true) {
        store_cached<RuleType::bitand_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_bitand_expr();
        if (!_raw || (tell() <= _res_state && !_first)) {
            break;
        }
        _first = false;
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    --_level;
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_bitand_expr()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // (bitand_expr | expr_4) '&' expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bitand_expr", _state, tell(), "(bitand_expr | expr_4) '&' expr_4");
        auto _user_opt_a = parse__tmp_20_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::AMPER);
        if (_literal) {
        auto _user_opt_b = parse_expr_4_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bitand_expr", _state, tell(), "(bitand_expr | expr_4) '&' expr_4");
            _res = ast::BinOp ( ast::BitAnd ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "(bitand_expr | expr_4) '&' expr_4");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bitand_expr", _state, tell(), "(bitand_expr | expr_4) '&' expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "bitand_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// bitxor_expr: (bitxor_expr | expr_4) '^' expr_4
std::optional<ast::field<ast::expr>> Parser::parse_bitxor_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::bitxor_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    bool _first = true;
    while (true) {
        store_cached<RuleType::bitxor_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_bitxor_expr();
        if (!_raw || (tell() <= _res_state && !_first)) {
            break;
        }
        _first = false;
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    --_level;
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_bitxor_expr()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // (bitxor_expr | expr_4) '^' expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bitxor_expr", _state, tell(), "(bitxor_expr | expr_4) '^' expr_4");
        auto _user_opt_a = parse__tmp_21_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::CIRCUMFLEX);
        if (_literal) {
        auto _user_opt_b = parse_expr_4_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bitxor_expr", _state, tell(), "(bitxor_expr | expr_4) '^' expr_4");
            _res = ast::BinOp ( ast::BitXor ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "(bitxor_expr | expr_4) '^' expr_4");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bitxor_expr", _state, tell(), "(bitxor_expr | expr_4) '^' expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "bitxor_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// shift_expr: (shift_expr | expr_4) shift_bin_op expr_4
std::optional<ast::field<ast::expr>> Parser::parse_shift_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::shift_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    bool _first = true;
    while (true) {
        store_cached<RuleType::shift_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_shift_expr();
        if (!_raw || (tell() <= _res_state && !_first)) {
            break;
        }
        _first = false;
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    --_level;
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_shift_expr()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // (shift_expr | expr_4) shift_bin_op expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "shift_expr", _state, tell(), "(shift_expr | expr_4) shift_bin_op expr_4");
        auto _user_opt_a = parse__tmp_22_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _user_opt_o = parse_shift_bin_op_rule();
        if (_user_opt_o) { auto o = std::move(*_user_opt_o);
        auto _user_opt_b = parse_expr_4_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "shift_expr", _state, tell(), "(shift_expr | expr_4) shift_bin_op expr_4");
            _res = ast::BinOp ( std::move ( o ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "(shift_expr | expr_4) shift_bin_op expr_4");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "shift_expr", _state, tell(), "(shift_expr | expr_4) shift_bin_op expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "shift_expr");
    --_level;
    return std::nullopt;
}

// shift_bin_op: '<<' | '>>'
std::optional<ast::field<ast::binary_op>> Parser::parse_shift_bin_op_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::binary_op>> _res = std::nullopt;
    { // '<<'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "shift_bin_op", _state, tell(), "'<<'");
        auto _literal = lexer.expect().punct(lex::Punct::LEFTSHIFT);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "shift_bin_op", _state, tell(), "'<<'");
            _res = ast::LShift ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'<<'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "shift_bin_op", _state, tell(), "'<<'");
    }
    { // '>>'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "shift_bin_op", _state, tell(), "'>>'");
        auto _literal = lexer.expect().punct(lex::Punct::RIGHTSHIFT);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "shift_bin_op", _state, tell(), "'>>'");
            _res = ast::RShift ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'>>'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "shift_bin_op", _state, tell(), "'>>'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "shift_bin_op");
    --_level;
    return std::nullopt;
}

// expr_4: unary_expr | power_expr | expr_5
std::optional<ast::field<ast::expr>> Parser::parse_expr_4_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::expr_4>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // unary_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_4", _state, tell(), "unary_expr");
        auto _single_result = parse_unary_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_4", _state, tell(), "unary_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "unary_expr");
            --_level;
            store_cached<RuleType::expr_4>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_4", _state, tell(), "unary_expr");
    }
    { // power_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_4", _state, tell(), "power_expr");
        auto _single_result = parse_power_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_4", _state, tell(), "power_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "power_expr");
            --_level;
            store_cached<RuleType::expr_4>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_4", _state, tell(), "power_expr");
    }
    { // expr_5
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_4", _state, tell(), "expr_5");
        auto _single_result = parse_expr_5_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_4", _state, tell(), "expr_5");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_5");
            --_level;
            store_cached<RuleType::expr_4>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_4", _state, tell(), "expr_5");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expr_4");
    --_level;
    store_cached<RuleType::expr_4>(_state, std::nullopt);
    return std::nullopt;
}

// unary_expr: unary_op (unary_expr | expr_5)
std::optional<ast::field<ast::expr>> Parser::parse_unary_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // unary_op (unary_expr | expr_5)
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "unary_expr", _state, tell(), "unary_op (unary_expr | expr_5)");
        auto _user_opt_o = parse_unary_op_rule();
        if (_user_opt_o) { auto o = std::move(*_user_opt_o);
        auto _user_opt_a = parse__tmp_23_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "unary_expr", _state, tell(), "unary_op (unary_expr | expr_5)");
            _res = ast::UnOp ( std::move ( o ) , std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "unary_op (unary_expr | expr_5)");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "unary_expr", _state, tell(), "unary_op (unary_expr | expr_5)");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "unary_expr");
    --_level;
    return std::nullopt;
}

// unary_op: '+' | '-' | '~' | '&' | '*'
std::optional<ast::field<ast::unary_op>> Parser::parse_unary_op_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::unary_op>> _res = std::nullopt;
    { // '+'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "unary_op", _state, tell(), "'+'");
        auto _literal = lexer.expect().punct(lex::Punct::PLUS);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "unary_op", _state, tell(), "'+'");
            _res = ast::UAdd ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'+'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "unary_op", _state, tell(), "'+'");
    }
    { // '-'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "unary_op", _state, tell(), "'-'");
        auto _literal = lexer.expect().punct(lex::Punct::MINUS);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "unary_op", _state, tell(), "'-'");
            _res = ast::USub ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'-'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "unary_op", _state, tell(), "'-'");
    }
    { // '~'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "unary_op", _state, tell(), "'~'");
        auto _literal = lexer.expect().punct(lex::Punct::TILDE);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "unary_op", _state, tell(), "'~'");
            _res = ast::BitInv ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'~'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "unary_op", _state, tell(), "'~'");
    }
    { // '&'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "unary_op", _state, tell(), "'&'");
        auto _literal = lexer.expect().punct(lex::Punct::AMPER);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "unary_op", _state, tell(), "'&'");
            _res = ast::URef ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'&'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "unary_op", _state, tell(), "'&'");
    }
    { // '*'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "unary_op", _state, tell(), "'*'");
        auto _literal = lexer.expect().punct(lex::Punct::STAR);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "unary_op", _state, tell(), "'*'");
            _res = ast::UStar ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'*'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "unary_op", _state, tell(), "'*'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "unary_op");
    --_level;
    return std::nullopt;
}

// power_expr: expr_5 '**' expr_5
std::optional<ast::field<ast::expr>> Parser::parse_power_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // expr_5 '**' expr_5
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "power_expr", _state, tell(), "expr_5 '**' expr_5");
        auto _user_opt_a = parse_expr_5_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::POWER);
        if (_literal) {
        auto _user_opt_b = parse_expr_5_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "power_expr", _state, tell(), "expr_5 '**' expr_5");
            _res = ast::BinOp ( ast::Pow ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_5 '**' expr_5");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "power_expr", _state, tell(), "expr_5 '**' expr_5");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "power_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// expr_5: attr_expr | call_expr | macro_call_expr | subscript_expr | expr_6
std::optional<ast::field<ast::expr>> Parser::parse_expr_5_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::expr_5>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    bool _first = true;
    while (true) {
        store_cached<RuleType::expr_5>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_expr_5();
        if (!_raw || (tell() <= _res_state && !_first)) {
            break;
        }
        _first = false;
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    --_level;
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_expr_5()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // attr_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_5", _state, tell(), "attr_expr");
        auto _single_result = parse_attr_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_5", _state, tell(), "attr_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "attr_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_5", _state, tell(), "attr_expr");
    }
    { // call_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_5", _state, tell(), "call_expr");
        auto _single_result = parse_call_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_5", _state, tell(), "call_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "call_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_5", _state, tell(), "call_expr");
    }
    { // macro_call_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_5", _state, tell(), "macro_call_expr");
        auto _single_result = parse_macro_call_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_5", _state, tell(), "macro_call_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "macro_call_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_5", _state, tell(), "macro_call_expr");
    }
    { // subscript_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_5", _state, tell(), "subscript_expr");
        auto _single_result = parse_subscript_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_5", _state, tell(), "subscript_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "subscript_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_5", _state, tell(), "subscript_expr");
    }
    { // expr_6
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_5", _state, tell(), "expr_6");
        auto _single_result = parse_expr_6_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_5", _state, tell(), "expr_6");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_6");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_5", _state, tell(), "expr_6");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expr_5");
    --_level;
    return std::nullopt;
}

// Left-recursive
// attr_expr: expr_5 '.' name | expr_5 '::' name
std::optional<ast::field<ast::expr>> Parser::parse_attr_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // expr_5 '.' name
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "attr_expr", _state, tell(), "expr_5 '.' name");
        auto _user_opt_a = parse_expr_5_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::DOT);
        if (_literal) {
        auto _user_opt_b = parse_name_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "attr_expr", _state, tell(), "expr_5 '.' name");
            _res = ast::Attribute ( std::move ( a ) , std::move ( b ) , ast::AttrInst ( ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_5 '.' name");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "attr_expr", _state, tell(), "expr_5 '.' name");
    }
    { // expr_5 '::' name
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "attr_expr", _state, tell(), "expr_5 '::' name");
        auto _user_opt_a = parse_expr_5_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::DOUBLECOLON);
        if (_literal) {
        auto _user_opt_b = parse_name_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "attr_expr", _state, tell(), "expr_5 '::' name");
            _res = ast::Attribute ( std::move ( a ) , std::move ( b ) , ast::AttrStatic ( ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_5 '::' name");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "attr_expr", _state, tell(), "expr_5 '::' name");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "attr_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// call_expr: expr_5 '(' call_args ')'
std::optional<ast::field<ast::expr>> Parser::parse_call_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // expr_5 '(' call_args ')'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "call_expr", _state, tell(), "expr_5 '(' call_args ')'");
        auto _user_opt_a = parse_expr_5_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::LPAR);
        if (_literal) {
        auto _user_opt_b = parse_call_args_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "call_expr", _state, tell(), "expr_5 '(' call_args ')'");
            _res = ast::Call ( std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_5 '(' call_args ')'");
            --_level;
            return _res;
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "call_expr", _state, tell(), "expr_5 '(' call_args ')'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "call_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// macro_call_expr: expr_5 '!' token_stream_delim
std::optional<ast::field<ast::expr>> Parser::parse_macro_call_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // expr_5 '!' token_stream_delim
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "macro_call_expr", _state, tell(), "expr_5 '!' token_stream_delim");
        auto _user_opt_a = parse_expr_5_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::EXCLAMATION);
        if (_literal) {
        auto _user_opt_b = parse_token_stream_delim_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "macro_call_expr", _state, tell(), "expr_5 '!' token_stream_delim");
            _res = ast::MacroCall ( std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_5 '!' token_stream_delim");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "macro_call_expr", _state, tell(), "expr_5 '!' token_stream_delim");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "macro_call_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// subscript_expr: expr_5 '[' call_args ']'
std::optional<ast::field<ast::expr>> Parser::parse_subscript_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // expr_5 '[' call_args ']'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "subscript_expr", _state, tell(), "expr_5 '[' call_args ']'");
        auto _user_opt_a = parse_expr_5_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::LSQB);
        if (_literal) {
        auto _user_opt_b = parse_call_args_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _literal_1 = lexer.expect().punct(lex::Punct::RSQB);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "subscript_expr", _state, tell(), "expr_5 '[' call_args ']'");
            _res = ast::Subscript ( std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_5 '[' call_args ']'");
            --_level;
            return _res;
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "subscript_expr", _state, tell(), "expr_5 '[' call_args ']'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "subscript_expr");
    --_level;
    return std::nullopt;
}

// call_args: 
std::optional<ast::field<ast::call_args>> Parser::parse_call_args_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::call_args>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::call_args>> _res = std::nullopt;
    { // 
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "call_args", _state, tell(), "");
        PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "call_args", _state, tell(), "");
        _res = ast::call_args ( ast::make_sequence < ast::call_arg > ( ) , nullptr , nullptr );
        PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "");
        --_level;
        store_cached<RuleType::call_args>(_state, _res);
        return _res;
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "call_args", _state, tell(), "");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "call_args");
    --_level;
    store_cached<RuleType::call_args>(_state, std::nullopt);
    return std::nullopt;
}

// token_stream: token_stream_delim | token_stream_no_parens
std::optional<ast::field<ast::expr>> Parser::parse_token_stream_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // token_stream_delim
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "token_stream", _state, tell(), "token_stream_delim");
        auto _single_result = parse_token_stream_delim_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "token_stream", _state, tell(), "token_stream_delim");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "token_stream_delim");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "token_stream", _state, tell(), "token_stream_delim");
    }
    { // token_stream_no_parens
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "token_stream", _state, tell(), "token_stream_no_parens");
        auto _single_result = parse_token_stream_no_parens_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "token_stream", _state, tell(), "token_stream_no_parens");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "token_stream_no_parens");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "token_stream", _state, tell(), "token_stream_no_parens");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "token_stream");
    --_level;
    return std::nullopt;
}

// token_stream_delim:
//     | '(' ~ token_stream* ')'
//     | '[' ~ token_stream* ']'
//     | '{' ~ token_stream* '}'
std::optional<ast::field<ast::expr>> Parser::parse_token_stream_delim_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '(' ~ token_stream* ')'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "token_stream_delim", _state, tell(), "'(' ~ token_stream* ')'");
        std::optional<std::monostate> _cut_var = std::nullopt;
        auto _literal = lexer.expect().punct(lex::Punct::LPAR);
        if (_literal) {
        _cut_var = std::optional<std::monostate>(std::monostate{});
        auto _user_opt_a = parse__loop0_24_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "token_stream_delim", _state, tell(), "'(' ~ token_stream* ')'");
            _res = ast::TokenStream ( /* ? ? ? */ );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'(' ~ token_stream* ')'");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "token_stream_delim", _state, tell(), "'(' ~ token_stream* ')'");
        if (_cut_var) {
            --_level;
            return std::nullopt;
        }
    }
    { // '[' ~ token_stream* ']'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "token_stream_delim", _state, tell(), "'[' ~ token_stream* ']'");
        std::optional<std::monostate> _cut_var = std::nullopt;
        auto _literal = lexer.expect().punct(lex::Punct::LSQB);
        if (_literal) {
        _cut_var = std::optional<std::monostate>(std::monostate{});
        auto _user_opt_a = parse__loop0_25_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal_1 = lexer.expect().punct(lex::Punct::RSQB);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "token_stream_delim", _state, tell(), "'[' ~ token_stream* ']'");
            _res = ast::TokenStream ( /* ? ? ? */ );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'[' ~ token_stream* ']'");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "token_stream_delim", _state, tell(), "'[' ~ token_stream* ']'");
        if (_cut_var) {
            --_level;
            return std::nullopt;
        }
    }
    { // '{' ~ token_stream* '}'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "token_stream_delim", _state, tell(), "'{' ~ token_stream* '}'");
        std::optional<std::monostate> _cut_var = std::nullopt;
        auto _literal = lexer.expect().punct(lex::Punct::LBRACE);
        if (_literal) {
        _cut_var = std::optional<std::monostate>(std::monostate{});
        auto _user_opt_a = parse__loop0_26_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal_1 = lexer.expect().punct(lex::Punct::RBRACE);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "token_stream_delim", _state, tell(), "'{' ~ token_stream* '}'");
            _res = ast::TokenStream ( /* ? ? ? */ );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'{' ~ token_stream* '}'");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "token_stream_delim", _state, tell(), "'{' ~ token_stream* '}'");
        if (_cut_var) {
            --_level;
            return std::nullopt;
        }
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "token_stream_delim");
    --_level;
    return std::nullopt;
}

// token_stream_no_parens: ((!any_paren any_token))+
std::optional<ast::field<ast::expr>> Parser::parse_token_stream_no_parens_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // ((!any_paren any_token))+
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "token_stream_no_parens", _state, tell(), "((!any_paren any_token))+");
        auto _loop1_27_var = parse__loop1_27_rule();
        if (_loop1_27_var) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "token_stream_no_parens", _state, tell(), "((!any_paren any_token))+");
            _res = ast::TokenStream ( /* ? ? ? */ );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "((!any_paren any_token))+");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "token_stream_no_parens", _state, tell(), "((!any_paren any_token))+");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "token_stream_no_parens");
    --_level;
    return std::nullopt;
}

// any_paren: '(' | ')' | '[' | ']' | '{' | '}'
std::optional<std::monostate> Parser::parse_any_paren_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<std::monostate> _res = std::nullopt;
    { // '('
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "any_paren", _state, tell(), "'('");
        auto _literal = lexer.expect().punct(lex::Punct::LPAR);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "any_paren", _state, tell(), "'('");
            _res = std::monostate{};
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'('");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "any_paren", _state, tell(), "'('");
    }
    { // ')'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "any_paren", _state, tell(), "')'");
        auto _literal = lexer.expect().punct(lex::Punct::RPAR);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "any_paren", _state, tell(), "')'");
            _res = std::monostate{};
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "')'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "any_paren", _state, tell(), "')'");
    }
    { // '['
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "any_paren", _state, tell(), "'['");
        auto _literal = lexer.expect().punct(lex::Punct::LSQB);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "any_paren", _state, tell(), "'['");
            _res = std::monostate{};
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'['");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "any_paren", _state, tell(), "'['");
    }
    { // ']'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "any_paren", _state, tell(), "']'");
        auto _literal = lexer.expect().punct(lex::Punct::RSQB);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "any_paren", _state, tell(), "']'");
            _res = std::monostate{};
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "']'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "any_paren", _state, tell(), "']'");
    }
    { // '{'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "any_paren", _state, tell(), "'{'");
        auto _literal = lexer.expect().punct(lex::Punct::LBRACE);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "any_paren", _state, tell(), "'{'");
            _res = std::monostate{};
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'{'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "any_paren", _state, tell(), "'{'");
    }
    { // '}'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "any_paren", _state, tell(), "'}'");
        auto _literal = lexer.expect().punct(lex::Punct::RBRACE);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "any_paren", _state, tell(), "'}'");
            _res = std::monostate{};
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'}'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "any_paren", _state, tell(), "'}'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "any_paren");
    --_level;
    return std::nullopt;
}

// any_token: NAME | NUMBER | STRING | KEYWORD | PUNCT
std::optional<lex::Token> Parser::parse_any_token_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<lex::Token> _res = std::nullopt;
    { // NAME
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "any_token", _state, tell(), "NAME");
        auto _single_result = lexer.expect().token(lex::TokenType::name);
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "any_token", _state, tell(), "NAME");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "NAME");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "any_token", _state, tell(), "NAME");
    }
    { // NUMBER
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "any_token", _state, tell(), "NUMBER");
        auto _single_result = lexer.expect().token(lex::TokenType::number);
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "any_token", _state, tell(), "NUMBER");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "NUMBER");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "any_token", _state, tell(), "NUMBER");
    }
    { // STRING
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "any_token", _state, tell(), "STRING");
        auto _single_result = lexer.expect().token(lex::TokenType::string);
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "any_token", _state, tell(), "STRING");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "STRING");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "any_token", _state, tell(), "STRING");
    }
    { // KEYWORD
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "any_token", _state, tell(), "KEYWORD");
        auto _single_result = lexer.expect().token(lex::TokenType::keyword);
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "any_token", _state, tell(), "KEYWORD");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "KEYWORD");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "any_token", _state, tell(), "KEYWORD");
    }
    { // PUNCT
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "any_token", _state, tell(), "PUNCT");
        auto _single_result = lexer.expect().token(lex::TokenType::punct);
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "any_token", _state, tell(), "PUNCT");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "PUNCT");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "any_token", _state, tell(), "PUNCT");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "any_token");
    --_level;
    return std::nullopt;
}

// expr_6: primary_expr
std::optional<ast::field<ast::expr>> Parser::parse_expr_6_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // primary_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_6", _state, tell(), "primary_expr");
        auto _single_result = parse_primary_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_6", _state, tell(), "primary_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "primary_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_6", _state, tell(), "primary_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expr_6");
    --_level;
    return std::nullopt;
}

// primary_expr:
//     | NUMBER
//     | &STRING strings
//     | '...'
//     | var_ref_expr
//     | group_expr
//     | tuple_expr
//     | array_expr
//     | ctime_block_expr
//     | block_expr
std::optional<ast::field<ast::expr>> Parser::parse_primary_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // NUMBER
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "primary_expr", _state, tell(), "NUMBER");
        auto _user_opt_a = lexer.expect().token(lex::TokenType::number);
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "primary_expr", _state, tell(), "NUMBER");
            _res = ast::Constant ( util::variant_cast ( a . get_number ( ) . value ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "NUMBER");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "primary_expr", _state, tell(), "NUMBER");
    }
    { // &STRING strings
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "primary_expr", _state, tell(), "&STRING strings");
        auto _tmpvar = lexer.lookahead(true).token(lex::TokenType::string);
        if (_tmpvar) {
        auto _user_opt_a = parse_strings_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "primary_expr", _state, tell(), "&STRING strings");
            _res = ast::Constant ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "&STRING strings");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "primary_expr", _state, tell(), "&STRING strings");
    }
    { // '...'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "primary_expr", _state, tell(), "'...'");
        auto _literal = lexer.expect().punct(lex::Punct::ELLIPSIS);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "primary_expr", _state, tell(), "'...'");
            _res = ast::Constant ( /* Ellipsis , somehow ... */ );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'...'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "primary_expr", _state, tell(), "'...'");
    }
    { // var_ref_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "primary_expr", _state, tell(), "var_ref_expr");
        auto _single_result = parse_var_ref_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "primary_expr", _state, tell(), "var_ref_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "var_ref_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "primary_expr", _state, tell(), "var_ref_expr");
    }
    { // group_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "primary_expr", _state, tell(), "group_expr");
        auto _single_result = parse_group_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "primary_expr", _state, tell(), "group_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "group_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "primary_expr", _state, tell(), "group_expr");
    }
    { // tuple_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "primary_expr", _state, tell(), "tuple_expr");
        auto _single_result = parse_tuple_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "primary_expr", _state, tell(), "tuple_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "tuple_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "primary_expr", _state, tell(), "tuple_expr");
    }
    { // array_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "primary_expr", _state, tell(), "array_expr");
        auto _single_result = parse_array_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "primary_expr", _state, tell(), "array_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "array_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "primary_expr", _state, tell(), "array_expr");
    }
    { // ctime_block_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "primary_expr", _state, tell(), "ctime_block_expr");
        auto _single_result = parse_ctime_block_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "primary_expr", _state, tell(), "ctime_block_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "ctime_block_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "primary_expr", _state, tell(), "ctime_block_expr");
    }
    { // block_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "primary_expr", _state, tell(), "block_expr");
        auto _single_result = parse_block_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "primary_expr", _state, tell(), "block_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "block_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "primary_expr", _state, tell(), "block_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "primary_expr");
    --_level;
    return std::nullopt;
}

// var_ref_expr: name
std::optional<ast::field<ast::expr>> Parser::parse_var_ref_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // name
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "var_ref_expr", _state, tell(), "name");
        auto _user_opt_a = parse_name_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "var_ref_expr", _state, tell(), "name");
            _res = ast::VarRef ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "name");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "var_ref_expr", _state, tell(), "name");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "var_ref_expr");
    --_level;
    return std::nullopt;
}

// strings: STRING+
std::optional<std::string> Parser::parse_strings_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::strings>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<std::string> _res = std::nullopt;
    { // STRING+
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "strings", _state, tell(), "STRING+");
        auto _user_opt_a = parse__loop1_28_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "strings", _state, tell(), "STRING+");
            _res = _concat_strings ( a );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "STRING+");
            --_level;
            store_cached<RuleType::strings>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "strings", _state, tell(), "STRING+");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "strings");
    --_level;
    store_cached<RuleType::strings>(_state, std::nullopt);
    return std::nullopt;
}

// group_expr: '(' weak_expr ')'
std::optional<ast::field<ast::expr>> Parser::parse_group_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '(' weak_expr ')'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "group_expr", _state, tell(), "'(' weak_expr ')'");
        auto _literal = lexer.expect().punct(lex::Punct::LPAR);
        if (_literal) {
        auto _single_result = parse_weak_expr_rule();
        if (_single_result) {
        auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "group_expr", _state, tell(), "'(' weak_expr ')'");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'(' weak_expr ')'");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "group_expr", _state, tell(), "'(' weak_expr ')'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "group_expr");
    --_level;
    return std::nullopt;
}

// tuple_expr: '(' ')' | '(' ','.expr+ ','? ')'
std::optional<ast::field<ast::expr>> Parser::parse_tuple_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '(' ')'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "tuple_expr", _state, tell(), "'(' ')'");
        auto _literal = lexer.expect().punct(lex::Punct::LPAR);
        if (_literal) {
        auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "tuple_expr", _state, tell(), "'(' ')'");
            _res = ast::Tuple ( ast::make_sequence < ast::expr > ( ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'(' ')'");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "tuple_expr", _state, tell(), "'(' ')'");
    }
    { // '(' ','.expr+ ','? ')'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "tuple_expr", _state, tell(), "'(' ','.expr+ ','? ')'");
        auto _literal = lexer.expect().punct(lex::Punct::LPAR);
        if (_literal) {
        auto _user_opt_a = parse__gather_29_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _opt_var = lexer.expect().punct(lex::Punct::COMMA);
        if (true) { (void)_opt_var;
        auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "tuple_expr", _state, tell(), "'(' ','.expr+ ','? ')'");
            _res = ast::Tuple ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'(' ','.expr+ ','? ')'");
            --_level;
            return _res;
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "tuple_expr", _state, tell(), "'(' ','.expr+ ','? ')'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "tuple_expr");
    --_level;
    return std::nullopt;
}

// array_expr: '[' ']' | '[' ','.expr+ ','? ']'
std::optional<ast::field<ast::expr>> Parser::parse_array_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '[' ']'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "array_expr", _state, tell(), "'[' ']'");
        auto _literal = lexer.expect().punct(lex::Punct::LSQB);
        if (_literal) {
        auto _literal_1 = lexer.expect().punct(lex::Punct::RSQB);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "array_expr", _state, tell(), "'[' ']'");
            _res = ast::Array ( ast::make_sequence < ast::expr > ( ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'[' ']'");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "array_expr", _state, tell(), "'[' ']'");
    }
    { // '[' ','.expr+ ','? ']'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "array_expr", _state, tell(), "'[' ','.expr+ ','? ']'");
        auto _literal = lexer.expect().punct(lex::Punct::LSQB);
        if (_literal) {
        auto _user_opt_a = parse__gather_31_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _opt_var = lexer.expect().punct(lex::Punct::COMMA);
        if (true) { (void)_opt_var;
        auto _literal_1 = lexer.expect().punct(lex::Punct::RSQB);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "array_expr", _state, tell(), "'[' ','.expr+ ','? ']'");
            _res = ast::Array ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'[' ','.expr+ ','? ']'");
            --_level;
            return _res;
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "array_expr", _state, tell(), "'[' ','.expr+ ','? ']'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "array_expr");
    --_level;
    return std::nullopt;
}

// ctime_block_expr: 'ctime' block_expr
std::optional<ast::field<ast::expr>> Parser::parse_ctime_block_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'ctime' block_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "ctime_block_expr", _state, tell(), "'ctime' block_expr");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::CTIME);
        if (_keyword) {
        auto _user_opt_b = parse_block_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "ctime_block_expr", _state, tell(), "'ctime' block_expr");
            _res = ast::CtimeBlock ( std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'ctime' block_expr");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "ctime_block_expr", _state, tell(), "'ctime' block_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "ctime_block_expr");
    --_level;
    return std::nullopt;
}

// block_expr: '{' stmt* expr_or_unit '}'
std::optional<ast::field<ast::expr>> Parser::parse_block_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::block_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '{' stmt* expr_or_unit '}'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "block_expr", _state, tell(), "'{' stmt* expr_or_unit '}'");
        auto _literal = lexer.expect().punct(lex::Punct::LBRACE);
        if (_literal) {
        auto _user_opt_b = parse__loop0_33_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _user_opt_v = parse_expr_or_unit_rule();
        if (_user_opt_v) { auto v = std::move(*_user_opt_v);
        auto _literal_1 = lexer.expect().punct(lex::Punct::RBRACE);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "block_expr", _state, tell(), "'{' stmt* expr_or_unit '}'");
            _res = ast::Block ( std::move ( b ) , std::move ( v ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'{' stmt* expr_or_unit '}'");
            --_level;
            store_cached<RuleType::block_expr>(_state, _res);
            return _res;
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "block_expr", _state, tell(), "'{' stmt* expr_or_unit '}'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "block_expr");
    --_level;
    store_cached<RuleType::block_expr>(_state, std::nullopt);
    return std::nullopt;
}

// attr_name: name | group_expr
std::optional<ast::field<ast::expr>> Parser::parse_attr_name_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // name
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "attr_name", _state, tell(), "name");
        auto _user_opt_n = parse_name_rule();
        if (_user_opt_n) { auto n = std::move(*_user_opt_n);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "attr_name", _state, tell(), "name");
            _res = ast::Constant ( std::move ( n ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "name");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "attr_name", _state, tell(), "name");
    }
    { // group_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "attr_name", _state, tell(), "group_expr");
        auto _single_result = parse_group_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "attr_name", _state, tell(), "group_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "group_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "attr_name", _state, tell(), "group_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "attr_name");
    --_level;
    return std::nullopt;
}

// weak_expr: infix_call_expr | expr
std::optional<ast::field<ast::expr>> Parser::parse_weak_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // infix_call_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "weak_expr", _state, tell(), "infix_call_expr");
        auto _single_result = parse_infix_call_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "weak_expr", _state, tell(), "infix_call_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "infix_call_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "weak_expr", _state, tell(), "infix_call_expr");
    }
    { // expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "weak_expr", _state, tell(), "expr");
        auto _single_result = parse_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "weak_expr", _state, tell(), "expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "weak_expr", _state, tell(), "expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "weak_expr");
    --_level;
    return std::nullopt;
}

// infix_call_expr: expr_4 name expr_4
std::optional<ast::field<ast::expr>> Parser::parse_infix_call_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // expr_4 name expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "infix_call_expr", _state, tell(), "expr_4 name expr_4");
        auto _user_opt_a = parse_expr_4_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _user_opt_o = parse_name_rule();
        if (_user_opt_o) { auto o = std::move(*_user_opt_o);
        auto _user_opt_b = parse_expr_4_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "infix_call_expr", _state, tell(), "expr_4 name expr_4");
            _res = ast::InfixCall ( std::move ( o ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_4 name expr_4");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "infix_call_expr", _state, tell(), "expr_4 name expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "infix_call_expr");
    --_level;
    return std::nullopt;
}

// name: NAME
std::optional<std::string> Parser::parse_name_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<std::string> _res = std::nullopt;
    { // NAME
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "name", _state, tell(), "NAME");
        auto _user_opt_a = lexer.expect().token(lex::TokenType::name);
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "name", _state, tell(), "NAME");
            _res = a . get_name ( ) . value;
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "NAME");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "name", _state, tell(), "NAME");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "name");
    --_level;
    return std::nullopt;
}

// xtime_flag: 'ctime' | 'rtime' | 
std::optional<ast::field<ast::xtime_flag>> Parser::parse_xtime_flag_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::xtime_flag>> _res = std::nullopt;
    { // 'ctime'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "xtime_flag", _state, tell(), "'ctime'");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::CTIME);
        if (_keyword) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "xtime_flag", _state, tell(), "'ctime'");
            _res = ast::CTime ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'ctime'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "xtime_flag", _state, tell(), "'ctime'");
    }
    { // 'rtime'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "xtime_flag", _state, tell(), "'rtime'");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::RTIME);
        if (_keyword) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "xtime_flag", _state, tell(), "'rtime'");
            _res = ast::RTime ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'rtime'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "xtime_flag", _state, tell(), "'rtime'");
    }
    { // 
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "xtime_flag", _state, tell(), "");
        PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "xtime_flag", _state, tell(), "");
        _res = ast::DefaultTime ( );
        PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "");
        --_level;
        return _res;
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "xtime_flag", _state, tell(), "");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "xtime_flag");
    --_level;
    return std::nullopt;
}

// type_annotation: ':' expr
std::optional<ast::field<ast::expr>> Parser::parse_type_annotation_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // ':' expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "type_annotation", _state, tell(), "':' expr");
        auto _literal = lexer.expect().punct(lex::Punct::COLON);
        if (_literal) {
        auto _user_opt_a = parse_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "type_annotation", _state, tell(), "':' expr");
            _res = std::move ( a );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "':' expr");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "type_annotation", _state, tell(), "':' expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "type_annotation");
    --_level;
    return std::nullopt;
}

// _loop0_1: stmt
std::optional<ast::sequence<ast::stmt>> Parser::parse__loop0_1_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    std::vector<ast::field<ast::stmt>> _children{};
    { // stmt
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop0_1", _state, tell(), "stmt");
        while (true) {
            auto _single_result = parse_stmt_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "stmt");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop0_1", _state, tell(), "stmt");
    }
    auto _seq = ast::make_sequence<ast::stmt>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _tmp_2: '=' expr
std::optional<ast::field<ast::expr>> Parser::parse__tmp_2_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '=' expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_2", _state, tell(), "'=' expr");
        auto _literal = lexer.expect().punct(lex::Punct::EQUAL);
        if (_literal) {
        auto _single_result = parse_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_2", _state, tell(), "'=' expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'=' expr");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_2", _state, tell(), "'=' expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_2");
    --_level;
    return std::nullopt;
}

// _loop0_3: stmt
std::optional<ast::sequence<ast::stmt>> Parser::parse__loop0_3_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    std::vector<ast::field<ast::stmt>> _children{};
    { // stmt
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop0_3", _state, tell(), "stmt");
        while (true) {
            auto _single_result = parse_stmt_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "stmt");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop0_3", _state, tell(), "stmt");
    }
    auto _seq = ast::make_sequence<ast::stmt>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _tmp_4: 'class' | 'struct'
std::optional<std::monostate> Parser::parse__tmp_4_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<std::monostate> _res = std::nullopt;
    { // 'class'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_4", _state, tell(), "'class'");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::CLASS);
        if (_keyword) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_4", _state, tell(), "'class'");
            _res = std::monostate{};
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'class'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_4", _state, tell(), "'class'");
    }
    { // 'struct'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_4", _state, tell(), "'struct'");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::STRUCT);
        if (_keyword) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_4", _state, tell(), "'struct'");
            _res = std::monostate{};
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'struct'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_4", _state, tell(), "'struct'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_4");
    --_level;
    return std::nullopt;
}

// _loop0_6: '::' name
std::optional<std::vector<std::string>> Parser::parse__loop0_6_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<std::string> _res = std::nullopt;
    std::vector<std::string> _children{};
    { // '::' name
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop0_6", _state, tell(), "'::' name");
        while (true) {
            auto _literal = lexer.expect().punct(lex::Punct::DOUBLECOLON);
            if (_literal) {
            auto _user_opt_elem = parse_name_rule();
            if (_user_opt_elem) { auto elem = std::move(*_user_opt_elem);
                _res = elem;
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'::' name");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop0_6", _state, tell(), "'::' name");
    }
    --_level;
    return _children;
}

// _gather_5: name _loop0_6
std::optional<std::vector<std::string>> Parser::parse__gather_5_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<std::vector<std::string>> _res = std::nullopt;
    { // name _loop0_6
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_gather_5", _state, tell(), "name _loop0_6");
        auto _user_opt_name_var = parse_name_rule();
        if (_user_opt_name_var) { auto name_var = std::move(*_user_opt_name_var);
        auto _user_opt_seq = parse__loop0_6_rule();
        if (_user_opt_seq) { auto seq = std::move(*_user_opt_seq);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_gather_5", _state, tell(), "name _loop0_6");
            _res = std::move(seq);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "name _loop0_6");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_gather_5", _state, tell(), "name _loop0_6");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_gather_5");
    --_level;
    return std::nullopt;
}

// _loop0_7: (',' arg_spec)
std::optional<ast::sequence<ast::arg_spec>> Parser::parse__loop0_7_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::arg_spec>> _res = std::nullopt;
    std::vector<ast::field<ast::arg_spec>> _children{};
    { // (',' arg_spec)
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop0_7", _state, tell(), "(',' arg_spec)");
        while (true) {
            auto _single_result = parse__tmp_34_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "(',' arg_spec)");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop0_7", _state, tell(), "(',' arg_spec)");
    }
    auto _seq = ast::make_sequence<ast::arg_spec>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _loop0_9: ',' arg_spec
std::optional<ast::sequence<ast::arg_spec>> Parser::parse__loop0_9_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::arg_spec>> _res = std::nullopt;
    std::vector<ast::field<ast::arg_spec>> _children{};
    { // ',' arg_spec
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop0_9", _state, tell(), "',' arg_spec");
        while (true) {
            auto _literal = lexer.expect().punct(lex::Punct::COMMA);
            if (_literal) {
            auto _user_opt_elem = parse_arg_spec_rule();
            if (_user_opt_elem) { auto elem = std::move(*_user_opt_elem);
                _res = elem;
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "',' arg_spec");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop0_9", _state, tell(), "',' arg_spec");
    }
    auto _seq = ast::make_sequence<ast::arg_spec>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _gather_8: arg_spec _loop0_9
std::optional<ast::sequence<ast::arg_spec>> Parser::parse__gather_8_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::sequence<ast::arg_spec>> _res = std::nullopt;
    { // arg_spec _loop0_9
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_gather_8", _state, tell(), "arg_spec _loop0_9");
        auto _user_opt_arg_spec_var = parse_arg_spec_rule();
        if (_user_opt_arg_spec_var) { auto arg_spec_var = std::move(*_user_opt_arg_spec_var);
        auto _user_opt_seq = parse__loop0_9_rule();
        if (_user_opt_seq) { auto seq = std::move(*_user_opt_seq);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_gather_8", _state, tell(), "arg_spec _loop0_9");
            _res = std::move(seq);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "arg_spec _loop0_9");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_gather_8", _state, tell(), "arg_spec _loop0_9");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_gather_8");
    --_level;
    return std::nullopt;
}

// _tmp_10: '=' expr
std::optional<ast::field<ast::expr>> Parser::parse__tmp_10_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '=' expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_10", _state, tell(), "'=' expr");
        auto _literal = lexer.expect().punct(lex::Punct::EQUAL);
        if (_literal) {
        auto _single_result = parse_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_10", _state, tell(), "'=' expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'=' expr");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_10", _state, tell(), "'=' expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_10");
    --_level;
    return std::nullopt;
}

// _tmp_11: 'else' flow_block
std::optional<ast::field<ast::expr>> Parser::parse__tmp_11_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'else' flow_block
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_11", _state, tell(), "'else' flow_block");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::ELSE);
        if (_keyword) {
        auto _single_result = parse_flow_block_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_11", _state, tell(), "'else' flow_block");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'else' flow_block");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_11", _state, tell(), "'else' flow_block");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_11");
    --_level;
    return std::nullopt;
}

// _tmp_12: 'else' flow_block
std::optional<ast::field<ast::expr>> Parser::parse__tmp_12_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'else' flow_block
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_12", _state, tell(), "'else' flow_block");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::ELSE);
        if (_keyword) {
        auto _single_result = parse_flow_block_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_12", _state, tell(), "'else' flow_block");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'else' flow_block");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_12", _state, tell(), "'else' flow_block");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_12");
    --_level;
    return std::nullopt;
}

// _tmp_13: 'else' flow_block
std::optional<ast::field<ast::expr>> Parser::parse__tmp_13_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'else' flow_block
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_13", _state, tell(), "'else' flow_block");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::ELSE);
        if (_keyword) {
        auto _single_result = parse_flow_block_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_13", _state, tell(), "'else' flow_block");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'else' flow_block");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_13", _state, tell(), "'else' flow_block");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_13");
    --_level;
    return std::nullopt;
}

// _loop1_14: ('and' expr_1)
std::optional<ast::sequence<ast::expr>> Parser::parse__loop1_14_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    std::vector<ast::field<ast::expr>> _children{};
    { // ('and' expr_1)
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop1_14", _state, tell(), "('and' expr_1)");
        while (true) {
            auto _single_result = parse__tmp_35_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "('and' expr_1)");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop1_14", _state, tell(), "('and' expr_1)");
    }
    if (_children.size() == 0) {
        --_level;
        return std::nullopt;
    }
    auto _seq = ast::make_sequence<ast::expr>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _loop1_15: ('or' expr_1)
std::optional<ast::sequence<ast::expr>> Parser::parse__loop1_15_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    std::vector<ast::field<ast::expr>> _children{};
    { // ('or' expr_1)
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop1_15", _state, tell(), "('or' expr_1)");
        while (true) {
            auto _single_result = parse__tmp_36_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "('or' expr_1)");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop1_15", _state, tell(), "('or' expr_1)");
    }
    if (_children.size() == 0) {
        --_level;
        return std::nullopt;
    }
    auto _seq = ast::make_sequence<ast::expr>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _loop1_16: comparison_followup_pair
std::optional<std::vector<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>>> Parser::parse__loop1_16_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>> _res = std::nullopt;
    std::vector<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>> _children{};
    { // comparison_followup_pair
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop1_16", _state, tell(), "comparison_followup_pair");
        while (true) {
            auto _single_result = parse_comparison_followup_pair_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "comparison_followup_pair");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop1_16", _state, tell(), "comparison_followup_pair");
    }
    if (_children.size() == 0) {
        --_level;
        return std::nullopt;
    }
    --_level;
    return _children;
}

// _tmp_17: sum_expr | product_expr
std::optional<ast::field<ast::expr>> Parser::parse__tmp_17_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // sum_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_17", _state, tell(), "sum_expr");
        auto _single_result = parse_sum_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_17", _state, tell(), "sum_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "sum_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_17", _state, tell(), "sum_expr");
    }
    { // product_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_17", _state, tell(), "product_expr");
        auto _single_result = parse_product_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_17", _state, tell(), "product_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "product_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_17", _state, tell(), "product_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_17");
    --_level;
    return std::nullopt;
}

// _tmp_18: product_expr | expr_4
std::optional<ast::field<ast::expr>> Parser::parse__tmp_18_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // product_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_18", _state, tell(), "product_expr");
        auto _single_result = parse_product_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_18", _state, tell(), "product_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "product_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_18", _state, tell(), "product_expr");
    }
    { // expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_18", _state, tell(), "expr_4");
        auto _single_result = parse_expr_4_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_18", _state, tell(), "expr_4");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_4");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_18", _state, tell(), "expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_18");
    --_level;
    return std::nullopt;
}

// _tmp_19: bitor_expr | expr_4
std::optional<ast::field<ast::expr>> Parser::parse__tmp_19_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // bitor_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_19", _state, tell(), "bitor_expr");
        auto _single_result = parse_bitor_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_19", _state, tell(), "bitor_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bitor_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_19", _state, tell(), "bitor_expr");
    }
    { // expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_19", _state, tell(), "expr_4");
        auto _single_result = parse_expr_4_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_19", _state, tell(), "expr_4");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_4");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_19", _state, tell(), "expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_19");
    --_level;
    return std::nullopt;
}

// _tmp_20: bitand_expr | expr_4
std::optional<ast::field<ast::expr>> Parser::parse__tmp_20_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // bitand_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_20", _state, tell(), "bitand_expr");
        auto _single_result = parse_bitand_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_20", _state, tell(), "bitand_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bitand_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_20", _state, tell(), "bitand_expr");
    }
    { // expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_20", _state, tell(), "expr_4");
        auto _single_result = parse_expr_4_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_20", _state, tell(), "expr_4");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_4");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_20", _state, tell(), "expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_20");
    --_level;
    return std::nullopt;
}

// _tmp_21: bitxor_expr | expr_4
std::optional<ast::field<ast::expr>> Parser::parse__tmp_21_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // bitxor_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_21", _state, tell(), "bitxor_expr");
        auto _single_result = parse_bitxor_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_21", _state, tell(), "bitxor_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bitxor_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_21", _state, tell(), "bitxor_expr");
    }
    { // expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_21", _state, tell(), "expr_4");
        auto _single_result = parse_expr_4_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_21", _state, tell(), "expr_4");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_4");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_21", _state, tell(), "expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_21");
    --_level;
    return std::nullopt;
}

// _tmp_22: shift_expr | expr_4
std::optional<ast::field<ast::expr>> Parser::parse__tmp_22_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // shift_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_22", _state, tell(), "shift_expr");
        auto _single_result = parse_shift_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_22", _state, tell(), "shift_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "shift_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_22", _state, tell(), "shift_expr");
    }
    { // expr_4
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_22", _state, tell(), "expr_4");
        auto _single_result = parse_expr_4_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_22", _state, tell(), "expr_4");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_4");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_22", _state, tell(), "expr_4");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_22");
    --_level;
    return std::nullopt;
}

// _tmp_23: unary_expr | expr_5
std::optional<ast::field<ast::expr>> Parser::parse__tmp_23_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // unary_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_23", _state, tell(), "unary_expr");
        auto _single_result = parse_unary_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_23", _state, tell(), "unary_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "unary_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_23", _state, tell(), "unary_expr");
    }
    { // expr_5
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_23", _state, tell(), "expr_5");
        auto _single_result = parse_expr_5_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_23", _state, tell(), "expr_5");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_5");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_23", _state, tell(), "expr_5");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_23");
    --_level;
    return std::nullopt;
}

// _loop0_24: token_stream
std::optional<ast::sequence<ast::expr>> Parser::parse__loop0_24_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    std::vector<ast::field<ast::expr>> _children{};
    { // token_stream
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop0_24", _state, tell(), "token_stream");
        while (true) {
            auto _single_result = parse_token_stream_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "token_stream");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop0_24", _state, tell(), "token_stream");
    }
    auto _seq = ast::make_sequence<ast::expr>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _loop0_25: token_stream
std::optional<ast::sequence<ast::expr>> Parser::parse__loop0_25_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    std::vector<ast::field<ast::expr>> _children{};
    { // token_stream
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop0_25", _state, tell(), "token_stream");
        while (true) {
            auto _single_result = parse_token_stream_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "token_stream");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop0_25", _state, tell(), "token_stream");
    }
    auto _seq = ast::make_sequence<ast::expr>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _loop0_26: token_stream
std::optional<ast::sequence<ast::expr>> Parser::parse__loop0_26_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    std::vector<ast::field<ast::expr>> _children{};
    { // token_stream
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop0_26", _state, tell(), "token_stream");
        while (true) {
            auto _single_result = parse_token_stream_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "token_stream");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop0_26", _state, tell(), "token_stream");
    }
    auto _seq = ast::make_sequence<ast::expr>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _loop1_27: (!any_paren any_token)
std::optional<std::vector<lex::Token>> Parser::parse__loop1_27_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<lex::Token> _res = std::nullopt;
    std::vector<lex::Token> _children{};
    { // (!any_paren any_token)
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop1_27", _state, tell(), "(!any_paren any_token)");
        while (true) {
            auto _single_result = parse__tmp_37_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "(!any_paren any_token)");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop1_27", _state, tell(), "(!any_paren any_token)");
    }
    if (_children.size() == 0) {
        --_level;
        return std::nullopt;
    }
    --_level;
    return _children;
}

// _loop1_28: STRING
std::optional<std::vector<lex::Token>> Parser::parse__loop1_28_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<lex::Token> _res = std::nullopt;
    std::vector<lex::Token> _children{};
    { // STRING
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop1_28", _state, tell(), "STRING");
        while (true) {
            auto _single_result = lexer.expect().token(lex::TokenType::string);
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "STRING");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop1_28", _state, tell(), "STRING");
    }
    if (_children.size() == 0) {
        --_level;
        return std::nullopt;
    }
    --_level;
    return _children;
}

// _loop0_30: ',' expr
std::optional<ast::sequence<ast::expr>> Parser::parse__loop0_30_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    std::vector<ast::field<ast::expr>> _children{};
    { // ',' expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop0_30", _state, tell(), "',' expr");
        while (true) {
            auto _literal = lexer.expect().punct(lex::Punct::COMMA);
            if (_literal) {
            auto _user_opt_elem = parse_expr_rule();
            if (_user_opt_elem) { auto elem = std::move(*_user_opt_elem);
                _res = elem;
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "',' expr");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop0_30", _state, tell(), "',' expr");
    }
    auto _seq = ast::make_sequence<ast::expr>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _gather_29: expr _loop0_30
std::optional<ast::sequence<ast::expr>> Parser::parse__gather_29_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::sequence<ast::expr>> _res = std::nullopt;
    { // expr _loop0_30
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_gather_29", _state, tell(), "expr _loop0_30");
        auto _user_opt_expr_var = parse_expr_rule();
        if (_user_opt_expr_var) { auto expr_var = std::move(*_user_opt_expr_var);
        auto _user_opt_seq = parse__loop0_30_rule();
        if (_user_opt_seq) { auto seq = std::move(*_user_opt_seq);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_gather_29", _state, tell(), "expr _loop0_30");
            _res = std::move(seq);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr _loop0_30");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_gather_29", _state, tell(), "expr _loop0_30");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_gather_29");
    --_level;
    return std::nullopt;
}

// _loop0_32: ',' expr
std::optional<ast::sequence<ast::expr>> Parser::parse__loop0_32_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    std::vector<ast::field<ast::expr>> _children{};
    { // ',' expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop0_32", _state, tell(), "',' expr");
        while (true) {
            auto _literal = lexer.expect().punct(lex::Punct::COMMA);
            if (_literal) {
            auto _user_opt_elem = parse_expr_rule();
            if (_user_opt_elem) { auto elem = std::move(*_user_opt_elem);
                _res = elem;
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "',' expr");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop0_32", _state, tell(), "',' expr");
    }
    auto _seq = ast::make_sequence<ast::expr>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _gather_31: expr _loop0_32
std::optional<ast::sequence<ast::expr>> Parser::parse__gather_31_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::sequence<ast::expr>> _res = std::nullopt;
    { // expr _loop0_32
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_gather_31", _state, tell(), "expr _loop0_32");
        auto _user_opt_expr_var = parse_expr_rule();
        if (_user_opt_expr_var) { auto expr_var = std::move(*_user_opt_expr_var);
        auto _user_opt_seq = parse__loop0_32_rule();
        if (_user_opt_seq) { auto seq = std::move(*_user_opt_seq);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_gather_31", _state, tell(), "expr _loop0_32");
            _res = std::move(seq);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr _loop0_32");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_gather_31", _state, tell(), "expr _loop0_32");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_gather_31");
    --_level;
    return std::nullopt;
}

// _loop0_33: stmt
std::optional<ast::sequence<ast::stmt>> Parser::parse__loop0_33_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    std::vector<ast::field<ast::stmt>> _children{};
    { // stmt
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop0_33", _state, tell(), "stmt");
        while (true) {
            auto _single_result = parse_stmt_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "stmt");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop0_33", _state, tell(), "stmt");
    }
    auto _seq = ast::make_sequence<ast::stmt>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _tmp_34: ',' arg_spec
std::optional<ast::field<ast::arg_spec>> Parser::parse__tmp_34_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::arg_spec>> _res = std::nullopt;
    { // ',' arg_spec
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_34", _state, tell(), "',' arg_spec");
        auto _literal = lexer.expect().punct(lex::Punct::COMMA);
        if (_literal) {
        auto _single_result = parse_arg_spec_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_34", _state, tell(), "',' arg_spec");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "',' arg_spec");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_34", _state, tell(), "',' arg_spec");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_34");
    --_level;
    return std::nullopt;
}

// _tmp_35: 'and' expr_1
std::optional<ast::field<ast::expr>> Parser::parse__tmp_35_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'and' expr_1
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_35", _state, tell(), "'and' expr_1");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::AND);
        if (_keyword) {
        auto _single_result = parse_expr_1_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_35", _state, tell(), "'and' expr_1");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'and' expr_1");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_35", _state, tell(), "'and' expr_1");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_35");
    --_level;
    return std::nullopt;
}

// _tmp_36: 'or' expr_1
std::optional<ast::field<ast::expr>> Parser::parse__tmp_36_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'or' expr_1
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_36", _state, tell(), "'or' expr_1");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::OR);
        if (_keyword) {
        auto _single_result = parse_expr_1_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_36", _state, tell(), "'or' expr_1");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'or' expr_1");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_36", _state, tell(), "'or' expr_1");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_36");
    --_level;
    return std::nullopt;
}

// _tmp_37: !any_paren any_token
std::optional<lex::Token> Parser::parse__tmp_37_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<lex::Token> _res = std::nullopt;
    { // !any_paren any_token
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_37", _state, tell(), "!any_paren any_token");
        auto _tmpvar = lookahead(false, [&]() { return parse_any_paren_rule(); });
        if (_tmpvar) {
        auto _single_result = parse_any_token_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_37", _state, tell(), "!any_paren any_token");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "!any_paren any_token");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_37", _state, tell(), "!any_paren any_token");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_37");
    --_level;
    return std::nullopt;
}

#pragma endregion Rule parsers


}  // namespace bondrewd::parse
