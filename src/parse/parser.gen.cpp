// AUTOGENERATED by bondrewd/tools/pegen++/pegenxx.py on 2023-03-16 19:39:13
// DO NOT EDIT

#include <bondrewd/parse/parser.gen.hpp>


#if 1
#define PARSER_DBG_(...)  fprintf(stderr, "[Parser] " __VA_ARGS__)
#else
#define PARSER_DBG_(...)
#endif


namespace bondrewd::parse {


#pragma region Rule parsers

// start: cartridge
std::optional<ast::field<ast::cartridge>> Parser::parse_start_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::cartridge>> _res = std::nullopt;
    { // cartridge
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "start", _state, tell(), "cartridge");
        auto _single_result = parse_cartridge_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "start", _state, tell(), "cartridge");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "cartridge");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "start", _state, tell(), "cartridge");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "start");
    --_level;
    return std::nullopt;
}

// cartridge: cartridge_header stmt* $
std::optional<ast::field<ast::cartridge>> Parser::parse_cartridge_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::cartridge>> _res = std::nullopt;
    { // cartridge_header stmt* $
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "cartridge", _state, tell(), "cartridge_header stmt* $");
        auto _user_opt_h = parse_cartridge_header_rule();
        if (_user_opt_h) { auto h = std::move(*_user_opt_h);
        auto _user_opt_b = parse__loop0_1_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _token = lexer.expect().token(lex::TokenType::endmarker);
        if (_token) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "cartridge", _state, tell(), "cartridge_header stmt* $");
            _res = ast::Cartridge ( std::move ( h ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "cartridge_header stmt* $");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "cartridge", _state, tell(), "cartridge_header stmt* $");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "cartridge");
    --_level;
    return std::nullopt;
}

// cartridge_header: 'cartridge' name ';'
std::optional<std::string> Parser::parse_cartridge_header_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<std::string> _res = std::nullopt;
    { // 'cartridge' name ';'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "cartridge_header", _state, tell(), "'cartridge' name ';'");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::CARTRIDGE);
        if (_keyword) {
        auto _user_opt_n = parse_name_rule();
        if (_user_opt_n) { auto n = std::move(*_user_opt_n);
        auto _literal = lexer.expect().punct(lex::Punct::SEMI);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "cartridge_header", _state, tell(), "'cartridge' name ';'");
            _res = std::move ( n );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'cartridge' name ';'");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "cartridge_header", _state, tell(), "'cartridge' name ';'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "cartridge_header");
    --_level;
    return std::nullopt;
}

// stmt: var_def_stmt | impl_stmt | assign_stmt | expr_stmt | ';'
std::optional<ast::field<ast::stmt>> Parser::parse_stmt_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::stmt>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    { // var_def_stmt
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "stmt", _state, tell(), "var_def_stmt");
        auto _single_result = parse_var_def_stmt_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "stmt", _state, tell(), "var_def_stmt");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "var_def_stmt");
            --_level;
            store_cached<RuleType::stmt>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "stmt", _state, tell(), "var_def_stmt");
    }
    { // impl_stmt
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "stmt", _state, tell(), "impl_stmt");
        auto _single_result = parse_impl_stmt_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "stmt", _state, tell(), "impl_stmt");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "impl_stmt");
            --_level;
            store_cached<RuleType::stmt>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "stmt", _state, tell(), "impl_stmt");
    }
    { // assign_stmt
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "stmt", _state, tell(), "assign_stmt");
        auto _single_result = parse_assign_stmt_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "stmt", _state, tell(), "assign_stmt");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "assign_stmt");
            --_level;
            store_cached<RuleType::stmt>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "stmt", _state, tell(), "assign_stmt");
    }
    { // expr_stmt
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "stmt", _state, tell(), "expr_stmt");
        auto _single_result = parse_expr_stmt_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "stmt", _state, tell(), "expr_stmt");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr_stmt");
            --_level;
            store_cached<RuleType::stmt>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "stmt", _state, tell(), "expr_stmt");
    }
    { // ';'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "stmt", _state, tell(), "';'");
        auto _literal = lexer.expect().punct(lex::Punct::SEMI);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "stmt", _state, tell(), "';'");
            _res = ast::Pass ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "';'");
            --_level;
            store_cached<RuleType::stmt>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "stmt", _state, tell(), "';'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "stmt");
    --_level;
    store_cached<RuleType::stmt>(_state, std::nullopt);
    return std::nullopt;
}

// assign_stmt: expr assign_op expr ';'
std::optional<ast::field<ast::stmt>> Parser::parse_assign_stmt_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    { // expr assign_op expr ';'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_stmt", _state, tell(), "expr assign_op expr ';'");
        auto _user_opt_a = parse_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _user_opt_op = parse_assign_op_rule();
        if (_user_opt_op) { auto op = std::move(*_user_opt_op);
        auto _user_opt_b = parse_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _literal = lexer.expect().punct(lex::Punct::SEMI);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_stmt", _state, tell(), "expr assign_op expr ';'");
            _res = ast::Assign ( std::move ( a ) , std::move ( b ) , std::move ( op ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr assign_op expr ';'");
            --_level;
            return _res;
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_stmt", _state, tell(), "expr assign_op expr ';'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "assign_stmt");
    --_level;
    return std::nullopt;
}

// assign_op: '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '|=' | '^='
std::optional<ast::field<ast::assign_op>> Parser::parse_assign_op_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::assign_op>> _res = std::nullopt;
    { // '='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'='");
        auto _literal = lexer.expect().punct(lex::Punct::EQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'='");
            _res = ast::AsgnNone ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'='");
    }
    { // '+='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'+='");
        auto _literal = lexer.expect().punct(lex::Punct::PLUSEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'+='");
            _res = ast::AsgnAdd ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'+='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'+='");
    }
    { // '-='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'-='");
        auto _literal = lexer.expect().punct(lex::Punct::MINEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'-='");
            _res = ast::AsgnSub ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'-='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'-='");
    }
    { // '*='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'*='");
        auto _literal = lexer.expect().punct(lex::Punct::STAREQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'*='");
            _res = ast::AsgnMul ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'*='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'*='");
    }
    { // '/='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'/='");
        auto _literal = lexer.expect().punct(lex::Punct::SLASHEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'/='");
            _res = ast::AsgnDiv ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'/='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'/='");
    }
    { // '%='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'%='");
        auto _literal = lexer.expect().punct(lex::Punct::PERCENTEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'%='");
            _res = ast::AsgnMod ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'%='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'%='");
    }
    { // '<<='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'<<='");
        auto _literal = lexer.expect().punct(lex::Punct::LEFTSHIFTEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'<<='");
            _res = ast::AsgnLShift ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'<<='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'<<='");
    }
    { // '>>='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'>>='");
        auto _literal = lexer.expect().punct(lex::Punct::RIGHTSHIFTEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'>>='");
            _res = ast::AsgnRShift ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'>>='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'>>='");
    }
    { // '&='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'&='");
        auto _literal = lexer.expect().punct(lex::Punct::AMPEREQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'&='");
            _res = ast::AsgnBitAnd ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'&='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'&='");
    }
    { // '|='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'|='");
        auto _literal = lexer.expect().punct(lex::Punct::VBAREQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'|='");
            _res = ast::AsgnBitOr ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'|='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'|='");
    }
    { // '^='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "assign_op", _state, tell(), "'^='");
        auto _literal = lexer.expect().punct(lex::Punct::CIRCUMFLEXEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "assign_op", _state, tell(), "'^='");
            _res = ast::AsgnBitXor ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'^='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "assign_op", _state, tell(), "'^='");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "assign_op");
    --_level;
    return std::nullopt;
}

// var_def_stmt: 'ctime'? 'var' name type_annotation? ['=' expr] ';'
std::optional<ast::field<ast::stmt>> Parser::parse_var_def_stmt_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    { // 'ctime'? 'var' name type_annotation? ['=' expr] ';'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "var_def_stmt", _state, tell(), "'ctime'? 'var' name type_annotation? ['=' expr] ';'");
        auto _user_opt_c = lexer.expect().keyword(lex::HardKeyword::CTIME);
        if (true) { auto c = _user_opt_c;
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::VAR);
        if (_keyword) {
        auto _user_opt_n = parse_name_rule();
        if (_user_opt_n) { auto n = std::move(*_user_opt_n);
        auto _user_opt_t = parse_type_annotation_rule();
        if (true) { auto t = _user_opt_t;
        auto _user_opt_v = parse__tmp_2_rule();
        if (true) { auto v = _user_opt_v;
        auto _literal = lexer.expect().punct(lex::Punct::SEMI);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "var_def_stmt", _state, tell(), "'ctime'? 'var' name type_annotation? ['=' expr] ';'");
            _res = ast::VarDef ( std::move ( n ) , _opt2maybe ( std::move ( t ) ) , _opt2maybe ( std::move ( v ) ) , true , bool ( c ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'ctime'? 'var' name type_annotation? ['=' expr] ';'");
            --_level;
            return _res;
        }
        }
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "var_def_stmt", _state, tell(), "'ctime'? 'var' name type_annotation? ['=' expr] ';'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "var_def_stmt");
    --_level;
    return std::nullopt;
}

// impl_stmt: 
std::optional<ast::field<ast::stmt>> Parser::parse_impl_stmt_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    PARSER_DBG_("Fail at %zu: %s\n", _state, "impl_stmt");
    --_level;
    return std::nullopt;
}

// expr_stmt: expr ';'
std::optional<ast::field<ast::stmt>> Parser::parse_expr_stmt_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    { // expr ';'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_stmt", _state, tell(), "expr ';'");
        auto _user_opt_a = parse_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::SEMI);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_stmt", _state, tell(), "expr ';'");
            _res = ast::Expr ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr ';'");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_stmt", _state, tell(), "expr ';'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expr_stmt");
    --_level;
    return std::nullopt;
}

// expr: func_def | 'return' expr_or_unit | 'break' expr_or_unit | disjunction_expr
std::optional<ast::field<ast::expr>> Parser::parse_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // func_def
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr", _state, tell(), "func_def");
        auto _single_result = parse_func_def_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr", _state, tell(), "func_def");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "func_def");
            --_level;
            store_cached<RuleType::expr>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr", _state, tell(), "func_def");
    }
    { // 'return' expr_or_unit
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr", _state, tell(), "'return' expr_or_unit");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::RETURN);
        if (_keyword) {
        auto _user_opt_a = parse_expr_or_unit_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr", _state, tell(), "'return' expr_or_unit");
            _res = ast::Return ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'return' expr_or_unit");
            --_level;
            store_cached<RuleType::expr>(_state, _res);
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr", _state, tell(), "'return' expr_or_unit");
    }
    { // 'break' expr_or_unit
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr", _state, tell(), "'break' expr_or_unit");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::BREAK);
        if (_keyword) {
        auto _user_opt_a = parse_expr_or_unit_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr", _state, tell(), "'break' expr_or_unit");
            _res = ast::Break ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'break' expr_or_unit");
            --_level;
            store_cached<RuleType::expr>(_state, _res);
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr", _state, tell(), "'break' expr_or_unit");
    }
    { // disjunction_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr", _state, tell(), "disjunction_expr");
        auto _single_result = parse_disjunction_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr", _state, tell(), "disjunction_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "disjunction_expr");
            --_level;
            store_cached<RuleType::expr>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr", _state, tell(), "disjunction_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expr");
    --_level;
    store_cached<RuleType::expr>(_state, std::nullopt);
    return std::nullopt;
}

// expr_or_unit: expr | 
std::optional<ast::field<ast::expr>> Parser::parse_expr_or_unit_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_or_unit", _state, tell(), "expr");
        auto _single_result = parse_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_or_unit", _state, tell(), "expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_or_unit", _state, tell(), "expr");
    }
    { // 
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "expr_or_unit", _state, tell(), "");
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "expr_or_unit", _state, tell(), "");
            _res = ast::Constant ( std::monostate ( ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "");
            --_level;
            return _res;
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "expr_or_unit", _state, tell(), "");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "expr_or_unit");
    --_level;
    return std::nullopt;
}

// disjunction_expr: conjunction_expr (('or' conjunction_expr))+ | conjunction_expr
std::optional<ast::field<ast::expr>> Parser::parse_disjunction_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::disjunction_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // conjunction_expr (('or' conjunction_expr))+
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "disjunction_expr", _state, tell(), "conjunction_expr (('or' conjunction_expr))+");
        auto _user_opt_a = parse_conjunction_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _user_opt_b = parse__loop1_3_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "disjunction_expr", _state, tell(), "conjunction_expr (('or' conjunction_expr))+");
            _res = ast::BoolOp ( ast::Or ( ) , ast::make_sequence < ast::expr > ( ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "conjunction_expr (('or' conjunction_expr))+");
            --_level;
            store_cached<RuleType::disjunction_expr>(_state, _res);
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "disjunction_expr", _state, tell(), "conjunction_expr (('or' conjunction_expr))+");
    }
    { // conjunction_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "disjunction_expr", _state, tell(), "conjunction_expr");
        auto _single_result = parse_conjunction_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "disjunction_expr", _state, tell(), "conjunction_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "conjunction_expr");
            --_level;
            store_cached<RuleType::disjunction_expr>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "disjunction_expr", _state, tell(), "conjunction_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "disjunction_expr");
    --_level;
    store_cached<RuleType::disjunction_expr>(_state, std::nullopt);
    return std::nullopt;
}

// conjunction_expr: inversion_expr (('and' inversion_expr))+ | inversion_expr
std::optional<ast::field<ast::expr>> Parser::parse_conjunction_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::conjunction_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // inversion_expr (('and' inversion_expr))+
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "conjunction_expr", _state, tell(), "inversion_expr (('and' inversion_expr))+");
        auto _user_opt_a = parse_inversion_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _user_opt_b = parse__loop1_4_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "conjunction_expr", _state, tell(), "inversion_expr (('and' inversion_expr))+");
            _res = ast::BoolOp ( ast::And ( ) , ast::make_sequence < ast::expr > ( ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "inversion_expr (('and' inversion_expr))+");
            --_level;
            store_cached<RuleType::conjunction_expr>(_state, _res);
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "conjunction_expr", _state, tell(), "inversion_expr (('and' inversion_expr))+");
    }
    { // inversion_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "conjunction_expr", _state, tell(), "inversion_expr");
        auto _single_result = parse_inversion_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "conjunction_expr", _state, tell(), "inversion_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "inversion_expr");
            --_level;
            store_cached<RuleType::conjunction_expr>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "conjunction_expr", _state, tell(), "inversion_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "conjunction_expr");
    --_level;
    store_cached<RuleType::conjunction_expr>(_state, std::nullopt);
    return std::nullopt;
}

// inversion_expr: 'not' inversion_expr | comparison_expr
std::optional<ast::field<ast::expr>> Parser::parse_inversion_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::inversion_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'not' inversion_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "inversion_expr", _state, tell(), "'not' inversion_expr");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::NOT);
        if (_keyword) {
        auto _user_opt_a = parse_inversion_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "inversion_expr", _state, tell(), "'not' inversion_expr");
            _res = ast::UnOp ( ast::Not ( ) , std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'not' inversion_expr");
            --_level;
            store_cached<RuleType::inversion_expr>(_state, _res);
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "inversion_expr", _state, tell(), "'not' inversion_expr");
    }
    { // comparison_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "inversion_expr", _state, tell(), "comparison_expr");
        auto _single_result = parse_comparison_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "inversion_expr", _state, tell(), "comparison_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "comparison_expr");
            --_level;
            store_cached<RuleType::inversion_expr>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "inversion_expr", _state, tell(), "comparison_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "inversion_expr");
    --_level;
    store_cached<RuleType::inversion_expr>(_state, std::nullopt);
    return std::nullopt;
}

// comparison_expr: bidir_cmp_expr comparison_followup_pair+ | bidir_cmp_expr
std::optional<ast::field<ast::expr>> Parser::parse_comparison_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // bidir_cmp_expr comparison_followup_pair+
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_expr", _state, tell(), "bidir_cmp_expr comparison_followup_pair+");
        auto _user_opt_a = parse_bidir_cmp_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _user_opt_b = parse__loop1_5_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_expr", _state, tell(), "bidir_cmp_expr comparison_followup_pair+");
            _res = ast::Compare ( std::move ( a ) , ast::make_sequence < ast::cmp_op > ( ) , ast::make_sequence < ast::expr > ( ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bidir_cmp_expr comparison_followup_pair+");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_expr", _state, tell(), "bidir_cmp_expr comparison_followup_pair+");
    }
    { // bidir_cmp_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_expr", _state, tell(), "bidir_cmp_expr");
        auto _single_result = parse_bidir_cmp_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_expr", _state, tell(), "bidir_cmp_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bidir_cmp_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_expr", _state, tell(), "bidir_cmp_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "comparison_expr");
    --_level;
    return std::nullopt;
}

// comparison_followup_pair: comparison_op bidir_cmp_expr
std::optional<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>> Parser::parse_comparison_followup_pair_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>> _res = std::nullopt;
    { // comparison_op bidir_cmp_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_followup_pair", _state, tell(), "comparison_op bidir_cmp_expr");
        auto _user_opt_o = parse_comparison_op_rule();
        if (_user_opt_o) { auto o = std::move(*_user_opt_o);
        auto _user_opt_a = parse_bidir_cmp_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_followup_pair", _state, tell(), "comparison_op bidir_cmp_expr");
            _res = std::make_pair ( std::move ( o ) , std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "comparison_op bidir_cmp_expr");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_followup_pair", _state, tell(), "comparison_op bidir_cmp_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "comparison_followup_pair");
    --_level;
    return std::nullopt;
}

// comparison_op: '==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in'
std::optional<ast::field<ast::cmp_op>> Parser::parse_comparison_op_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::cmp_op>> _res = std::nullopt;
    { // '=='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'=='");
        auto _literal = lexer.expect().punct(lex::Punct::DOUBLEEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'=='");
            _res = ast::Eq ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'=='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'=='");
    }
    { // '!='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'!='");
        auto _literal = lexer.expect().punct(lex::Punct::NOTEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'!='");
            _res = ast::NotEq ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'!='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'!='");
    }
    { // '<'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'<'");
        auto _literal = lexer.expect().punct(lex::Punct::LESS);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'<'");
            _res = ast::Lt ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'<'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'<'");
    }
    { // '<='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'<='");
        auto _literal = lexer.expect().punct(lex::Punct::LESSEQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'<='");
            _res = ast::LtE ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'<='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'<='");
    }
    { // '>'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'>'");
        auto _literal = lexer.expect().punct(lex::Punct::GREATER);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'>'");
            _res = ast::Gt ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'>'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'>'");
    }
    { // '>='
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'>='");
        auto _literal = lexer.expect().punct(lex::Punct::GREATEREQUAL);
        if (_literal) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'>='");
            _res = ast::GtE ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'>='");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'>='");
    }
    { // 'in'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'in'");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::IN);
        if (_keyword) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'in'");
            _res = ast::In ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'in'");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'in'");
    }
    { // 'not' 'in'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "comparison_op", _state, tell(), "'not' 'in'");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::NOT);
        if (_keyword) {
        auto _keyword_1 = lexer.expect().keyword(lex::HardKeyword::IN);
        if (_keyword_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "comparison_op", _state, tell(), "'not' 'in'");
            _res = ast::NotIn ( );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'not' 'in'");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "comparison_op", _state, tell(), "'not' 'in'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "comparison_op");
    --_level;
    return std::nullopt;
}

// bidir_cmp_expr: bitor_expr '<=>' bitor_expr | bitor_expr
std::optional<ast::field<ast::expr>> Parser::parse_bidir_cmp_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // bitor_expr '<=>' bitor_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bidir_cmp_expr", _state, tell(), "bitor_expr '<=>' bitor_expr");
        auto _user_opt_a = parse_bitor_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::BIDIRCMP);
        if (_literal) {
        auto _user_opt_b = parse_bitor_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bidir_cmp_expr", _state, tell(), "bitor_expr '<=>' bitor_expr");
            _res = ast::BinOp ( ast::BidirCmp ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bitor_expr '<=>' bitor_expr");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bidir_cmp_expr", _state, tell(), "bitor_expr '<=>' bitor_expr");
    }
    { // bitor_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bidir_cmp_expr", _state, tell(), "bitor_expr");
        auto _single_result = parse_bitor_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bidir_cmp_expr", _state, tell(), "bitor_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bitor_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bidir_cmp_expr", _state, tell(), "bitor_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "bidir_cmp_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// bitor_expr: bitor_expr '|' bitxor_expr | bitxor_expr
std::optional<ast::field<ast::expr>> Parser::parse_bitor_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::bitor_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    bool _first = true;
    while (true) {
        store_cached<RuleType::bitor_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_bitor_expr();
        if (!_raw || (tell() <= _res_state && !_first)) {
            break;
        }
        _first = false;
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    --_level;
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_bitor_expr()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // bitor_expr '|' bitxor_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bitor_expr", _state, tell(), "bitor_expr '|' bitxor_expr");
        auto _user_opt_a = parse_bitor_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::VBAR);
        if (_literal) {
        auto _user_opt_b = parse_bitxor_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bitor_expr", _state, tell(), "bitor_expr '|' bitxor_expr");
            _res = ast::BinOp ( ast::BitOr ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bitor_expr '|' bitxor_expr");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bitor_expr", _state, tell(), "bitor_expr '|' bitxor_expr");
    }
    { // bitxor_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bitor_expr", _state, tell(), "bitxor_expr");
        auto _single_result = parse_bitxor_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bitor_expr", _state, tell(), "bitxor_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bitxor_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bitor_expr", _state, tell(), "bitxor_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "bitor_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// bitxor_expr: bitxor_expr '^' bitand_expr | bitand_expr
std::optional<ast::field<ast::expr>> Parser::parse_bitxor_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::bitxor_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    bool _first = true;
    while (true) {
        store_cached<RuleType::bitxor_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_bitxor_expr();
        if (!_raw || (tell() <= _res_state && !_first)) {
            break;
        }
        _first = false;
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    --_level;
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_bitxor_expr()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // bitxor_expr '^' bitand_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bitxor_expr", _state, tell(), "bitxor_expr '^' bitand_expr");
        auto _user_opt_a = parse_bitxor_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::CIRCUMFLEX);
        if (_literal) {
        auto _user_opt_b = parse_bitand_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bitxor_expr", _state, tell(), "bitxor_expr '^' bitand_expr");
            _res = ast::BinOp ( ast::BitXor ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bitxor_expr '^' bitand_expr");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bitxor_expr", _state, tell(), "bitxor_expr '^' bitand_expr");
    }
    { // bitand_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bitxor_expr", _state, tell(), "bitand_expr");
        auto _single_result = parse_bitand_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bitxor_expr", _state, tell(), "bitand_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bitand_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bitxor_expr", _state, tell(), "bitand_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "bitxor_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// bitand_expr: bitand_expr '&' shift_expr | shift_expr
std::optional<ast::field<ast::expr>> Parser::parse_bitand_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::bitand_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    bool _first = true;
    while (true) {
        store_cached<RuleType::bitand_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_bitand_expr();
        if (!_raw || (tell() <= _res_state && !_first)) {
            break;
        }
        _first = false;
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    --_level;
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_bitand_expr()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // bitand_expr '&' shift_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bitand_expr", _state, tell(), "bitand_expr '&' shift_expr");
        auto _user_opt_a = parse_bitand_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::AMPER);
        if (_literal) {
        auto _user_opt_b = parse_shift_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bitand_expr", _state, tell(), "bitand_expr '&' shift_expr");
            _res = ast::BinOp ( ast::BitAnd ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "bitand_expr '&' shift_expr");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bitand_expr", _state, tell(), "bitand_expr '&' shift_expr");
    }
    { // shift_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "bitand_expr", _state, tell(), "shift_expr");
        auto _single_result = parse_shift_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "bitand_expr", _state, tell(), "shift_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "shift_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "bitand_expr", _state, tell(), "shift_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "bitand_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// shift_expr: shift_expr '<<' sum_expr | shift_expr '>>' sum_expr | sum_expr
std::optional<ast::field<ast::expr>> Parser::parse_shift_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::shift_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    bool _first = true;
    while (true) {
        store_cached<RuleType::shift_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_shift_expr();
        if (!_raw || (tell() <= _res_state && !_first)) {
            break;
        }
        _first = false;
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    --_level;
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_shift_expr()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // shift_expr '<<' sum_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "shift_expr", _state, tell(), "shift_expr '<<' sum_expr");
        auto _user_opt_a = parse_shift_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::LEFTSHIFT);
        if (_literal) {
        auto _user_opt_b = parse_sum_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "shift_expr", _state, tell(), "shift_expr '<<' sum_expr");
            _res = ast::BinOp ( ast::LShift ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "shift_expr '<<' sum_expr");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "shift_expr", _state, tell(), "shift_expr '<<' sum_expr");
    }
    { // shift_expr '>>' sum_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "shift_expr", _state, tell(), "shift_expr '>>' sum_expr");
        auto _user_opt_a = parse_shift_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::RIGHTSHIFT);
        if (_literal) {
        auto _user_opt_b = parse_sum_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "shift_expr", _state, tell(), "shift_expr '>>' sum_expr");
            _res = ast::BinOp ( ast::RShift ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "shift_expr '>>' sum_expr");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "shift_expr", _state, tell(), "shift_expr '>>' sum_expr");
    }
    { // sum_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "shift_expr", _state, tell(), "sum_expr");
        auto _single_result = parse_sum_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "shift_expr", _state, tell(), "sum_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "sum_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "shift_expr", _state, tell(), "sum_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "shift_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// sum_expr: sum_expr '+' term_expr | sum_expr '-' term_expr | term_expr
std::optional<ast::field<ast::expr>> Parser::parse_sum_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::sum_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    bool _first = true;
    while (true) {
        store_cached<RuleType::sum_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_sum_expr();
        if (!_raw || (tell() <= _res_state && !_first)) {
            break;
        }
        _first = false;
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    --_level;
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_sum_expr()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // sum_expr '+' term_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "sum_expr", _state, tell(), "sum_expr '+' term_expr");
        auto _user_opt_a = parse_sum_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::PLUS);
        if (_literal) {
        auto _user_opt_b = parse_term_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "sum_expr", _state, tell(), "sum_expr '+' term_expr");
            _res = ast::BinOp ( ast::Add ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "sum_expr '+' term_expr");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "sum_expr", _state, tell(), "sum_expr '+' term_expr");
    }
    { // sum_expr '-' term_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "sum_expr", _state, tell(), "sum_expr '-' term_expr");
        auto _user_opt_a = parse_sum_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::MINUS);
        if (_literal) {
        auto _user_opt_b = parse_term_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "sum_expr", _state, tell(), "sum_expr '-' term_expr");
            _res = ast::BinOp ( ast::Sub ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "sum_expr '-' term_expr");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "sum_expr", _state, tell(), "sum_expr '-' term_expr");
    }
    { // term_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "sum_expr", _state, tell(), "term_expr");
        auto _single_result = parse_term_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "sum_expr", _state, tell(), "term_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "term_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "sum_expr", _state, tell(), "term_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "sum_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// term_expr:
//     | term_expr '*' factor_expr
//     | term_expr '/' factor_expr
//     | term_expr '%' factor_expr
//     | factor_expr
std::optional<ast::field<ast::expr>> Parser::parse_term_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::term_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    bool _first = true;
    while (true) {
        store_cached<RuleType::term_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_term_expr();
        if (!_raw || (tell() <= _res_state && !_first)) {
            break;
        }
        _first = false;
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    --_level;
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_term_expr()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // term_expr '*' factor_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "term_expr", _state, tell(), "term_expr '*' factor_expr");
        auto _user_opt_a = parse_term_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::STAR);
        if (_literal) {
        auto _user_opt_b = parse_factor_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "term_expr", _state, tell(), "term_expr '*' factor_expr");
            _res = ast::BinOp ( ast::Mul ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "term_expr '*' factor_expr");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "term_expr", _state, tell(), "term_expr '*' factor_expr");
    }
    { // term_expr '/' factor_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "term_expr", _state, tell(), "term_expr '/' factor_expr");
        auto _user_opt_a = parse_term_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::SLASH);
        if (_literal) {
        auto _user_opt_b = parse_factor_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "term_expr", _state, tell(), "term_expr '/' factor_expr");
            _res = ast::BinOp ( ast::Div ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "term_expr '/' factor_expr");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "term_expr", _state, tell(), "term_expr '/' factor_expr");
    }
    { // term_expr '%' factor_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "term_expr", _state, tell(), "term_expr '%' factor_expr");
        auto _user_opt_a = parse_term_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::PERCENT);
        if (_literal) {
        auto _user_opt_b = parse_factor_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "term_expr", _state, tell(), "term_expr '%' factor_expr");
            _res = ast::BinOp ( ast::Mod ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "term_expr '%' factor_expr");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "term_expr", _state, tell(), "term_expr '%' factor_expr");
    }
    { // factor_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "term_expr", _state, tell(), "factor_expr");
        auto _single_result = parse_factor_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "term_expr", _state, tell(), "factor_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "factor_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "term_expr", _state, tell(), "factor_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "term_expr");
    --_level;
    return std::nullopt;
}

// factor_expr:
//     | '+' factor_expr
//     | '-' factor_expr
//     | '~' factor_expr
//     | '&' factor_expr
//     | '*' factor_expr
//     | power_expr
std::optional<ast::field<ast::expr>> Parser::parse_factor_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::factor_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '+' factor_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "factor_expr", _state, tell(), "'+' factor_expr");
        auto _literal = lexer.expect().punct(lex::Punct::PLUS);
        if (_literal) {
        auto _user_opt_a = parse_factor_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "factor_expr", _state, tell(), "'+' factor_expr");
            _res = ast::UnOp ( ast::UAdd ( ) , std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'+' factor_expr");
            --_level;
            store_cached<RuleType::factor_expr>(_state, _res);
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "factor_expr", _state, tell(), "'+' factor_expr");
    }
    { // '-' factor_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "factor_expr", _state, tell(), "'-' factor_expr");
        auto _literal = lexer.expect().punct(lex::Punct::MINUS);
        if (_literal) {
        auto _user_opt_a = parse_factor_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "factor_expr", _state, tell(), "'-' factor_expr");
            _res = ast::UnOp ( ast::USub ( ) , std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'-' factor_expr");
            --_level;
            store_cached<RuleType::factor_expr>(_state, _res);
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "factor_expr", _state, tell(), "'-' factor_expr");
    }
    { // '~' factor_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "factor_expr", _state, tell(), "'~' factor_expr");
        auto _literal = lexer.expect().punct(lex::Punct::TILDE);
        if (_literal) {
        auto _user_opt_a = parse_factor_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "factor_expr", _state, tell(), "'~' factor_expr");
            _res = ast::UnOp ( ast::BitInv ( ) , std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'~' factor_expr");
            --_level;
            store_cached<RuleType::factor_expr>(_state, _res);
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "factor_expr", _state, tell(), "'~' factor_expr");
    }
    { // '&' factor_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "factor_expr", _state, tell(), "'&' factor_expr");
        auto _literal = lexer.expect().punct(lex::Punct::AMPER);
        if (_literal) {
        auto _user_opt_a = parse_factor_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "factor_expr", _state, tell(), "'&' factor_expr");
            _res = ast::UnOp ( ast::URef ( ) , std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'&' factor_expr");
            --_level;
            store_cached<RuleType::factor_expr>(_state, _res);
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "factor_expr", _state, tell(), "'&' factor_expr");
    }
    { // '*' factor_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "factor_expr", _state, tell(), "'*' factor_expr");
        auto _literal = lexer.expect().punct(lex::Punct::STAR);
        if (_literal) {
        auto _user_opt_a = parse_factor_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "factor_expr", _state, tell(), "'*' factor_expr");
            _res = ast::UnOp ( ast::UStar ( ) , std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'*' factor_expr");
            --_level;
            store_cached<RuleType::factor_expr>(_state, _res);
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "factor_expr", _state, tell(), "'*' factor_expr");
    }
    { // power_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "factor_expr", _state, tell(), "power_expr");
        auto _single_result = parse_power_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "factor_expr", _state, tell(), "power_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "power_expr");
            --_level;
            store_cached<RuleType::factor_expr>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "factor_expr", _state, tell(), "power_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "factor_expr");
    --_level;
    store_cached<RuleType::factor_expr>(_state, std::nullopt);
    return std::nullopt;
}

// power_expr: primary_expr '**' factor_expr | primary_expr
std::optional<ast::field<ast::expr>> Parser::parse_power_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // primary_expr '**' factor_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "power_expr", _state, tell(), "primary_expr '**' factor_expr");
        auto _user_opt_a = parse_primary_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::POWER);
        if (_literal) {
        auto _user_opt_b = parse_factor_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "power_expr", _state, tell(), "primary_expr '**' factor_expr");
            _res = ast::BinOp ( ast::Pow ( ) , std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "primary_expr '**' factor_expr");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "power_expr", _state, tell(), "primary_expr '**' factor_expr");
    }
    { // primary_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "power_expr", _state, tell(), "primary_expr");
        auto _single_result = parse_primary_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "power_expr", _state, tell(), "primary_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "primary_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "power_expr", _state, tell(), "primary_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "power_expr");
    --_level;
    return std::nullopt;
}

// Left-recursive
// primary_expr:
//     | primary_expr '.' name
//     | primary_expr '::' name
//     | primary_expr '[' call_args ']'
//     | primary_expr '(' call_args ')'
//     | atom_expr
std::optional<ast::field<ast::expr>> Parser::parse_primary_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    auto _res_state = tell();
    if (auto _cached = get_cached<RuleType::primary_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    bool _first = true;
    while (true) {
        store_cached<RuleType::primary_expr>(_state, _res);
        seek(_state);
        auto _raw = parse_raw_primary_expr();
        if (!_raw || (tell() <= _res_state && !_first)) {
            break;
        }
        _first = false;
        _res = std::move(_raw);
        _res_state = tell();
    }
    seek(_res_state);
    --_level;
    return _res;
}
std::optional<ast::field<ast::expr>> Parser::parse_raw_primary_expr()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // primary_expr '.' name
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "primary_expr", _state, tell(), "primary_expr '.' name");
        auto _user_opt_a = parse_primary_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::DOT);
        if (_literal) {
        auto _user_opt_b = parse_name_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "primary_expr", _state, tell(), "primary_expr '.' name");
            _res = ast::Attribute ( std::move ( a ) , std::move ( b ) , ast::AttrInst ( ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "primary_expr '.' name");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "primary_expr", _state, tell(), "primary_expr '.' name");
    }
    { // primary_expr '::' name
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "primary_expr", _state, tell(), "primary_expr '::' name");
        auto _user_opt_a = parse_primary_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::DOUBLECOLON);
        if (_literal) {
        auto _user_opt_b = parse_name_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "primary_expr", _state, tell(), "primary_expr '::' name");
            _res = ast::Attribute ( std::move ( a ) , std::move ( b ) , ast::AttrStatic ( ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "primary_expr '::' name");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "primary_expr", _state, tell(), "primary_expr '::' name");
    }
    { // primary_expr '[' call_args ']'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "primary_expr", _state, tell(), "primary_expr '[' call_args ']'");
        auto _user_opt_a = parse_primary_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::LSQB);
        if (_literal) {
        auto _user_opt_b = parse_call_args_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _literal_1 = lexer.expect().punct(lex::Punct::RSQB);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "primary_expr", _state, tell(), "primary_expr '[' call_args ']'");
            _res = ast::Subscript ( std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "primary_expr '[' call_args ']'");
            --_level;
            return _res;
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "primary_expr", _state, tell(), "primary_expr '[' call_args ']'");
    }
    { // primary_expr '(' call_args ')'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "primary_expr", _state, tell(), "primary_expr '(' call_args ')'");
        auto _user_opt_a = parse_primary_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal = lexer.expect().punct(lex::Punct::LPAR);
        if (_literal) {
        auto _user_opt_b = parse_call_args_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "primary_expr", _state, tell(), "primary_expr '(' call_args ')'");
            _res = ast::Call ( std::move ( a ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "primary_expr '(' call_args ')'");
            --_level;
            return _res;
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "primary_expr", _state, tell(), "primary_expr '(' call_args ')'");
    }
    { // atom_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "primary_expr", _state, tell(), "atom_expr");
        auto _single_result = parse_atom_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "primary_expr", _state, tell(), "atom_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "atom_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "primary_expr", _state, tell(), "atom_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "primary_expr");
    --_level;
    return std::nullopt;
}

// atom_expr:
//     | name
//     | NUMBER
//     | &STRING strings
//     | group_expr
//     | tuple_expr
//     | array_expr
//     | block_expr
std::optional<ast::field<ast::expr>> Parser::parse_atom_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // name
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "atom_expr", _state, tell(), "name");
        auto _user_opt_a = parse_name_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "atom_expr", _state, tell(), "name");
            _res = ast::Name ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "name");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "atom_expr", _state, tell(), "name");
    }
    { // NUMBER
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "atom_expr", _state, tell(), "NUMBER");
        auto _user_opt_a = lexer.expect().token(lex::TokenType::number);
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "atom_expr", _state, tell(), "NUMBER");
            _res = ast::Constant ( util::variant_cast ( a . get_number ( ) . value ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "NUMBER");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "atom_expr", _state, tell(), "NUMBER");
    }
    { // &STRING strings
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "atom_expr", _state, tell(), "&STRING strings");
        auto _tmpvar = lexer.lookahead(true).token(lex::TokenType::string);
        if (_tmpvar) {
        auto _user_opt_a = parse_strings_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "atom_expr", _state, tell(), "&STRING strings");
            _res = ast::Constant ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "&STRING strings");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "atom_expr", _state, tell(), "&STRING strings");
    }
    { // group_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "atom_expr", _state, tell(), "group_expr");
        auto _single_result = parse_group_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "atom_expr", _state, tell(), "group_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "group_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "atom_expr", _state, tell(), "group_expr");
    }
    { // tuple_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "atom_expr", _state, tell(), "tuple_expr");
        auto _single_result = parse_tuple_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "atom_expr", _state, tell(), "tuple_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "tuple_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "atom_expr", _state, tell(), "tuple_expr");
    }
    { // array_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "atom_expr", _state, tell(), "array_expr");
        auto _single_result = parse_array_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "atom_expr", _state, tell(), "array_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "array_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "atom_expr", _state, tell(), "array_expr");
    }
    { // block_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "atom_expr", _state, tell(), "block_expr");
        auto _single_result = parse_block_expr_rule();
        if (_single_result) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "atom_expr", _state, tell(), "block_expr");
            _res = std::move(_single_result);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "block_expr");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "atom_expr", _state, tell(), "block_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "atom_expr");
    --_level;
    return std::nullopt;
}

// call_args: 
std::optional<ast::field<ast::call_args>> Parser::parse_call_args_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::call_args>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::call_args>> _res = std::nullopt;
    { // 
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "call_args", _state, tell(), "");
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "call_args", _state, tell(), "");
            _res = ast::call_args ( ast::make_sequence < ast::call_arg > ( ) , nullptr , nullptr );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "");
            --_level;
            store_cached<RuleType::call_args>(_state, _res);
            return _res;
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "call_args", _state, tell(), "");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "call_args");
    --_level;
    store_cached<RuleType::call_args>(_state, std::nullopt);
    return std::nullopt;
}

// name: NAME
std::optional<std::string> Parser::parse_name_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<std::string> _res = std::nullopt;
    { // NAME
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "name", _state, tell(), "NAME");
        auto _user_opt_a = lexer.expect().token(lex::TokenType::name);
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "name", _state, tell(), "NAME");
            _res = a . get_name ( ) . value;
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "NAME");
            --_level;
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "name", _state, tell(), "NAME");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "name");
    --_level;
    return std::nullopt;
}

// strings: STRING+
std::optional<std::string> Parser::parse_strings_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::strings>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<std::string> _res = std::nullopt;
    { // STRING+
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "strings", _state, tell(), "STRING+");
        auto _user_opt_a = parse__loop1_6_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "strings", _state, tell(), "STRING+");
            _res = _concat_strings ( a );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "STRING+");
            --_level;
            store_cached<RuleType::strings>(_state, _res);
            return _res;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "strings", _state, tell(), "STRING+");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "strings");
    --_level;
    store_cached<RuleType::strings>(_state, std::nullopt);
    return std::nullopt;
}

// group_expr: '(' expr ')'
std::optional<ast::field<ast::expr>> Parser::parse_group_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '(' expr ')'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "group_expr", _state, tell(), "'(' expr ')'");
        auto _literal = lexer.expect().punct(lex::Punct::LPAR);
        if (_literal) {
        auto _user_opt_a = parse_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "group_expr", _state, tell(), "'(' expr ')'");
            _res = std::move ( a );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'(' expr ')'");
            --_level;
            return _res;
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "group_expr", _state, tell(), "'(' expr ')'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "group_expr");
    --_level;
    return std::nullopt;
}

// tuple_expr: '(' ')' | '(' ','.expr+ ','? ')'
std::optional<ast::field<ast::expr>> Parser::parse_tuple_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '(' ')'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "tuple_expr", _state, tell(), "'(' ')'");
        auto _literal = lexer.expect().punct(lex::Punct::LPAR);
        if (_literal) {
        auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "tuple_expr", _state, tell(), "'(' ')'");
            _res = ast::Tuple ( ast::make_sequence < ast::expr > ( ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'(' ')'");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "tuple_expr", _state, tell(), "'(' ')'");
    }
    { // '(' ','.expr+ ','? ')'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "tuple_expr", _state, tell(), "'(' ','.expr+ ','? ')'");
        auto _literal = lexer.expect().punct(lex::Punct::LPAR);
        if (_literal) {
        auto _user_opt_a = parse__gather_7_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _opt_var = lexer.expect().punct(lex::Punct::COMMA);
        if (true) { (void)_opt_var;
        auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "tuple_expr", _state, tell(), "'(' ','.expr+ ','? ')'");
            _res = ast::Tuple ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'(' ','.expr+ ','? ')'");
            --_level;
            return _res;
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "tuple_expr", _state, tell(), "'(' ','.expr+ ','? ')'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "tuple_expr");
    --_level;
    return std::nullopt;
}

// array_expr: '[' ']' | '[' ','.expr+ ','? ']'
std::optional<ast::field<ast::expr>> Parser::parse_array_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '[' ']'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "array_expr", _state, tell(), "'[' ']'");
        auto _literal = lexer.expect().punct(lex::Punct::LSQB);
        if (_literal) {
        auto _literal_1 = lexer.expect().punct(lex::Punct::RSQB);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "array_expr", _state, tell(), "'[' ']'");
            _res = ast::Array ( ast::make_sequence < ast::expr > ( ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'[' ']'");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "array_expr", _state, tell(), "'[' ']'");
    }
    { // '[' ','.expr+ ','? ']'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "array_expr", _state, tell(), "'[' ','.expr+ ','? ']'");
        auto _literal = lexer.expect().punct(lex::Punct::LSQB);
        if (_literal) {
        auto _user_opt_a = parse__gather_9_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _opt_var = lexer.expect().punct(lex::Punct::COMMA);
        if (true) { (void)_opt_var;
        auto _literal_1 = lexer.expect().punct(lex::Punct::RSQB);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "array_expr", _state, tell(), "'[' ','.expr+ ','? ']'");
            _res = ast::Array ( std::move ( a ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'[' ','.expr+ ','? ']'");
            --_level;
            return _res;
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "array_expr", _state, tell(), "'[' ','.expr+ ','? ']'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "array_expr");
    --_level;
    return std::nullopt;
}

// block_expr: 'ctime'? '{' stmt* expr_or_unit '}'
std::optional<ast::field<ast::expr>> Parser::parse_block_expr_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    if (auto _cached = get_cached<RuleType::block_expr>(_state)) {
        --_level;
        return *_cached;
    }
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'ctime'? '{' stmt* expr_or_unit '}'
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "block_expr", _state, tell(), "'ctime'? '{' stmt* expr_or_unit '}'");
        auto _user_opt_c = lexer.expect().keyword(lex::HardKeyword::CTIME);
        if (true) { auto c = _user_opt_c;
        auto _literal = lexer.expect().punct(lex::Punct::LBRACE);
        if (_literal) {
        auto _user_opt_b = parse__loop0_11_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
        auto _user_opt_v = parse_expr_or_unit_rule();
        if (_user_opt_v) { auto v = std::move(*_user_opt_v);
        auto _literal_1 = lexer.expect().punct(lex::Punct::RBRACE);
        if (_literal_1) {
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "block_expr", _state, tell(), "'ctime'? '{' stmt* expr_or_unit '}'");
            _res = ast::Block ( std::move ( b ) , std::move ( v ) , bool ( c ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'ctime'? '{' stmt* expr_or_unit '}'");
            --_level;
            store_cached<RuleType::block_expr>(_state, _res);
            return _res;
        }
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "block_expr", _state, tell(), "'ctime'? '{' stmt* expr_or_unit '}'");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "block_expr");
    --_level;
    store_cached<RuleType::block_expr>(_state, std::nullopt);
    return std::nullopt;
}

// type_annotation: ':' expr
std::optional<ast::field<ast::expr>> Parser::parse_type_annotation_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // ':' expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "type_annotation", _state, tell(), "':' expr");
        auto _literal = lexer.expect().punct(lex::Punct::COLON);
        if (_literal) {
        auto _user_opt_a = parse_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "type_annotation", _state, tell(), "':' expr");
            _res = std::move ( a );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "':' expr");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "type_annotation", _state, tell(), "':' expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "type_annotation");
    --_level;
    return std::nullopt;
}

// func_def: 'func' name '(' func_args_def ')' type_annotation? '=>' block_expr
std::optional<ast::field<ast::expr>> Parser::parse_func_def_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'func' name '(' func_args_def ')' type_annotation? '=>' block_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "func_def", _state, tell(), "'func' name '(' func_args_def ')' type_annotation? '=>' block_expr");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::FUNC);
        if (_keyword) {
        auto _user_opt_n = parse_name_rule();
        if (_user_opt_n) { auto n = std::move(*_user_opt_n);
        auto _literal = lexer.expect().punct(lex::Punct::LPAR);
        if (_literal) {
        auto _user_opt_a = parse_func_args_def_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
        auto _literal_1 = lexer.expect().punct(lex::Punct::RPAR);
        if (_literal_1) {
        auto _user_opt_t = parse_type_annotation_rule();
        if (true) { auto t = _user_opt_t;
        auto _literal_2 = lexer.expect().punct(lex::Punct::RARROW2);
        if (_literal_2) {
        auto _user_opt_b = parse_block_expr_rule();
        if (_user_opt_b) { auto b = std::move(*_user_opt_b);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "func_def", _state, tell(), "'func' name '(' func_args_def ')' type_annotation? '=>' block_expr");
            _res = ast::FuncDef ( std::move ( n ) , std::move ( a ) , _opt2maybe ( std::move ( t ) ) , std::move ( b ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'func' name '(' func_args_def ')' type_annotation? '=>' block_expr");
            --_level;
            return _res;
        }
        }
        }
        }
        }
        }
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "func_def", _state, tell(), "'func' name '(' func_args_def ')' type_annotation? '=>' block_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "func_def");
    --_level;
    return std::nullopt;
}

// func_args_def: 
std::optional<ast::field<ast::arg_defs>> Parser::parse_func_args_def_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::arg_defs>> _res = std::nullopt;
    { // 
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "func_args_def", _state, tell(), "");
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "func_args_def", _state, tell(), "");
            _res = ast::arg_defs ( ast::make_sequence < ast::arg_def > ( ) );
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "");
            --_level;
            return _res;
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "func_args_def", _state, tell(), "");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "func_args_def");
    --_level;
    return std::nullopt;
}

// _loop0_1: stmt
std::optional<ast::sequence<ast::stmt>> Parser::parse__loop0_1_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    std::vector<ast::field<ast::stmt>> _children{};
    { // stmt
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop0_1", _state, tell(), "stmt");
        while (true) {
            auto _single_result = parse_stmt_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "stmt");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop0_1", _state, tell(), "stmt");
    }
    auto _seq = ast::make_sequence<ast::stmt>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _tmp_2: '=' expr
std::optional<ast::field<ast::expr>> Parser::parse__tmp_2_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // '=' expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_2", _state, tell(), "'=' expr");
        auto _literal = lexer.expect().punct(lex::Punct::EQUAL);
        if (_literal) {
        auto _user_opt_a = parse_expr_rule();
        if (_user_opt_a) { auto a = std::move(*_user_opt_a);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_2", _state, tell(), "'=' expr");
            _res = a;
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'=' expr");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_2", _state, tell(), "'=' expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_2");
    --_level;
    return std::nullopt;
}

// _loop1_3: ('or' conjunction_expr)
std::optional<ast::sequence<ast::expr>> Parser::parse__loop1_3_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    std::vector<ast::field<ast::expr>> _children{};
    { // ('or' conjunction_expr)
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop1_3", _state, tell(), "('or' conjunction_expr)");
        while (true) {
            auto _single_result = parse__tmp_12_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "('or' conjunction_expr)");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop1_3", _state, tell(), "('or' conjunction_expr)");
    }
    if (_children.size() == 0) {
        --_level;
        return std::nullopt;
    }
    auto _seq = ast::make_sequence<ast::expr>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _loop1_4: ('and' inversion_expr)
std::optional<ast::sequence<ast::expr>> Parser::parse__loop1_4_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    std::vector<ast::field<ast::expr>> _children{};
    { // ('and' inversion_expr)
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop1_4", _state, tell(), "('and' inversion_expr)");
        while (true) {
            auto _single_result = parse__tmp_13_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "('and' inversion_expr)");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop1_4", _state, tell(), "('and' inversion_expr)");
    }
    if (_children.size() == 0) {
        --_level;
        return std::nullopt;
    }
    auto _seq = ast::make_sequence<ast::expr>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _loop1_5: comparison_followup_pair
std::optional<std::vector<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>>> Parser::parse__loop1_5_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>> _res = std::nullopt;
    std::vector<std::pair < ast::field < ast::cmp_op > , ast::field < ast::expr >>> _children{};
    { // comparison_followup_pair
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop1_5", _state, tell(), "comparison_followup_pair");
        while (true) {
            auto _single_result = parse_comparison_followup_pair_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "comparison_followup_pair");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop1_5", _state, tell(), "comparison_followup_pair");
    }
    if (_children.size() == 0) {
        --_level;
        return std::nullopt;
    }
    --_level;
    return _children;
}

// _loop1_6: STRING
std::optional<std::vector<lex::Token>> Parser::parse__loop1_6_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<lex::Token> _res = std::nullopt;
    std::vector<lex::Token> _children{};
    { // STRING
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop1_6", _state, tell(), "STRING");
        while (true) {
            auto _single_result = lexer.expect().token(lex::TokenType::string);
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "STRING");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop1_6", _state, tell(), "STRING");
    }
    if (_children.size() == 0) {
        --_level;
        return std::nullopt;
    }
    --_level;
    return _children;
}

// _loop0_8: ',' expr
std::optional<ast::sequence<ast::expr>> Parser::parse__loop0_8_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    std::vector<ast::field<ast::expr>> _children{};
    { // ',' expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop0_8", _state, tell(), "',' expr");
        while (true) {
            auto _literal = lexer.expect().punct(lex::Punct::COMMA);
            if (_literal) {
            auto _user_opt_elem = parse_expr_rule();
            if (_user_opt_elem) { auto elem = std::move(*_user_opt_elem);
                _res = elem;
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "',' expr");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop0_8", _state, tell(), "',' expr");
    }
    auto _seq = ast::make_sequence<ast::expr>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _gather_7: expr _loop0_8
std::optional<ast::sequence<ast::expr>> Parser::parse__gather_7_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::sequence<ast::expr>> _res = std::nullopt;
    { // expr _loop0_8
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_gather_7", _state, tell(), "expr _loop0_8");
        auto _user_opt_expr_var = parse_expr_rule();
        if (_user_opt_expr_var) { auto expr_var = std::move(*_user_opt_expr_var);
        auto _user_opt_seq = parse__loop0_8_rule();
        if (_user_opt_seq) { auto seq = std::move(*_user_opt_seq);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_gather_7", _state, tell(), "expr _loop0_8");
            _res = std::move(seq);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr _loop0_8");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_gather_7", _state, tell(), "expr _loop0_8");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_gather_7");
    --_level;
    return std::nullopt;
}

// _loop0_10: ',' expr
std::optional<ast::sequence<ast::expr>> Parser::parse__loop0_10_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    std::vector<ast::field<ast::expr>> _children{};
    { // ',' expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop0_10", _state, tell(), "',' expr");
        while (true) {
            auto _literal = lexer.expect().punct(lex::Punct::COMMA);
            if (_literal) {
            auto _user_opt_elem = parse_expr_rule();
            if (_user_opt_elem) { auto elem = std::move(*_user_opt_elem);
                _res = elem;
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "',' expr");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop0_10", _state, tell(), "',' expr");
    }
    auto _seq = ast::make_sequence<ast::expr>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _gather_9: expr _loop0_10
std::optional<ast::sequence<ast::expr>> Parser::parse__gather_9_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::sequence<ast::expr>> _res = std::nullopt;
    { // expr _loop0_10
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_gather_9", _state, tell(), "expr _loop0_10");
        auto _user_opt_expr_var = parse_expr_rule();
        if (_user_opt_expr_var) { auto expr_var = std::move(*_user_opt_expr_var);
        auto _user_opt_seq = parse__loop0_10_rule();
        if (_user_opt_seq) { auto seq = std::move(*_user_opt_seq);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_gather_9", _state, tell(), "expr _loop0_10");
            _res = std::move(seq);
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "expr _loop0_10");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_gather_9", _state, tell(), "expr _loop0_10");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_gather_9");
    --_level;
    return std::nullopt;
}

// _loop0_11: stmt
std::optional<ast::sequence<ast::stmt>> Parser::parse__loop0_11_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    auto _state = tell();
    std::optional<ast::field<ast::stmt>> _res = std::nullopt;
    std::vector<ast::field<ast::stmt>> _children{};
    { // stmt
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_loop0_11", _state, tell(), "stmt");
        while (true) {
            auto _single_result = parse_stmt_rule();
            if (_single_result) {
                _res = std::move(_single_result);
                PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "stmt");
                _children.push_back(std::move(*_res));
                _state = tell();
                continue;
            }
            break;
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_loop0_11", _state, tell(), "stmt");
    }
    auto _seq = ast::make_sequence<ast::stmt>();
    for (auto &_child : _children) {
        _seq->push_back(std::move(*_child));
    }
    --_level;
    return _seq;
}

// _tmp_12: 'or' conjunction_expr
std::optional<ast::field<ast::expr>> Parser::parse__tmp_12_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'or' conjunction_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_12", _state, tell(), "'or' conjunction_expr");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::OR);
        if (_keyword) {
        auto _user_opt_c = parse_conjunction_expr_rule();
        if (_user_opt_c) { auto c = std::move(*_user_opt_c);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_12", _state, tell(), "'or' conjunction_expr");
            _res = c;
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'or' conjunction_expr");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_12", _state, tell(), "'or' conjunction_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_12");
    --_level;
    return std::nullopt;
}

// _tmp_13: 'and' inversion_expr
std::optional<ast::field<ast::expr>> Parser::parse__tmp_13_rule()
{
    if (++_level > MAX_RECURSION_LEVEL) {
        throw SyntaxError("Recursion limit exceeded");
    }
    const auto _state = tell();
    (void)_state;
    std::optional<ast::field<ast::expr>> _res = std::nullopt;
    { // 'and' inversion_expr
        PARSER_DBG_("%*c> %s[%zu-%zu]: %s\n", _level, ' ', "_tmp_13", _state, tell(), "'and' inversion_expr");
        auto _keyword = lexer.expect().keyword(lex::HardKeyword::AND);
        if (_keyword) {
        auto _user_opt_c = parse_inversion_expr_rule();
        if (_user_opt_c) { auto c = std::move(*_user_opt_c);
            PARSER_DBG_("%*c+ %s[%zu-%zu]: %s succeeded!\n", _level, ' ', "_tmp_13", _state, tell(), "'and' inversion_expr");
            _res = c;
            PARSER_DBG_("Hit with action [%zu-%zu]: %s\n", _state, tell(), "'and' inversion_expr");
            --_level;
            return _res;
        }
        }
        seek(_state);
        PARSER_DBG_("%*c- %s[%zu-%zu]: %s failed!\n", _level, ' ', "_tmp_13", _state, tell(), "'and' inversion_expr");
    }
    PARSER_DBG_("Fail at %zu: %s\n", _state, "_tmp_13");
    --_level;
    return std::nullopt;
}

#pragma endregion Rule parsers


}  // namespace bondrewd::parse
